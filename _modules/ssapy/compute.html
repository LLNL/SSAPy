

<!DOCTYPE html>
<html class="writer-html5" lang="en">
<head>
  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1.0" />
  <title>ssapy.compute &mdash; SSAPy  documentation</title>
      <link rel="stylesheet" type="text/css" href="../../_static/pygments.css?v=b86133f3" />
      <link rel="stylesheet" type="text/css" href="../../_static/css/theme.css?v=e59714d7" />
      <link rel="stylesheet" type="text/css" href="../../_static/copybutton.css?v=76b2166b" />
      <link rel="stylesheet" type="text/css" href="../../_static/graphviz.css?v=eafc0fe6" />

  
    <link rel="shortcut icon" href="../../_static/ssapy_logo.ico"/>
      <script src="../../_static/jquery.js?v=5d32c60e"></script>
      <script src="../../_static/_sphinx_javascript_frameworks_compat.js?v=2cd50e6c"></script>
      <script data-url_root="../../" id="documentation_options" src="../../_static/documentation_options.js?v=b3ba4146"></script>
      <script src="../../_static/doctools.js?v=888ff710"></script>
      <script src="../../_static/sphinx_highlight.js?v=4825356b"></script>
      <script src="../../_static/clipboard.min.js?v=a7894cd8"></script>
      <script src="../../_static/copybutton.js?v=f281be69"></script>
    <script src="../../_static/js/theme.js"></script>
    <link rel="index" title="Index" href="../../genindex.html" />
    <link rel="search" title="Search" href="../../search.html" /> 
</head>

<body class="wy-body-for-nav"> 
  <div class="wy-grid-for-nav">
    <nav data-toggle="wy-nav-shift" class="wy-nav-side">
      <div class="wy-side-scroll">
        <div class="wy-side-nav-search" >

          
          
          <a href="../../index.html">
            
              <img src="../../_static/ssapy_logo.svg" class="logo" alt="Logo"/>
          </a>
<div role="search">
  <form id="rtd-search-form" class="wy-form" action="../../search.html" method="get">
    <input type="text" name="q" placeholder="Search docs" aria-label="Search docs" />
    <input type="hidden" name="check_keywords" value="yes" />
    <input type="hidden" name="area" value="default" />
  </form>
</div>
        </div><div class="wy-menu wy-menu-vertical" data-spy="affix" role="navigation" aria-label="Navigation menu">
              <p class="caption" role="heading"><span class="caption-text">Basics</span></p>
<ul>
<li class="toctree-l1"><a class="reference internal" href="../../installation.html">Getting Started</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../examples.html">SSAPy by Example</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../benchmarks.html">SSAPy Benchmarks</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../concepts.html">SSAPy Concepts</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../contribution_guide.html">Contribution Guide</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../references.html">References</a></li>
</ul>
<p class="caption" role="heading"><span class="caption-text">API DOCS</span></p>
<ul>
<li class="toctree-l1"><a class="reference internal" href="../../api.html">API Reference Guide</a></li>
</ul>

        </div>
      </div>
    </nav>

    <section data-toggle="wy-nav-shift" class="wy-nav-content-wrap"><nav class="wy-nav-top" aria-label="Mobile navigation menu" >
          <i data-toggle="wy-nav-top" class="fa fa-bars"></i>
          <a href="../../index.html">SSAPy</a>
      </nav>

      <div class="wy-nav-content">
        <div class="rst-content">
          <div role="navigation" aria-label="Page navigation">
  <ul class="wy-breadcrumbs">
      <li><a href="../../index.html" class="icon icon-home" aria-label="Home"></a></li>
          <li class="breadcrumb-item"><a href="../index.html">Module code</a></li>
      <li class="breadcrumb-item active">ssapy.compute</li>
      <li class="wy-breadcrumbs-aside">
      </li>
  </ul>
  <hr/>
</div>
          <div role="main" class="document" itemscope="itemscope" itemtype="http://schema.org/Article">
           <div itemprop="articleBody">
             
  <h1>Source code for ssapy.compute</h1><div class="highlight"><pre>
<span></span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">Tools for orbital dynamics, satellite tracking, and celestial mechanics.</span>
<span class="sd">&quot;&quot;&quot;</span>

<span class="kn">import</span><span class="w"> </span><span class="nn">numpy</span><span class="w"> </span><span class="k">as</span><span class="w"> </span><span class="nn">np</span>
<span class="kn">from</span><span class="w"> </span><span class="nn">astropy.time</span><span class="w"> </span><span class="kn">import</span> <span class="n">Time</span>
<span class="kn">import</span><span class="w"> </span><span class="nn">astropy.units</span><span class="w"> </span><span class="k">as</span><span class="w"> </span><span class="nn">u</span>

<span class="kn">from</span><span class="w"> </span><span class="nn">.body</span><span class="w"> </span><span class="kn">import</span> <span class="n">get_body</span>
<span class="kn">from</span><span class="w"> </span><span class="nn">.constants</span><span class="w"> </span><span class="kn">import</span> <span class="n">RGEO</span><span class="p">,</span> <span class="n">LD</span><span class="p">,</span> <span class="n">EARTH_RADIUS</span><span class="p">,</span> <span class="n">EARTH_MU</span><span class="p">,</span> <span class="n">MOON_RADIUS</span><span class="p">,</span> <span class="n">MOON_MU</span>
<span class="kn">from</span><span class="w"> </span><span class="nn">.propagator</span><span class="w"> </span><span class="kn">import</span> <span class="n">KeplerianPropagator</span>
<span class="kn">from</span><span class="w"> </span><span class="nn">.utils</span><span class="w"> </span><span class="kn">import</span> <span class="p">(</span>
    <span class="n">norm</span><span class="p">,</span> <span class="n">normed</span><span class="p">,</span> <span class="n">unitAngle3</span><span class="p">,</span> <span class="n">get_angle</span><span class="p">,</span> <span class="n">LRU_Cache</span><span class="p">,</span> <span class="n">lb_to_unit</span><span class="p">,</span> <span class="n">sunPos</span><span class="p">,</span> <span class="n">_gpsToTT</span><span class="p">,</span>
    <span class="n">iers_interp</span><span class="p">,</span> <span class="n">rotation_matrix_from_vectors</span><span class="p">,</span> <span class="n">angle_between_vectors</span><span class="p">,</span> <span class="n">gcrf_to_itrf</span>
<span class="p">)</span>
<span class="kn">from</span><span class="w"> </span><span class="nn">.orbit</span><span class="w"> </span><span class="kn">import</span> <span class="n">Orbit</span>
<span class="kn">from</span><span class="w"> </span><span class="nn">.ellipsoid</span><span class="w"> </span><span class="kn">import</span> <span class="n">Ellipsoid</span>

<span class="k">try</span><span class="p">:</span>
    <span class="kn">import</span><span class="w"> </span><span class="nn">erfa</span>
<span class="k">except</span> <span class="ne">ImportError</span><span class="p">:</span>
    <span class="c1"># Let this raise</span>
    <span class="kn">import</span><span class="w"> </span><span class="nn">astropy._erfa</span><span class="w"> </span><span class="k">as</span><span class="w"> </span><span class="nn">erfa</span>


<span class="k">def</span><span class="w"> </span><span class="nf">_doSqueeze</span><span class="p">(</span><span class="n">squeezeOrbit</span><span class="p">,</span> <span class="n">squeezeTime</span><span class="p">,</span> <span class="o">*</span><span class="n">args</span><span class="p">):</span>
    <span class="n">out</span> <span class="o">=</span> <span class="p">[]</span>
    <span class="k">for</span> <span class="n">i</span><span class="p">,</span> <span class="n">arg</span> <span class="ow">in</span> <span class="nb">enumerate</span><span class="p">(</span><span class="n">args</span><span class="p">):</span>
        <span class="k">if</span> <span class="n">squeezeTime</span><span class="p">:</span>
            <span class="k">if</span> <span class="n">squeezeOrbit</span><span class="p">:</span>
                <span class="n">out</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">arg</span><span class="p">[</span><span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">])</span>  <span class="c1"># scalar</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="n">out</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">squeeze</span><span class="p">(</span><span class="n">arg</span><span class="p">,</span> <span class="n">axis</span><span class="o">=</span><span class="mi">1</span><span class="p">))</span>  <span class="c1"># (nOrbit,)</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="k">if</span> <span class="n">squeezeOrbit</span><span class="p">:</span>
                <span class="n">out</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">squeeze</span><span class="p">(</span><span class="n">arg</span><span class="p">,</span> <span class="n">axis</span><span class="o">=</span><span class="mi">0</span><span class="p">))</span>  <span class="c1"># (nTime,)</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="n">out</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">arg</span><span class="p">)</span>  <span class="c1"># (nOrbit, nTime)</span>
    <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">out</span><span class="p">)</span> <span class="o">==</span> <span class="mi">1</span><span class="p">:</span>
        <span class="k">return</span> <span class="n">out</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span>
    <span class="k">return</span> <span class="nb">tuple</span><span class="p">(</span><span class="n">out</span><span class="p">)</span>


<span class="k">def</span><span class="w"> </span><span class="nf">_countOrbit</span><span class="p">(</span><span class="n">orbit</span><span class="p">):</span>
    <span class="c1"># orbit is one of:</span>
    <span class="c1"># 1) scalar Orbit</span>
    <span class="c1"># 2) vector Orbit</span>
    <span class="c1"># 3) list of scalar Orbit</span>
    <span class="c1"># convert to (2), set nOrbit, squeezeOrbit, and orbit.</span>

    <span class="c1"># check 1) and 2)</span>
    <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">orbit</span><span class="p">,</span> <span class="n">Orbit</span><span class="p">):</span>
        <span class="c1"># check shape of r to decide scalar vs vector</span>
        <span class="k">if</span> <span class="n">orbit</span><span class="o">.</span><span class="n">r</span><span class="o">.</span><span class="n">ndim</span> <span class="o">==</span> <span class="mi">1</span><span class="p">:</span>  <span class="c1"># scalar Orbit</span>
            <span class="n">nOrbit</span> <span class="o">=</span> <span class="mi">1</span>
            <span class="n">squeezeOrbit</span> <span class="o">=</span> <span class="kc">True</span>
            <span class="k">if</span> <span class="s1">&#39;kozaiMeanKeplerianElements&#39;</span> <span class="ow">in</span> <span class="n">orbit</span><span class="o">.</span><span class="vm">__dict__</span><span class="p">:</span>
                <span class="n">kMKE</span> <span class="o">=</span> <span class="n">orbit</span><span class="o">.</span><span class="vm">__dict__</span><span class="p">[</span><span class="s1">&#39;kozaiMeanKeplerianElements&#39;</span><span class="p">]</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="n">kMKE</span> <span class="o">=</span> <span class="kc">None</span>
            <span class="n">orbit</span> <span class="o">=</span> <span class="n">Orbit</span><span class="p">(</span>
                <span class="n">np</span><span class="o">.</span><span class="n">atleast_2d</span><span class="p">(</span><span class="n">orbit</span><span class="o">.</span><span class="n">r</span><span class="p">),</span>
                <span class="n">np</span><span class="o">.</span><span class="n">atleast_2d</span><span class="p">(</span><span class="n">orbit</span><span class="o">.</span><span class="n">v</span><span class="p">),</span>
                <span class="n">np</span><span class="o">.</span><span class="n">atleast_1d</span><span class="p">(</span><span class="n">orbit</span><span class="o">.</span><span class="n">t</span><span class="p">),</span>
                <span class="n">mu</span><span class="o">=</span><span class="n">orbit</span><span class="o">.</span><span class="n">mu</span><span class="p">,</span>
                <span class="n">propkw</span><span class="o">=</span><span class="p">{</span><span class="n">k</span><span class="p">:</span> <span class="n">np</span><span class="o">.</span><span class="n">atleast_1d</span><span class="p">(</span><span class="n">v</span><span class="p">)</span> <span class="k">for</span> <span class="n">k</span><span class="p">,</span> <span class="n">v</span> <span class="ow">in</span> <span class="n">orbit</span><span class="o">.</span><span class="n">propkw</span><span class="o">.</span><span class="n">items</span><span class="p">()},</span>
            <span class="p">)</span>
            <span class="c1"># Copying just kozaiMeanKeplerianElements for now, though maybe</span>
            <span class="c1"># ought to retain other (all?) lazy_properties attributes too?</span>
            <span class="k">if</span> <span class="n">kMKE</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
                <span class="n">orbit</span><span class="o">.</span><span class="n">kozaiMeanKeplerianElements</span> <span class="o">=</span> <span class="n">kMKE</span>
        <span class="k">else</span><span class="p">:</span>  <span class="c1"># vector Orbit</span>
            <span class="n">nOrbit</span> <span class="o">=</span> <span class="n">orbit</span><span class="o">.</span><span class="n">r</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span>
            <span class="n">squeezeOrbit</span> <span class="o">=</span> <span class="kc">False</span>
    <span class="k">else</span><span class="p">:</span>
        <span class="kn">import</span><span class="w"> </span><span class="nn">warnings</span>
        <span class="n">warnings</span><span class="o">.</span><span class="n">warn</span><span class="p">(</span>
            <span class="s2">&quot;list of Orbit syntax is deprecated.  &quot;</span>
            <span class="s2">&quot;Please use a vector Orbit instead.&quot;</span><span class="p">,</span>
            <span class="ne">DeprecationWarning</span>
        <span class="p">)</span>
        <span class="c1"># list of scalar orbit</span>
        <span class="n">nOrbit</span> <span class="o">=</span> <span class="nb">len</span><span class="p">(</span><span class="n">orbit</span><span class="p">)</span>
        <span class="n">squeezeOrbit</span> <span class="o">=</span> <span class="kc">False</span>
        <span class="c1"># assumes all orbits have the same keywords and mu!</span>
        <span class="n">propkeys</span> <span class="o">=</span> <span class="p">[]</span> <span class="k">if</span> <span class="n">nOrbit</span> <span class="o">==</span> <span class="mi">0</span> <span class="k">else</span> <span class="n">orbit</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span><span class="o">.</span><span class="n">propkw</span><span class="o">.</span><span class="n">keys</span><span class="p">()</span>
        <span class="n">mu</span> <span class="o">=</span> <span class="kc">None</span> <span class="k">if</span> <span class="n">nOrbit</span> <span class="o">==</span> <span class="mi">0</span> <span class="k">else</span> <span class="n">orbit</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span><span class="o">.</span><span class="n">mu</span>
        <span class="n">orbit</span> <span class="o">=</span> <span class="n">Orbit</span><span class="p">(</span>
            <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">([</span><span class="n">o</span><span class="o">.</span><span class="n">r</span> <span class="k">for</span> <span class="n">o</span> <span class="ow">in</span> <span class="n">orbit</span><span class="p">]),</span>
            <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">([</span><span class="n">o</span><span class="o">.</span><span class="n">v</span> <span class="k">for</span> <span class="n">o</span> <span class="ow">in</span> <span class="n">orbit</span><span class="p">]),</span>
            <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">([</span><span class="n">o</span><span class="o">.</span><span class="n">t</span> <span class="k">for</span> <span class="n">o</span> <span class="ow">in</span> <span class="n">orbit</span><span class="p">]),</span>
            <span class="n">mu</span><span class="o">=</span><span class="n">mu</span><span class="p">,</span>
            <span class="n">propkw</span><span class="o">=</span><span class="p">{</span><span class="n">k</span><span class="p">:</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">([</span><span class="n">o</span><span class="o">.</span><span class="n">propkw</span><span class="p">[</span><span class="n">k</span><span class="p">]</span> <span class="k">for</span> <span class="n">o</span> <span class="ow">in</span> <span class="n">orbit</span><span class="p">])</span>
                    <span class="k">for</span> <span class="n">k</span> <span class="ow">in</span> <span class="n">propkeys</span><span class="p">}</span>
        <span class="p">)</span>
    <span class="k">return</span> <span class="n">nOrbit</span><span class="p">,</span> <span class="n">squeezeOrbit</span><span class="p">,</span> <span class="n">orbit</span>


<span class="k">def</span><span class="w"> </span><span class="nf">_countTime</span><span class="p">(</span><span class="n">time</span><span class="p">):</span>
    <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">time</span><span class="p">,</span> <span class="n">Time</span><span class="p">):</span>
        <span class="n">time</span> <span class="o">=</span> <span class="n">time</span><span class="o">.</span><span class="n">gps</span>
    <span class="n">squeezeTime</span> <span class="o">=</span> <span class="kc">False</span>
    <span class="k">try</span><span class="p">:</span>
        <span class="n">nTime</span> <span class="o">=</span> <span class="nb">len</span><span class="p">(</span><span class="n">time</span><span class="p">)</span>
    <span class="k">except</span> <span class="ne">TypeError</span><span class="p">:</span>
        <span class="n">time</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">([</span><span class="n">time</span><span class="p">])</span>
        <span class="n">nTime</span> <span class="o">=</span> <span class="mi">1</span>
        <span class="n">squeezeTime</span> <span class="o">=</span> <span class="kc">True</span>
    <span class="k">return</span> <span class="n">nTime</span><span class="p">,</span> <span class="n">squeezeTime</span><span class="p">,</span> <span class="n">time</span>


<span class="k">def</span><span class="w"> </span><span class="nf">_countR</span><span class="p">(</span><span class="n">r</span><span class="p">):</span>
    <span class="c1"># orbit is one of:</span>
    <span class="c1"># 1) scalar r</span>
    <span class="c1"># 2) vector r</span>
    <span class="c1"># 3) list of scalar Orbit</span>
    <span class="c1"># convert to (2), set nOrbit, squeezeOrbit, and orbit.</span>
    <span class="n">squeezeR</span> <span class="o">=</span> <span class="kc">False</span>
    <span class="k">if</span> <span class="n">np</span><span class="o">.</span><span class="n">shape</span><span class="p">(</span><span class="n">r</span><span class="p">)[</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span> <span class="o">==</span> <span class="mi">3</span><span class="p">:</span>
        <span class="k">pass</span>
    <span class="k">else</span><span class="p">:</span>
        <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;Incorrect r dimensions. Expected shape (n, 3), but got </span><span class="si">{</span><span class="n">np</span><span class="o">.</span><span class="n">shape</span><span class="p">(</span><span class="n">r</span><span class="p">)</span><span class="si">}</span><span class="s2">.&quot;</span><span class="p">)</span>
    <span class="c1"># check 1) and 2)</span>
    <span class="k">if</span> <span class="n">r</span><span class="o">.</span><span class="n">ndim</span> <span class="o">&lt;</span> <span class="mi">3</span><span class="p">:</span>  <span class="c1"># scalar r</span>
        <span class="n">nR</span> <span class="o">=</span> <span class="mi">1</span>
        <span class="n">r</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">reshape</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">atleast_3d</span><span class="p">(</span><span class="n">r</span><span class="p">),</span> <span class="p">(</span><span class="n">nR</span><span class="p">,</span> <span class="n">np</span><span class="o">.</span><span class="n">shape</span><span class="p">(</span><span class="n">r</span><span class="p">)[</span><span class="mi">0</span><span class="p">],</span> <span class="n">np</span><span class="o">.</span><span class="n">shape</span><span class="p">(</span><span class="n">r</span><span class="p">)[</span><span class="mi">1</span><span class="p">]))</span>
        <span class="n">squeezeR</span> <span class="o">=</span> <span class="kc">True</span>
    <span class="k">else</span><span class="p">:</span>
        <span class="n">nR</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">shape</span><span class="p">(</span><span class="n">r</span><span class="p">)[</span><span class="mi">0</span><span class="p">]</span>
    <span class="k">return</span> <span class="n">nR</span><span class="p">,</span> <span class="n">squeezeR</span><span class="p">,</span> <span class="n">r</span>


<span class="k">def</span><span class="w"> </span><span class="nf">_processObserver</span><span class="p">(</span>
    <span class="n">observer</span><span class="p">,</span> <span class="n">obsPos</span><span class="p">,</span> <span class="n">obsVel</span><span class="p">,</span> <span class="n">nTime</span><span class="p">,</span> <span class="n">squeezeTime</span><span class="p">,</span> <span class="n">time</span><span class="p">,</span> <span class="n">doObsVel</span><span class="o">=</span><span class="kc">False</span>
<span class="p">):</span>
    <span class="c1"># We always need obsPos output, but only sometimes obsVel.  So only require</span>
    <span class="c1"># obsVel if doObsVel is True.  (but always return it, and always compute it</span>
    <span class="c1"># if what we got as input was in an observer).</span>
    <span class="n">squeezeObsPos</span> <span class="o">=</span> <span class="kc">False</span>
    <span class="k">if</span> <span class="n">observer</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
        <span class="k">if</span> <span class="n">obsPos</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
            <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span>
                <span class="s2">&quot;Exactly one of obsPos and observer must be specified&quot;</span>
            <span class="p">)</span>
        <span class="k">if</span> <span class="n">doObsVel</span> <span class="ow">and</span> <span class="n">obsVel</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
            <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span>
                <span class="s2">&quot;Exactly one of obsVel and observer required for doObsVel&quot;</span>
            <span class="p">)</span>

    <span class="k">if</span> <span class="n">observer</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
        <span class="k">if</span> <span class="n">obsPos</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
            <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span>
                <span class="s2">&quot;Exactly one of obsPos and observer must be specified&quot;</span>
            <span class="p">)</span>
        <span class="k">if</span> <span class="n">doObsVel</span> <span class="ow">and</span> <span class="n">obsVel</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
            <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span>
                <span class="s2">&quot;Exactly one of obsVel and observer required for doObsVel&quot;</span>
            <span class="p">)</span>
        <span class="k">try</span><span class="p">:</span>
            <span class="n">nObservers</span> <span class="o">=</span> <span class="nb">len</span><span class="p">(</span><span class="n">observer</span><span class="p">)</span>
        <span class="k">except</span> <span class="ne">TypeError</span><span class="p">:</span>
            <span class="n">observer</span> <span class="o">=</span> <span class="p">[</span><span class="n">observer</span><span class="p">]</span>
            <span class="n">nObservers</span> <span class="o">=</span> <span class="mi">1</span>
            <span class="n">squeezeObsPos</span> <span class="o">=</span> <span class="n">squeezeTime</span>
        <span class="c1"># Now generate obsPos</span>
        <span class="k">if</span> <span class="n">nObservers</span> <span class="o">==</span> <span class="n">nTime</span><span class="p">:</span>
            <span class="n">obsPos</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">empty</span><span class="p">((</span><span class="n">nObservers</span><span class="p">,</span> <span class="mi">3</span><span class="p">),</span> <span class="n">dtype</span><span class="o">=</span><span class="nb">float</span><span class="p">)</span>
            <span class="n">obsVel</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">empty</span><span class="p">((</span><span class="n">nObservers</span><span class="p">,</span> <span class="mi">3</span><span class="p">),</span> <span class="n">dtype</span><span class="o">=</span><span class="nb">float</span><span class="p">)</span>
            <span class="k">for</span> <span class="n">i</span><span class="p">,</span> <span class="p">(</span><span class="n">obs</span><span class="p">,</span> <span class="n">t</span><span class="p">)</span> <span class="ow">in</span> <span class="nb">enumerate</span><span class="p">(</span><span class="nb">zip</span><span class="p">(</span><span class="n">observer</span><span class="p">,</span> <span class="n">time</span><span class="p">)):</span>
                <span class="n">obsPos</span><span class="p">[</span><span class="n">i</span><span class="p">],</span> <span class="n">obsVel</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">=</span> <span class="n">obs</span><span class="o">.</span><span class="n">getRV</span><span class="p">(</span><span class="n">t</span><span class="p">)</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="k">if</span> <span class="n">nObservers</span> <span class="o">==</span> <span class="mi">1</span><span class="p">:</span>
                <span class="n">obsPos</span><span class="p">,</span> <span class="n">obsVel</span> <span class="o">=</span> <span class="n">observer</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span><span class="o">.</span><span class="n">getRV</span><span class="p">(</span><span class="n">time</span><span class="p">)</span>
            <span class="k">elif</span> <span class="n">nTime</span> <span class="o">==</span> <span class="mi">1</span><span class="p">:</span>
                <span class="n">obsPos</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">empty</span><span class="p">((</span><span class="n">nObservers</span><span class="p">,</span> <span class="mi">3</span><span class="p">),</span> <span class="n">dtype</span><span class="o">=</span><span class="nb">float</span><span class="p">)</span>
                <span class="n">obsVel</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">empty</span><span class="p">((</span><span class="n">nObservers</span><span class="p">,</span> <span class="mi">3</span><span class="p">),</span> <span class="n">dtype</span><span class="o">=</span><span class="nb">float</span><span class="p">)</span>
                <span class="k">for</span> <span class="n">i</span><span class="p">,</span> <span class="n">obs</span> <span class="ow">in</span> <span class="nb">enumerate</span><span class="p">(</span><span class="n">observer</span><span class="p">):</span>
                    <span class="n">obsPos</span><span class="p">[</span><span class="n">i</span><span class="p">],</span> <span class="n">obsVel</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">=</span> <span class="n">obs</span><span class="o">.</span><span class="n">getRV</span><span class="p">(</span><span class="n">time</span><span class="p">[</span><span class="mi">0</span><span class="p">])</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s2">&quot;observer and time must be broadcastable&quot;</span><span class="p">)</span>

    <span class="k">if</span> <span class="n">doObsVel</span><span class="p">:</span>
        <span class="n">obsPos</span><span class="p">,</span> <span class="n">obsVel</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">broadcast_arrays</span><span class="p">(</span><span class="n">obsPos</span><span class="p">,</span> <span class="n">obsVel</span><span class="p">)</span>
    <span class="n">obsPos</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">atleast_1d</span><span class="p">(</span><span class="n">obsPos</span><span class="p">)</span>
    <span class="k">if</span> <span class="n">obsPos</span><span class="o">.</span><span class="n">ndim</span> <span class="o">==</span> <span class="mi">2</span><span class="p">:</span>
        <span class="n">nObsPos</span> <span class="o">=</span> <span class="n">obsPos</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span>
    <span class="k">else</span><span class="p">:</span>
        <span class="n">obsPos</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">atleast_2d</span><span class="p">(</span><span class="n">obsPos</span><span class="p">)</span>
        <span class="n">nObsPos</span> <span class="o">=</span> <span class="mi">1</span>
        <span class="n">squeezeObsPos</span> <span class="o">=</span> <span class="kc">True</span>
    <span class="c1"># times and obsPos must align</span>
    <span class="k">if</span> <span class="n">nObsPos</span> <span class="o">!=</span> <span class="n">nTime</span><span class="p">:</span>
        <span class="k">if</span> <span class="n">nObsPos</span> <span class="o">==</span> <span class="mi">1</span><span class="p">:</span>
            <span class="n">obsPos</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">broadcast_to</span><span class="p">(</span><span class="n">obsPos</span><span class="p">,</span> <span class="p">(</span><span class="n">nTime</span><span class="p">,</span> <span class="mi">3</span><span class="p">))</span>
            <span class="k">if</span> <span class="n">doObsVel</span><span class="p">:</span>
                <span class="n">obsVel</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">broadcast_to</span><span class="p">(</span><span class="n">obsVel</span><span class="p">,</span> <span class="p">(</span><span class="n">nTime</span><span class="p">,</span> <span class="mi">3</span><span class="p">))</span>
            <span class="n">nObsPos</span> <span class="o">=</span> <span class="n">nTime</span>
        <span class="k">elif</span> <span class="n">nTime</span> <span class="o">==</span> <span class="mi">1</span><span class="p">:</span>
            <span class="n">time</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">broadcast_to</span><span class="p">(</span><span class="n">time</span><span class="p">,</span> <span class="p">(</span><span class="n">nObsPos</span><span class="p">,))</span>
            <span class="n">nTime</span> <span class="o">=</span> <span class="n">nObsPos</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s2">&quot;obsPos and time must be broadcastable&quot;</span><span class="p">)</span>
    <span class="n">squeezeTime</span> <span class="o">&amp;=</span> <span class="n">squeezeObsPos</span>
    <span class="k">return</span> <span class="n">obsPos</span><span class="p">,</span> <span class="n">obsVel</span><span class="p">,</span> <span class="n">time</span><span class="p">,</span> <span class="n">squeezeTime</span>


<div class="viewcode-block" id="HashableArrayContainer"><a class="viewcode-back" href="../../api/ssapy.compute.HashableArrayContainer.html#ssapy.compute.HashableArrayContainer">[docs]</a><span class="k">class</span><span class="w"> </span><span class="nc">HashableArrayContainer</span><span class="p">:</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    A container for NumPy arrays that makes them hashable and immutable.</span>

<span class="sd">    This class wraps a NumPy array and ensures that it is immutable by setting</span>
<span class="sd">    its `writeable` flag to `False`. It also provides implementations for</span>
<span class="sd">    `__hash__` and `__eq__`, enabling the wrapped array to be used as a key in</span>
<span class="sd">    hash-based data structures like dictionaries and sets.</span>

<span class="sd">    Attributes:</span>
<span class="sd">        arr (numpy.ndarray): The wrapped NumPy array, which is immutable.</span>

<span class="sd">    Methods:</span>
<span class="sd">        __hash__():</span>
<span class="sd">            Returns a hash value for the array based on its byte representation.</span>
<span class="sd">        </span>
<span class="sd">        __eq__(rhs):</span>
<span class="sd">            Compares the wrapped array with another `HashableArrayContainer` instance</span>
<span class="sd">            for equality based on element-wise comparison.</span>
<span class="sd">    </span>
<span class="sd">    Examples:</span>
<span class="sd">        &gt;&gt;&gt; import numpy as np</span>
<span class="sd">        &gt;&gt;&gt; arr1 = np.array([1, 2, 3])</span>
<span class="sd">        &gt;&gt;&gt; arr2 = np.array([1, 2, 3])</span>
<span class="sd">        &gt;&gt;&gt; container1 = HashableArrayContainer(arr1)</span>
<span class="sd">        &gt;&gt;&gt; container2 = HashableArrayContainer(arr2)</span>
<span class="sd">        &gt;&gt;&gt; container1 == container2</span>
<span class="sd">        True</span>
<span class="sd">        &gt;&gt;&gt; hash(container1) == hash(container2)</span>
<span class="sd">        True</span>
<span class="sd">        &gt;&gt;&gt; my_dict = {container1: &quot;value&quot;}</span>
<span class="sd">        &gt;&gt;&gt; my_dict[container2]</span>
<span class="sd">        &#39;value&#39;</span>
<span class="sd">    &quot;&quot;&quot;</span>

    <span class="k">def</span><span class="w"> </span><span class="fm">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">arr</span><span class="p">):</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">arr</span> <span class="o">=</span> <span class="n">arr</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">arr</span><span class="o">.</span><span class="n">flags</span><span class="o">.</span><span class="n">writeable</span> <span class="o">=</span> <span class="kc">False</span>

<div class="viewcode-block" id="HashableArrayContainer.__hash__"><a class="viewcode-back" href="../../api/ssapy.compute.HashableArrayContainer.html#ssapy.compute.HashableArrayContainer.__hash__">[docs]</a>    <span class="k">def</span><span class="w"> </span><span class="fm">__hash__</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="k">return</span> <span class="nb">hash</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">arr</span><span class="o">.</span><span class="n">data</span><span class="o">.</span><span class="n">tobytes</span><span class="p">())</span></div>

<div class="viewcode-block" id="HashableArrayContainer.__eq__"><a class="viewcode-back" href="../../api/ssapy.compute.HashableArrayContainer.html#ssapy.compute.HashableArrayContainer.__eq__">[docs]</a>    <span class="k">def</span><span class="w"> </span><span class="fm">__eq__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">rhs</span><span class="p">):</span>
        <span class="k">return</span> <span class="n">np</span><span class="o">.</span><span class="n">all</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">arr</span> <span class="o">==</span> <span class="n">rhs</span><span class="o">.</span><span class="n">arr</span><span class="p">)</span></div></div>


<div class="viewcode-block" id="rv"><a class="viewcode-back" href="../../api/ssapy.compute.rv.html#ssapy.compute.rv">[docs]</a><span class="k">def</span><span class="w"> </span><span class="nf">rv</span><span class="p">(</span><span class="n">orbit</span><span class="p">,</span> <span class="n">time</span><span class="p">,</span> <span class="n">propagator</span><span class="o">=</span><span class="n">KeplerianPropagator</span><span class="p">()):</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;Calculate positions and velocities on the outer product of all supplied</span>
<span class="sd">    orbits and times.</span>

<span class="sd">    Parameters</span>
<span class="sd">    ----------</span>
<span class="sd">    orbit : Orbit or list of Orbit (n,)</span>
<span class="sd">        Desired orbit(s)</span>
<span class="sd">    time : array_like or astropy.time.Time (m,)</span>
<span class="sd">        If float (array), then should correspond to GPS seconds; i.e., seconds</span>
<span class="sd">        since 1980-01-06 00:00:00 UTC</span>
<span class="sd">    propagator : Propagator, optional</span>
<span class="sd">        The propagator instance to use.</span>

<span class="sd">    Notes</span>
<span class="sd">    -----</span>
<span class="sd">    If orbit or time is scalar valued (as opposed to a list of Orbit, e.g.) then</span>
<span class="sd">    the corresponding dimension of the output will be squeezed out.</span>

<span class="sd">    For Keplerian orbit propagation it is more efficient to use a &quot;vector Orbit&quot;</span>
<span class="sd">    instead of a list of single scalar Orbits.</span>

<span class="sd">    Returns</span>
<span class="sd">    -------</span>
<span class="sd">    r : array_like (n, m, 3)</span>
<span class="sd">        Position in meters.</span>
<span class="sd">    v : array_like (n, m, 3)</span>
<span class="sd">        Velocity in meters per second.</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="n">nOrbit</span><span class="p">,</span> <span class="n">squeezeOrbit</span><span class="p">,</span> <span class="n">orbit</span> <span class="o">=</span> <span class="n">_countOrbit</span><span class="p">(</span><span class="n">orbit</span><span class="p">)</span>
    <span class="n">nTime</span><span class="p">,</span> <span class="n">squeezeTime</span><span class="p">,</span> <span class="n">time</span> <span class="o">=</span> <span class="n">_countTime</span><span class="p">(</span><span class="n">time</span><span class="p">)</span>
    <span class="c1"># print(nOrbit, squeezeOrbit, orbit, nTime, squeezeTime, time)</span>
    <span class="n">outR</span><span class="p">,</span> <span class="n">outV</span> <span class="o">=</span> <span class="n">_rv</span><span class="p">(</span><span class="n">orbit</span><span class="p">,</span> <span class="n">HashableArrayContainer</span><span class="p">(</span><span class="n">time</span><span class="p">),</span> <span class="n">propagator</span><span class="p">)</span>

    <span class="k">return</span> <span class="n">_doSqueeze</span><span class="p">(</span><span class="n">squeezeOrbit</span><span class="p">,</span> <span class="n">squeezeTime</span><span class="p">,</span> <span class="n">outR</span><span class="p">,</span> <span class="n">outV</span><span class="p">)</span></div>


<span class="k">def</span><span class="w"> </span><span class="nf">__rv</span><span class="p">(</span><span class="n">orbit</span><span class="p">,</span> <span class="n">time</span><span class="p">,</span> <span class="n">propagator</span><span class="p">):</span>
    <span class="n">outR</span><span class="p">,</span> <span class="n">outV</span> <span class="o">=</span> <span class="n">propagator</span><span class="o">.</span><span class="n">_getRVMany</span><span class="p">(</span><span class="n">orbit</span><span class="p">,</span> <span class="n">time</span><span class="o">.</span><span class="n">arr</span><span class="p">)</span>

    <span class="k">return</span> <span class="n">outR</span><span class="p">,</span> <span class="n">outV</span>


<span class="n">_rv</span> <span class="o">=</span> <span class="n">LRU_Cache</span><span class="p">(</span><span class="n">__rv</span><span class="p">,</span> <span class="n">maxsize</span><span class="o">=</span><span class="mi">16</span><span class="p">)</span>


<div class="viewcode-block" id="groundTrack"><a class="viewcode-back" href="../../api/ssapy.compute.groundTrack.html#ssapy.compute.groundTrack">[docs]</a><span class="k">def</span><span class="w"> </span><span class="nf">groundTrack</span><span class="p">(</span><span class="n">orbit</span><span class="p">,</span> <span class="n">time</span><span class="p">,</span> <span class="n">propagator</span><span class="o">=</span><span class="n">KeplerianPropagator</span><span class="p">(),</span> <span class="nb">format</span><span class="o">=</span><span class="s1">&#39;geodetic&#39;</span><span class="p">):</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;Calculate satellite ground track on the outer product of all supplied times and</span>
<span class="sd">    state vectors or orbits.</span>

<span class="sd">    Parameters</span>
<span class="sd">    ----------</span>
<span class="sd">    r : array_like (n,3) Position (m)</span>

<span class="sd">    time : array_like or astropy.time.Time (m,)</span>
<span class="sd">        If float (array), then should correspond to GPS seconds; i.e., seconds</span>
<span class="sd">        since 1980-01-06 00:00:00 UTC</span>
<span class="sd">    or</span>

<span class="sd">    orbit : r : array_like (n,3) Position (m) or</span>
<span class="sd">        Orbit or list of Orbit (n,)</span>
<span class="sd">        Desired orbit(s)</span>
<span class="sd">    propagator : Propagator, optional</span>
<span class="sd">        The propagator instance to use.</span>
<span class="sd">    format : &#39;geodetic&#39; or &#39;cartesian&#39;</span>
<span class="sd">        If &#39;geodetic&#39;, then returns longitude, latitude, height.</span>
<span class="sd">        If &#39;cartesian&#39;, then returns xyz in ITRF frame.</span>

<span class="sd">    Notes</span>
<span class="sd">    -----</span>
<span class="sd">    If orbit or time is scalar valued (as opposed to a list of Orbit, e.g.) then</span>
<span class="sd">    the corresponding dimension of the output will be squeezed out.</span>

<span class="sd">    For Keplerian orbit propagation it is more efficient to use a &quot;vector Orbit&quot;</span>
<span class="sd">    instead of a list of single scalar Orbits.</span>

<span class="sd">    Returns</span>
<span class="sd">    -------</span>
<span class="sd">    lon, lat, height : array_like (n, m, 3)</span>
<span class="sd">        Radians and meters.</span>

<span class="sd">    or</span>

<span class="sd">    x, y, z : array_like(n, m, 3)</span>
<span class="sd">        Meters.</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="k">if</span> <span class="nb">format</span> <span class="ow">not</span> <span class="ow">in</span> <span class="p">[</span><span class="s1">&#39;cartesian&#39;</span><span class="p">,</span> <span class="s1">&#39;geodetic&#39;</span><span class="p">]:</span>
        <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s2">&quot;Format must be either &#39;cartesian&#39; or &#39;geodetic&#39;&quot;</span><span class="p">)</span>

    <span class="n">nTime</span><span class="p">,</span> <span class="n">squeezeTime</span><span class="p">,</span> <span class="n">time</span> <span class="o">=</span> <span class="n">_countTime</span><span class="p">(</span><span class="n">time</span><span class="p">)</span>
    <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">orbit</span><span class="p">,</span> <span class="n">Orbit</span><span class="p">):</span>
        <span class="n">nOrbit</span><span class="p">,</span> <span class="n">squeezeOrbit</span><span class="p">,</span> <span class="n">orbit</span> <span class="o">=</span> <span class="n">_countOrbit</span><span class="p">(</span><span class="n">orbit</span><span class="p">)</span>
        <span class="n">r</span><span class="p">,</span> <span class="n">v</span> <span class="o">=</span> <span class="n">rv</span><span class="p">(</span><span class="n">orbit</span><span class="p">,</span> <span class="n">time</span><span class="p">,</span> <span class="n">propagator</span><span class="o">=</span><span class="n">propagator</span><span class="p">)</span>  <span class="c1"># (n, m, 3)</span>
    <span class="k">else</span><span class="p">:</span>
        <span class="n">nOrbit</span><span class="p">,</span> <span class="n">squeezeOrbit</span><span class="p">,</span> <span class="n">r</span> <span class="o">=</span> <span class="n">_countR</span><span class="p">(</span><span class="n">orbit</span><span class="p">)</span>  <span class="c1"># (n, m, 3)</span>

    <span class="c1"># Reverse the math in EarthObserver.getRV</span>
    <span class="n">mjd_tt</span> <span class="o">=</span> <span class="n">_gpsToTT</span><span class="p">(</span><span class="n">time</span><span class="p">)</span>
    <span class="n">d_ut1_tt_mjd</span><span class="p">,</span> <span class="n">pmx</span><span class="p">,</span> <span class="n">pmy</span> <span class="o">=</span> <span class="n">iers_interp</span><span class="p">(</span><span class="n">time</span><span class="p">)</span>
    <span class="n">pn</span> <span class="o">=</span> <span class="n">erfa</span><span class="o">.</span><span class="n">pnm80</span><span class="p">(</span><span class="mf">2400000.5</span><span class="p">,</span> <span class="n">mjd_tt</span><span class="p">)</span>
    <span class="n">gst</span> <span class="o">=</span> <span class="n">erfa</span><span class="o">.</span><span class="n">gst94</span><span class="p">(</span><span class="mf">2400000.5</span><span class="p">,</span> <span class="n">mjd_tt</span> <span class="o">+</span> <span class="n">d_ut1_tt_mjd</span><span class="p">)</span>
    <span class="n">cg</span><span class="p">,</span> <span class="n">sg</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">cos</span><span class="p">(</span><span class="n">gst</span><span class="p">),</span> <span class="n">np</span><span class="o">.</span><span class="n">sin</span><span class="p">(</span><span class="n">gst</span><span class="p">)</span>
    <span class="n">gstMat</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">zeros</span><span class="p">([</span><span class="nb">len</span><span class="p">(</span><span class="n">time</span><span class="p">),</span> <span class="mi">3</span><span class="p">,</span> <span class="mi">3</span><span class="p">],</span> <span class="n">dtype</span><span class="o">=</span><span class="nb">float</span><span class="p">)</span>
    <span class="n">gstMat</span><span class="p">[:,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">]</span> <span class="o">=</span> <span class="n">cg</span>
    <span class="n">gstMat</span><span class="p">[:,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">1</span><span class="p">]</span> <span class="o">=</span> <span class="n">sg</span>
    <span class="n">gstMat</span><span class="p">[:,</span> <span class="mi">1</span><span class="p">,</span> <span class="mi">0</span><span class="p">]</span> <span class="o">=</span> <span class="o">-</span><span class="n">sg</span>
    <span class="n">gstMat</span><span class="p">[:,</span> <span class="mi">1</span><span class="p">,</span> <span class="mi">1</span><span class="p">]</span> <span class="o">=</span> <span class="n">cg</span>
    <span class="n">gstMat</span><span class="p">[:,</span> <span class="mi">2</span><span class="p">,</span> <span class="mi">2</span><span class="p">]</span> <span class="o">=</span> <span class="mf">1.0</span>

    <span class="n">polar</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">zeros</span><span class="p">([</span><span class="nb">len</span><span class="p">(</span><span class="n">time</span><span class="p">),</span> <span class="mi">3</span><span class="p">,</span> <span class="mi">3</span><span class="p">],</span> <span class="n">dtype</span><span class="o">=</span><span class="nb">float</span><span class="p">)</span>
    <span class="n">polar</span><span class="p">[:]</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">eye</span><span class="p">(</span><span class="mi">3</span><span class="p">)</span>

    <span class="n">polar</span><span class="p">[:,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">2</span><span class="p">]</span> <span class="o">=</span> <span class="n">pmx</span>
    <span class="n">polar</span><span class="p">[:,</span> <span class="mi">1</span><span class="p">,</span> <span class="mi">2</span><span class="p">]</span> <span class="o">=</span> <span class="o">-</span><span class="n">pmy</span>
    <span class="n">polar</span><span class="p">[:,</span> <span class="mi">2</span><span class="p">,</span> <span class="mi">0</span><span class="p">]</span> <span class="o">=</span> <span class="o">-</span><span class="n">pmx</span>
    <span class="n">polar</span><span class="p">[:,</span> <span class="mi">2</span><span class="p">,</span> <span class="mi">1</span><span class="p">]</span> <span class="o">=</span> <span class="n">pmy</span>

    <span class="n">U</span> <span class="o">=</span> <span class="n">gstMat</span> <span class="o">@</span> <span class="n">pn</span>
    <span class="n">itrs</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">einsum</span><span class="p">(</span>
        <span class="s2">&quot;tab,ntb-&gt;nta&quot;</span><span class="p">,</span>
        <span class="p">(</span><span class="n">polar</span> <span class="o">@</span> <span class="n">U</span><span class="p">),</span>
        <span class="n">r</span>
    <span class="p">)</span>
    <span class="n">x</span> <span class="o">=</span> <span class="n">itrs</span><span class="p">[</span><span class="o">...</span><span class="p">,</span> <span class="mi">0</span><span class="p">]</span>
    <span class="n">y</span> <span class="o">=</span> <span class="n">itrs</span><span class="p">[</span><span class="o">...</span><span class="p">,</span> <span class="mi">1</span><span class="p">]</span>
    <span class="n">z</span> <span class="o">=</span> <span class="n">itrs</span><span class="p">[</span><span class="o">...</span><span class="p">,</span> <span class="mi">2</span><span class="p">]</span>
    <span class="k">if</span> <span class="nb">format</span> <span class="o">==</span> <span class="s1">&#39;cartesian&#39;</span><span class="p">:</span>
        <span class="k">return</span> <span class="n">_doSqueeze</span><span class="p">(</span><span class="n">squeezeOrbit</span><span class="p">,</span> <span class="n">squeezeTime</span><span class="p">,</span> <span class="n">x</span><span class="p">,</span> <span class="n">y</span><span class="p">,</span> <span class="n">z</span><span class="p">)</span>
    <span class="k">elif</span> <span class="nb">format</span> <span class="o">==</span> <span class="s1">&#39;geodetic&#39;</span><span class="p">:</span>
        <span class="n">ellipsoid</span> <span class="o">=</span> <span class="n">Ellipsoid</span><span class="p">()</span>
        <span class="n">lon</span><span class="p">,</span> <span class="n">lat</span><span class="p">,</span> <span class="n">height</span> <span class="o">=</span> <span class="n">ellipsoid</span><span class="o">.</span><span class="n">cartToSphere</span><span class="p">(</span><span class="n">x</span><span class="p">,</span> <span class="n">y</span><span class="p">,</span> <span class="n">z</span><span class="p">)</span>
        <span class="k">return</span> <span class="n">_doSqueeze</span><span class="p">(</span><span class="n">squeezeOrbit</span><span class="p">,</span> <span class="n">squeezeTime</span><span class="p">,</span> <span class="n">lon</span><span class="p">,</span> <span class="n">lat</span><span class="p">,</span> <span class="n">height</span><span class="p">)</span></div>


<span class="k">def</span><span class="w"> </span><span class="nf">_obsAngleCorrection</span><span class="p">(</span>
    <span class="n">r</span><span class="p">,</span> <span class="n">v</span><span class="p">,</span> <span class="n">obsPos</span><span class="p">,</span> <span class="n">obsVel</span><span class="p">,</span> <span class="n">orbit</span><span class="p">,</span> <span class="n">time</span><span class="p">,</span> <span class="n">propagator</span><span class="p">,</span> <span class="n">correctionType</span><span class="p">,</span> <span class="n">max_iter</span><span class="o">=</span><span class="mi">10</span>
<span class="p">):</span>
    <span class="k">if</span> <span class="n">correctionType</span> <span class="o">==</span> <span class="s2">&quot;linear&quot;</span><span class="p">:</span>
        <span class="c1"># First order correction is to back up satellite by v * dt</span>
        <span class="c1"># where dt is the approximate time delay from the 0th order distance.</span>
        <span class="c1"># Important: *don&#39;t* do anything to the observer position, since we</span>
        <span class="c1"># really did do the observation at the originally given time and place.</span>
        <span class="n">dt</span> <span class="o">=</span> <span class="n">norm</span><span class="p">(</span><span class="n">r</span> <span class="o">-</span> <span class="n">obsPos</span><span class="p">)</span> <span class="o">/</span> <span class="mi">299792458</span>
        <span class="n">r</span> <span class="o">-=</span> <span class="n">np</span><span class="o">.</span><span class="n">einsum</span><span class="p">(</span><span class="s2">&quot;nmi,nm-&gt;nmi&quot;</span><span class="p">,</span> <span class="n">v</span><span class="p">,</span> <span class="n">dt</span><span class="p">)</span>
        <span class="c1"># no change to v since linear assumption _is_ that v is constant for the</span>
        <span class="c1"># light time duration.</span>
    <span class="k">elif</span> <span class="n">correctionType</span> <span class="o">==</span> <span class="s2">&quot;exact&quot;</span><span class="p">:</span>
        <span class="c1"># Solve |r(t-dt) - r_obs(t)| = c dt for dt.</span>
        <span class="n">dist</span> <span class="o">=</span> <span class="n">norm</span><span class="p">(</span><span class="n">r</span> <span class="o">-</span> <span class="n">obsPos</span><span class="p">)</span>
        <span class="n">dt</span><span class="p">,</span> <span class="n">dt_previous</span> <span class="o">=</span> <span class="n">dist</span> <span class="o">/</span> <span class="mi">299792458</span><span class="p">,</span> <span class="n">np</span><span class="o">.</span><span class="n">inf</span>
        <span class="nb">iter</span> <span class="o">=</span> <span class="mi">0</span>
        <span class="k">while</span> <span class="n">np</span><span class="o">.</span><span class="n">any</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">abs</span><span class="p">(</span><span class="n">dt</span> <span class="o">-</span> <span class="n">dt_previous</span><span class="p">))</span> <span class="o">&gt;</span> <span class="mf">1e-12</span><span class="p">:</span>  <span class="c1"># picosecond accurate</span>
            <span class="k">if</span> <span class="nb">iter</span> <span class="o">&gt;</span> <span class="n">max_iter</span><span class="p">:</span>
                <span class="k">raise</span> <span class="ne">RuntimeError</span><span class="p">(</span>
                    <span class="s2">&quot;Exact light time correction did not converge in &quot;</span>
                    <span class="s2">&quot;</span><span class="si">{}</span><span class="s2"> iterations&quot;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="nb">iter</span><span class="p">)</span>
                <span class="p">)</span>
            <span class="c1"># Unfortunately, can&#39;t just do</span>
            <span class="c1"># r, v = rv(orbit, time-dt, propagator=propagator)</span>
            <span class="c1"># because ssapy.rv isn&#39;t parallelized for n orbits and n, m times.</span>
            <span class="c1"># so do one orbit at a time.</span>
            <span class="n">r</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">empty</span><span class="p">((</span><span class="nb">len</span><span class="p">(</span><span class="n">orbit</span><span class="p">),</span> <span class="nb">len</span><span class="p">(</span><span class="n">time</span><span class="p">),</span> <span class="mi">3</span><span class="p">))</span>
            <span class="n">v</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">empty</span><span class="p">((</span><span class="nb">len</span><span class="p">(</span><span class="n">orbit</span><span class="p">),</span> <span class="nb">len</span><span class="p">(</span><span class="n">time</span><span class="p">),</span> <span class="mi">3</span><span class="p">))</span>
            <span class="k">for</span> <span class="n">i</span><span class="p">,</span> <span class="n">o</span> <span class="ow">in</span> <span class="nb">enumerate</span><span class="p">(</span><span class="n">orbit</span><span class="p">):</span>
                <span class="n">r</span><span class="p">[</span><span class="n">i</span><span class="p">],</span> <span class="n">v</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">=</span> <span class="n">rv</span><span class="p">(</span><span class="n">o</span><span class="p">,</span> <span class="n">time</span> <span class="o">-</span> <span class="n">dt</span><span class="p">[</span><span class="n">i</span><span class="p">],</span> <span class="n">propagator</span><span class="o">=</span><span class="n">propagator</span><span class="p">)</span>
            <span class="n">dist</span> <span class="o">=</span> <span class="n">norm</span><span class="p">(</span><span class="n">r</span> <span class="o">-</span> <span class="n">obsPos</span><span class="p">)</span>
            <span class="n">dt</span><span class="p">,</span> <span class="n">dt_previous</span> <span class="o">=</span> <span class="n">dist</span> <span class="o">/</span> <span class="mi">299792458</span><span class="p">,</span> <span class="n">dt</span>
            <span class="nb">iter</span> <span class="o">+=</span> <span class="mi">1</span>
    <span class="k">else</span><span class="p">:</span>
        <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span>
            <span class="s2">&quot;Invalid value for correctionType: </span><span class="si">{}</span><span class="s2">&quot;</span>
            <span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="n">correctionType</span><span class="p">)</span>
        <span class="p">)</span>
    <span class="c1"># Apply velocity correction (i.e., diurnal aberration for an Earth-based</span>
    <span class="c1"># observer, and whatever you call the analogous correction for an orbital</span>
    <span class="c1"># observer).</span>
    <span class="n">dr</span> <span class="o">=</span> <span class="n">norm</span><span class="p">(</span><span class="n">r</span> <span class="o">-</span> <span class="n">obsPos</span><span class="p">)</span>
    <span class="n">r</span> <span class="o">+=</span> <span class="n">obsVel</span> <span class="o">*</span> <span class="n">dr</span><span class="p">[</span><span class="o">...</span><span class="p">,</span> <span class="kc">None</span><span class="p">]</span> <span class="o">/</span> <span class="mi">299792458</span>
    <span class="k">return</span> <span class="n">r</span><span class="p">,</span> <span class="n">v</span>


<div class="viewcode-block" id="dircos"><a class="viewcode-back" href="../../api/ssapy.compute.dircos.html#ssapy.compute.dircos">[docs]</a><span class="k">def</span><span class="w"> </span><span class="nf">dircos</span><span class="p">(</span>
    <span class="n">orbit</span><span class="p">,</span> <span class="n">time</span><span class="p">,</span> <span class="n">obsPos</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">obsVel</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">observer</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span>
    <span class="n">propagator</span><span class="o">=</span><span class="n">KeplerianPropagator</span><span class="p">(),</span> <span class="n">obsAngleCorrection</span><span class="o">=</span><span class="kc">None</span>
<span class="p">):</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot; Calculate observed direction-cosines of orbiting objects as viewed at</span>
<span class="sd">    specified times and positions.</span>

<span class="sd">    The direction cosines are the cosines of the angles between the vector</span>
<span class="sd">    pointing towards the orbiting object and the x, y, z axes.  An equivalent</span>
<span class="sd">    description is that they are the components of the unit vector pointing</span>
<span class="sd">    towards the orbiting object.</span>

<span class="sd">    Parameters</span>
<span class="sd">    ----------</span>
<span class="sd">    orbit : Orbit or list of Orbit (n,)</span>
<span class="sd">        Orbit(s) for which to calculate direction cosines.</span>
<span class="sd">    time : array_like or astropy.time.Time (m,)</span>
<span class="sd">        If float (array), then should correspond to GPS seconds; i.e., seconds</span>
<span class="sd">        since 1980-01-06 00:00:00 UTC</span>
<span class="sd">    obsPos : array_like (m, 3), optional</span>
<span class="sd">        Position of observer at given time.</span>
<span class="sd">    obsVel : array_like (m, 3), optional</span>
<span class="sd">        Velocity of observer at given time.  Only required if correcting for</span>
<span class="sd">        diurnal aberration.</span>
<span class="sd">    observer : Observer or list of Observers (m,), optional</span>
<span class="sd">        Observer(s) used to calculate obsPos and obsVel.</span>
<span class="sd">    propagator : Propagator, optional</span>
<span class="sd">        The propagator instance to use.</span>
<span class="sd">    obsAngleCorrection : {None, &quot;linear&quot;, &quot;exact&quot;}, optional</span>
<span class="sd">        Correct actual angle to observed angle, meaning account for light-time</span>
<span class="sd">        delay, and aberration due to the observer&#39;s velocity.  None means don&#39;t</span>
<span class="sd">        do any correction.  &quot;linear&quot; means do an aberration correction and first</span>
<span class="sd">        order light-time correction.  &quot;exact&quot; means do an aberration correction</span>
<span class="sd">        and iteratively solve for the exact light-time correction.  (The</span>
<span class="sd">        &quot;linear&quot; correction is almost always sufficiently accurate).</span>

<span class="sd">    Notes</span>
<span class="sd">    -----</span>
<span class="sd">    Exactly 1 of `obsPos` and `observer` must be supplied.  `observer` and</span>
<span class="sd">    `obsPos` follow similar broadcasting rules as detailed below explicitly only</span>
<span class="sd">    for `obsPos`.</span>

<span class="sd">    The length of `time` and `obsPos` must match or be broadcastable to match.</span>
<span class="sd">    If `orbit` is scalar-valued (an Orbit instead of a list of Orbit), then that</span>
<span class="sd">    dimension will be squeezed out in the return value.  Likewise, if both</span>
<span class="sd">    `time` and `obsPos` are scalar, that dimension will be squeezed out.</span>

<span class="sd">    For Keplerian orbit propagation it is more efficient to use a &quot;vector Orbit&quot;</span>
<span class="sd">    instead of a list of single scalar Orbits.</span>

<span class="sd">    When doing light time corrections, the time argument is the arrival time of</span>
<span class="sd">    the photons at the observer, as opposed to the emission time at the</span>
<span class="sd">    satellite.</span>

<span class="sd">    Returns</span>
<span class="sd">    -------</span>
<span class="sd">    dircos : array_like (n, m, 3)</span>
<span class="sd">        Direction cosines on the outer product of orbit(s) and time/obsPos.</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="n">nTime</span><span class="p">,</span> <span class="n">squeezeTime</span><span class="p">,</span> <span class="n">time</span> <span class="o">=</span> <span class="n">_countTime</span><span class="p">(</span><span class="n">time</span><span class="p">)</span>
    <span class="n">nOrbit</span><span class="p">,</span> <span class="n">squeezeOrbit</span><span class="p">,</span> <span class="n">orbit</span> <span class="o">=</span> <span class="n">_countOrbit</span><span class="p">(</span><span class="n">orbit</span><span class="p">)</span>
    <span class="n">obsPos</span><span class="p">,</span> <span class="n">obsVel</span><span class="p">,</span> <span class="n">time</span><span class="p">,</span> <span class="n">squeezeTime</span> <span class="o">=</span> <span class="n">_processObserver</span><span class="p">(</span>
        <span class="n">observer</span><span class="p">,</span> <span class="n">obsPos</span><span class="p">,</span> <span class="n">obsVel</span><span class="p">,</span> <span class="n">nTime</span><span class="p">,</span> <span class="n">squeezeTime</span><span class="p">,</span> <span class="n">time</span><span class="p">,</span>
        <span class="n">doObsVel</span><span class="o">=</span><span class="n">obsAngleCorrection</span>
    <span class="p">)</span>

    <span class="c1"># At this point, should have len(orbit) == n</span>
    <span class="c1"># and len(obsPos) == len(time) == nTime</span>
    <span class="c1"># So get positions of orbits...</span>
    <span class="n">r</span><span class="p">,</span> <span class="n">v</span> <span class="o">=</span> <span class="n">rv</span><span class="p">(</span><span class="n">orbit</span><span class="p">,</span> <span class="n">time</span><span class="p">,</span> <span class="n">propagator</span><span class="o">=</span><span class="n">propagator</span><span class="p">)</span>  <span class="c1"># (n, m, 3)</span>
    <span class="k">if</span> <span class="n">obsAngleCorrection</span><span class="p">:</span>
        <span class="n">r</span><span class="p">,</span> <span class="n">v</span> <span class="o">=</span> <span class="n">_obsAngleCorrection</span><span class="p">(</span>
            <span class="n">r</span><span class="p">,</span> <span class="n">v</span><span class="p">,</span> <span class="n">obsPos</span><span class="p">,</span> <span class="n">obsVel</span><span class="p">,</span> <span class="n">orbit</span><span class="p">,</span> <span class="n">time</span><span class="p">,</span> <span class="n">propagator</span><span class="p">,</span> <span class="n">obsAngleCorrection</span>
        <span class="p">)</span>
    <span class="n">dc</span> <span class="o">=</span> <span class="n">normed</span><span class="p">(</span><span class="n">r</span> <span class="o">-</span> <span class="n">obsPos</span><span class="p">)</span>

    <span class="k">return</span> <span class="n">_doSqueeze</span><span class="p">(</span><span class="n">squeezeOrbit</span><span class="p">,</span> <span class="n">squeezeTime</span><span class="p">,</span> <span class="n">dc</span><span class="p">)</span></div>


<div class="viewcode-block" id="radec"><a class="viewcode-back" href="../../api/ssapy.compute.radec.html#ssapy.compute.radec">[docs]</a><span class="k">def</span><span class="w"> </span><span class="nf">radec</span><span class="p">(</span>
    <span class="n">orbit</span><span class="p">,</span> <span class="n">time</span><span class="p">,</span> <span class="n">obsPos</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">obsVel</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">observer</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span>
    <span class="n">propagator</span><span class="o">=</span><span class="n">KeplerianPropagator</span><span class="p">(),</span> <span class="n">obsAngleCorrection</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">rate</span><span class="o">=</span><span class="kc">False</span>
<span class="p">):</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot; Calculate observed right ascension, declination, and slant range of</span>
<span class="sd">    orbiting objects as viewed at specified times and positions.</span>

<span class="sd">    Parameters</span>
<span class="sd">    ----------</span>
<span class="sd">    orbit : Orbit or list of Orbit (n,)</span>
<span class="sd">        Orbit(s) for which to calculate ra and dec.</span>
<span class="sd">    time : array_like or astropy.time.Time (m,)</span>
<span class="sd">        If float (array), then should correspond to GPS seconds; i.e., seconds</span>
<span class="sd">        since 1980-01-06 00:00:00 UTC</span>
<span class="sd">    obsPos : array_like (m, 3), optional</span>
<span class="sd">        Positions of observers at given times.</span>
<span class="sd">    obsVel : array_like (m, 3), optional</span>
<span class="sd">        Velocity of observers at given times.</span>
<span class="sd">    observer : Observer or list of Observers (m,), optional</span>
<span class="sd">        Observer(s) used to calculate obsPos.</span>
<span class="sd">    propagator : Propagator, optional</span>
<span class="sd">        The propagator instance to use.</span>
<span class="sd">    rate : bool</span>
<span class="sd">        If True, return additionally the time derivatives of the quantity, times</span>
<span class="sd">        cos(dec) in the case of right ascension.</span>
<span class="sd">    obsAngleCorrection : {None, &quot;linear&quot;, &quot;exact&quot;}, optional</span>
<span class="sd">        Correct actual angle to observed angle, meaning account for light-time</span>
<span class="sd">        delay, and aberration due to the observer&#39;s velocity.  None means don&#39;t</span>
<span class="sd">        do any correction.  &quot;linear&quot; means do an aberration correction and first</span>
<span class="sd">        order light-time correction.  &quot;exact&quot; means do an aberration correction</span>
<span class="sd">        and iteratively solve for the exact light-time correction.  (The</span>
<span class="sd">        &quot;linear&quot; correction is almost always sufficiently accurate).</span>

<span class="sd">    Notes</span>
<span class="sd">    -----</span>
<span class="sd">    Exactly 1 of `obsPos` and `observer` must be supplied.  `observer` and</span>
<span class="sd">    `obsPos` follow similar broadcasting rules as detailed below explicitly only</span>
<span class="sd">    for `obsPos`.</span>

<span class="sd">    The length of `time` and `obsPos` must match or be broadcastable to match.</span>
<span class="sd">    If `orbit` is scalar-valued (an Orbit instead of a list of Orbit), then that</span>
<span class="sd">    dimension will be squeezed out in the return value.  Likewise, if both</span>
<span class="sd">    `time` and `obsPos` are scalar, that dimension will be squeezed out.</span>

<span class="sd">    For Keplerian orbit propagation it is more efficient to use a &quot;vector Orbit&quot;</span>
<span class="sd">    instead of a list of single scalar Orbits.</span>

<span class="sd">    When doing light time corrections, the time argument is the arrival time of</span>
<span class="sd">    the photons at the observer, as opposed to the emission time at the</span>
<span class="sd">    satellite.</span>

<span class="sd">    Returns</span>
<span class="sd">    -------</span>
<span class="sd">    ra, dec : array_like (n, m)</span>
<span class="sd">        Right ascension and declination in radians.</span>
<span class="sd">    range : array_like (n, m)</span>
<span class="sd">        (Slant) range in meters.</span>
<span class="sd">    If rate, also:</span>
<span class="sd">    raRate : array_like (n, m)</span>
<span class="sd">        Time derivatives of right ascension times cos(dec), rad / sec.</span>
<span class="sd">    decRate : array_like (n, m)</span>
<span class="sd">        Time derivative of declination, rad / sec.</span>
<span class="sd">    rangeRate : array_like (n, m)</span>
<span class="sd">        Time derivative of range, meter / s.</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="n">nTime</span><span class="p">,</span> <span class="n">squeezeTime</span><span class="p">,</span> <span class="n">time</span> <span class="o">=</span> <span class="n">_countTime</span><span class="p">(</span><span class="n">time</span><span class="p">)</span>
    <span class="n">nOrbit</span><span class="p">,</span> <span class="n">squeezeOrbit</span><span class="p">,</span> <span class="n">orbit</span> <span class="o">=</span> <span class="n">_countOrbit</span><span class="p">(</span><span class="n">orbit</span><span class="p">)</span>
    <span class="n">obsPos</span><span class="p">,</span> <span class="n">obsVel</span><span class="p">,</span> <span class="n">time</span><span class="p">,</span> <span class="n">squeezeTime</span> <span class="o">=</span> <span class="n">_processObserver</span><span class="p">(</span>
        <span class="n">observer</span><span class="p">,</span> <span class="n">obsPos</span><span class="p">,</span> <span class="n">obsVel</span><span class="p">,</span> <span class="n">nTime</span><span class="p">,</span> <span class="n">squeezeTime</span><span class="p">,</span> <span class="n">time</span><span class="p">,</span>
        <span class="n">doObsVel</span><span class="o">=</span><span class="n">obsAngleCorrection</span>
    <span class="p">)</span>

    <span class="k">if</span> <span class="n">rate</span> <span class="ow">and</span> <span class="n">obsVel</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
        <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s1">&#39;obsVel must not be None if rate is True.&#39;</span><span class="p">)</span>

    <span class="c1"># At this point, should have len(orbit) == n</span>
    <span class="c1"># and len(obsPos) == len(time) == nTime</span>
    <span class="c1"># So get positions of orbits...</span>
    <span class="n">r</span><span class="p">,</span> <span class="n">v</span> <span class="o">=</span> <span class="n">rv</span><span class="p">(</span><span class="n">orbit</span><span class="p">,</span> <span class="n">time</span><span class="p">,</span> <span class="n">propagator</span><span class="o">=</span><span class="n">propagator</span><span class="p">)</span>  <span class="c1"># (n, m, 3)</span>
    <span class="k">if</span> <span class="n">obsAngleCorrection</span><span class="p">:</span>
        <span class="n">r</span><span class="p">,</span> <span class="n">v</span> <span class="o">=</span> <span class="n">_obsAngleCorrection</span><span class="p">(</span>
            <span class="n">r</span><span class="p">,</span> <span class="n">v</span><span class="p">,</span> <span class="n">obsPos</span><span class="p">,</span> <span class="n">obsVel</span><span class="p">,</span> <span class="n">orbit</span><span class="p">,</span> <span class="n">time</span><span class="p">,</span> <span class="n">propagator</span><span class="p">,</span> <span class="n">obsAngleCorrection</span>
        <span class="p">)</span>

    <span class="n">ra</span><span class="p">,</span> <span class="n">dec</span><span class="p">,</span> <span class="n">slantRange</span><span class="p">,</span> <span class="n">raRate</span><span class="p">,</span> <span class="n">decRate</span><span class="p">,</span> <span class="n">rangeRate</span> <span class="o">=</span> <span class="n">rvObsToRaDecRate</span><span class="p">(</span>
        <span class="n">r</span><span class="p">,</span> <span class="n">v</span><span class="p">,</span> <span class="n">obsPos</span><span class="p">,</span> <span class="n">obsVel</span>
    <span class="p">)</span>
    <span class="n">res</span> <span class="o">=</span> <span class="p">(</span><span class="n">ra</span><span class="p">,</span> <span class="n">dec</span><span class="p">,</span> <span class="n">slantRange</span><span class="p">)</span>
    <span class="k">if</span> <span class="n">rate</span><span class="p">:</span>
        <span class="n">res</span> <span class="o">=</span> <span class="n">res</span> <span class="o">+</span> <span class="p">(</span><span class="n">raRate</span><span class="p">,</span> <span class="n">decRate</span><span class="p">,</span> <span class="n">rangeRate</span><span class="p">)</span>

    <span class="k">return</span> <span class="n">_doSqueeze</span><span class="p">(</span><span class="o">*</span><span class="p">((</span><span class="n">squeezeOrbit</span><span class="p">,</span> <span class="n">squeezeTime</span><span class="p">)</span> <span class="o">+</span> <span class="n">res</span><span class="p">))</span></div>


<div class="viewcode-block" id="altaz"><a class="viewcode-back" href="../../api/ssapy.compute.altaz.html#ssapy.compute.altaz">[docs]</a><span class="k">def</span><span class="w"> </span><span class="nf">altaz</span><span class="p">(</span>
    <span class="n">orbit</span><span class="p">,</span> <span class="n">time</span><span class="p">,</span> <span class="n">observer</span><span class="p">,</span> <span class="n">propagator</span><span class="o">=</span><span class="n">KeplerianPropagator</span><span class="p">(),</span>
    <span class="n">obsAngleCorrection</span><span class="o">=</span><span class="kc">None</span>
<span class="p">):</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot; Calculate observed altitude and azimuth of orbiting objects as viewed at</span>
<span class="sd">    specified times and locations.</span>

<span class="sd">    Parameters</span>
<span class="sd">    ----------</span>
<span class="sd">    orbit : Orbit or list of Orbit (n,)</span>
<span class="sd">        Orbits for which to calculate direction cosines.</span>
<span class="sd">    time : array_like or astropy.time.Time (m,)</span>
<span class="sd">        If float (array), then should correspond to GPS seconds; i.e., seconds</span>
<span class="sd">        since 1980-01-06 00:00:00 UTC</span>
<span class="sd">    observer : EarthObserver</span>
<span class="sd">        Where on Earth to compute alt and az.</span>
<span class="sd">    propagator : Propagator, optional</span>
<span class="sd">        The propagator instance to use.</span>
<span class="sd">    obsAngleCorrection : {None, &quot;linear&quot;, &quot;exact&quot;}, optional</span>
<span class="sd">        Correct actual angle to observed angle, meaning account for light-time</span>
<span class="sd">        delay, and aberration due to the observer&#39;s velocity.  None means don&#39;t</span>
<span class="sd">        do any correction.  &quot;linear&quot; means do an aberration correction and first</span>
<span class="sd">        order light-time correction.  &quot;exact&quot; means do an aberration correction</span>
<span class="sd">        and iteratively solve for the exact light-time correction.  (The</span>
<span class="sd">        &quot;linear&quot; correction is almost always sufficiently accurate).</span>

<span class="sd">    Notes</span>
<span class="sd">    -----</span>
<span class="sd">    If `orbit` is scalar-valued (an Orbit instead of a list of Orbit), then that</span>
<span class="sd">    dimension will be squeezed out in the return value.  Likewise, if `time` is</span>
<span class="sd">    scalar, that dimension will be squeezed out.</span>

<span class="sd">    For Keplerian orbit propagation it is more efficient to use a &quot;vector Orbit&quot;</span>
<span class="sd">    instead of a list of single scalar Orbits.</span>

<span class="sd">    When doing light time corrections, the time argument is the arrival time of</span>
<span class="sd">    the photons at the observer, as opposed to the emission time at the</span>
<span class="sd">    satellite.</span>

<span class="sd">    Returns</span>
<span class="sd">    -------</span>
<span class="sd">    alt, az : array_like (n, m)</span>
<span class="sd">        Altitude and azimuth in radians.</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="kn">from</span><span class="w"> </span><span class="nn">astropy.coordinates</span><span class="w"> </span><span class="kn">import</span> <span class="n">SkyCoord</span><span class="p">,</span> <span class="n">AltAz</span><span class="p">,</span> <span class="n">GCRS</span>

    <span class="n">nTime</span><span class="p">,</span> <span class="n">squeezeTime</span><span class="p">,</span> <span class="n">time</span> <span class="o">=</span> <span class="n">_countTime</span><span class="p">(</span><span class="n">time</span><span class="p">)</span>
    <span class="n">nOrbit</span><span class="p">,</span> <span class="n">squeezeOrbit</span><span class="p">,</span> <span class="n">orbit</span> <span class="o">=</span> <span class="n">_countOrbit</span><span class="p">(</span><span class="n">orbit</span><span class="p">)</span>
    <span class="n">obsPos</span><span class="p">,</span> <span class="n">obsVel</span> <span class="o">=</span> <span class="n">observer</span><span class="o">.</span><span class="n">getRV</span><span class="p">(</span><span class="n">time</span><span class="p">)</span>

    <span class="n">r</span><span class="p">,</span> <span class="n">v</span> <span class="o">=</span> <span class="n">rv</span><span class="p">(</span><span class="n">orbit</span><span class="p">,</span> <span class="n">time</span><span class="p">,</span> <span class="n">propagator</span><span class="o">=</span><span class="n">propagator</span><span class="p">)</span>  <span class="c1"># (n, m, 3)</span>
    <span class="k">if</span> <span class="n">obsAngleCorrection</span><span class="p">:</span>
        <span class="n">r</span><span class="p">,</span> <span class="n">v</span> <span class="o">=</span> <span class="n">_obsAngleCorrection</span><span class="p">(</span>
            <span class="n">r</span><span class="p">,</span> <span class="n">v</span><span class="p">,</span> <span class="n">obsPos</span><span class="p">,</span> <span class="n">obsVel</span><span class="p">,</span> <span class="n">orbit</span><span class="p">,</span> <span class="n">time</span><span class="p">,</span> <span class="n">propagator</span><span class="p">,</span> <span class="n">obsAngleCorrection</span>
        <span class="p">)</span>

    <span class="c1"># Using astropy backend for AltAz computation</span>
    <span class="n">sc</span> <span class="o">=</span> <span class="n">SkyCoord</span><span class="p">(</span>
        <span class="n">x</span><span class="o">=</span><span class="n">r</span><span class="p">[</span><span class="o">...</span><span class="p">,</span> <span class="mi">0</span><span class="p">],</span> <span class="n">y</span><span class="o">=</span><span class="n">r</span><span class="p">[</span><span class="o">...</span><span class="p">,</span> <span class="mi">1</span><span class="p">],</span> <span class="n">z</span><span class="o">=</span><span class="n">r</span><span class="p">[</span><span class="o">...</span><span class="p">,</span> <span class="mi">2</span><span class="p">],</span>
        <span class="n">unit</span><span class="o">=</span><span class="s1">&#39;m&#39;</span><span class="p">,</span>
        <span class="n">representation_type</span><span class="o">=</span><span class="s1">&#39;cartesian&#39;</span><span class="p">,</span>
        <span class="n">frame</span><span class="o">=</span><span class="n">GCRS</span><span class="p">(</span><span class="n">obstime</span><span class="o">=</span><span class="n">Time</span><span class="p">(</span><span class="n">time</span><span class="p">,</span> <span class="nb">format</span><span class="o">=</span><span class="s1">&#39;gps&#39;</span><span class="p">))</span>
    <span class="p">)</span>
    <span class="n">aa</span> <span class="o">=</span> <span class="n">sc</span><span class="o">.</span><span class="n">transform_to</span><span class="p">(</span><span class="n">AltAz</span><span class="p">(</span><span class="n">location</span><span class="o">=</span><span class="n">observer</span><span class="o">.</span><span class="n">_location</span><span class="p">))</span>

    <span class="k">return</span> <span class="n">_doSqueeze</span><span class="p">(</span><span class="n">squeezeOrbit</span><span class="p">,</span> <span class="n">squeezeTime</span><span class="p">,</span> <span class="n">aa</span><span class="o">.</span><span class="n">alt</span><span class="o">.</span><span class="n">radian</span><span class="p">,</span> <span class="n">aa</span><span class="o">.</span><span class="n">az</span><span class="o">.</span><span class="n">radian</span><span class="p">)</span></div>


<div class="viewcode-block" id="quickAltAz"><a class="viewcode-back" href="../../api/ssapy.compute.quickAltAz.html#ssapy.compute.quickAltAz">[docs]</a><span class="k">def</span><span class="w"> </span><span class="nf">quickAltAz</span><span class="p">(</span>
    <span class="n">orbit</span><span class="p">,</span> <span class="n">time</span><span class="p">,</span> <span class="n">observer</span><span class="p">,</span> <span class="n">propagator</span><span class="o">=</span><span class="n">KeplerianPropagator</span><span class="p">(),</span>
    <span class="n">obsAngleCorrection</span><span class="o">=</span><span class="kc">None</span>
<span class="p">):</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot; Quickly estimate observed altitude and azimuth of orbiting objects as</span>
<span class="sd">    viewed at specified times and locations.</span>

<span class="sd">    This algorithm approximates &quot;up&quot; as pointing directly away from the center</span>
<span class="sd">    of the Earth, instead of normal to the reference ellipsoid.  Use `altAz` if</span>
<span class="sd">    you want values wrt the reference ellipsoid.</span>

<span class="sd">    Parameters</span>
<span class="sd">    ----------</span>
<span class="sd">    orbit : Orbit or list of Orbit (n,)</span>
<span class="sd">        Orbits for which to calculate direction cosines.</span>
<span class="sd">    time : array_like or astropy.time.Time (m,)</span>
<span class="sd">        If float (array), then should correspond to GPS seconds; i.e., seconds</span>
<span class="sd">        since 1980-01-06 00:00:00 UTC</span>
<span class="sd">    observer : EarthObserver</span>
<span class="sd">        Where on Earth to compute alt and az.</span>
<span class="sd">    propagator : Propagator, optional</span>
<span class="sd">        The propagator instance to use.</span>
<span class="sd">    obsAngleCorrection : {None, &quot;linear&quot;, &quot;exact&quot;}, optional</span>
<span class="sd">        Correct actual angle to observed angle, meaning account for light-time</span>
<span class="sd">        delay, and aberration due to the observer&#39;s velocity.  None means don&#39;t</span>
<span class="sd">        do any correction.  &quot;linear&quot; means do an aberration correction and first</span>
<span class="sd">        order light-time correction.  &quot;exact&quot; means do an aberration correction</span>
<span class="sd">        and iteratively solve for the exact light-time correction.  (The</span>
<span class="sd">        &quot;linear&quot; correction is almost always sufficiently accurate).</span>

<span class="sd">    Notes</span>
<span class="sd">    -----</span>
<span class="sd">    If `orbit` is scalar-valued (an Orbit instead of a list of Orbit), then that</span>
<span class="sd">    dimension will be squeezed out in the return value.  Likewise, if `time` is</span>
<span class="sd">    scalar, that dimension will be squeezed out.</span>

<span class="sd">    For Keplerian orbit propagation it is more efficient to use a &quot;vector Orbit&quot;</span>
<span class="sd">    instead of a list of single scalar Orbits.</span>

<span class="sd">    When doing light time corrections, the time argument is the arrival time of</span>
<span class="sd">    the photons at the observer, as opposed to the emission time at the</span>
<span class="sd">    satellite.</span>

<span class="sd">    Returns</span>
<span class="sd">    -------</span>
<span class="sd">    alt, az : array_like (n, m)</span>
<span class="sd">        Altitude and azimuth in radians.</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="n">nTime</span><span class="p">,</span> <span class="n">squeezeTime</span><span class="p">,</span> <span class="n">time</span> <span class="o">=</span> <span class="n">_countTime</span><span class="p">(</span><span class="n">time</span><span class="p">)</span>
    <span class="n">nOrbit</span><span class="p">,</span> <span class="n">squeezeOrbit</span><span class="p">,</span> <span class="n">orbit</span> <span class="o">=</span> <span class="n">_countOrbit</span><span class="p">(</span><span class="n">orbit</span><span class="p">)</span>

    <span class="n">ro</span><span class="p">,</span> <span class="n">vo</span> <span class="o">=</span> <span class="n">observer</span><span class="o">.</span><span class="n">getRV</span><span class="p">(</span><span class="n">time</span><span class="p">)</span>  <span class="c1"># (m, 3)</span>
    <span class="n">r</span><span class="p">,</span> <span class="n">v</span> <span class="o">=</span> <span class="n">rv</span><span class="p">(</span><span class="n">orbit</span><span class="p">,</span> <span class="n">time</span><span class="p">,</span> <span class="n">propagator</span><span class="o">=</span><span class="n">propagator</span><span class="p">)</span>  <span class="c1"># (n, m, 3)</span>
    <span class="k">if</span> <span class="n">obsAngleCorrection</span><span class="p">:</span>
        <span class="n">r</span><span class="p">,</span> <span class="n">v</span> <span class="o">=</span> <span class="n">_obsAngleCorrection</span><span class="p">(</span>
            <span class="n">r</span><span class="p">,</span> <span class="n">v</span><span class="p">,</span> <span class="n">ro</span><span class="p">,</span> <span class="n">vo</span><span class="p">,</span> <span class="n">orbit</span><span class="p">,</span> <span class="n">time</span><span class="p">,</span> <span class="n">propagator</span><span class="p">,</span> <span class="n">obsAngleCorrection</span>
        <span class="p">)</span>

    <span class="n">up</span> <span class="o">=</span> <span class="n">normed</span><span class="p">(</span><span class="n">ro</span><span class="p">)</span>
    <span class="n">east</span> <span class="o">=</span> <span class="n">normed</span><span class="p">(</span><span class="n">vo</span><span class="p">)</span>
    <span class="n">north</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">cross</span><span class="p">(</span><span class="n">up</span><span class="p">,</span> <span class="n">east</span><span class="p">)</span>

    <span class="n">dr</span> <span class="o">=</span> <span class="n">r</span> <span class="o">-</span> <span class="n">ro</span>
    <span class="n">northing</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">einsum</span><span class="p">(</span><span class="s2">&quot;nmi,mi-&gt;nm&quot;</span><span class="p">,</span> <span class="n">dr</span><span class="p">,</span> <span class="n">north</span><span class="p">)</span>
    <span class="n">easting</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">einsum</span><span class="p">(</span><span class="s2">&quot;nmi,mi-&gt;nm&quot;</span><span class="p">,</span> <span class="n">dr</span><span class="p">,</span> <span class="n">east</span><span class="p">)</span>

    <span class="n">alt</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">pi</span> <span class="o">/</span> <span class="mi">2</span> <span class="o">-</span> <span class="n">unitAngle3</span><span class="p">(</span>
        <span class="n">normed</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">broadcast_to</span><span class="p">(</span><span class="n">ro</span><span class="p">,</span> <span class="n">r</span><span class="o">.</span><span class="n">shape</span><span class="p">)),</span> <span class="n">normed</span><span class="p">(</span><span class="n">dr</span><span class="p">)</span>
    <span class="p">)</span>
    <span class="n">az</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">arctan2</span><span class="p">(</span><span class="n">easting</span><span class="p">,</span> <span class="n">northing</span><span class="p">)</span>
    <span class="n">az</span> <span class="o">%=</span> <span class="mi">2</span> <span class="o">*</span> <span class="n">np</span><span class="o">.</span><span class="n">pi</span>

    <span class="k">return</span> <span class="n">_doSqueeze</span><span class="p">(</span><span class="n">squeezeOrbit</span><span class="p">,</span> <span class="n">squeezeTime</span><span class="p">,</span> <span class="n">alt</span><span class="p">,</span> <span class="n">az</span><span class="p">)</span></div>


<div class="viewcode-block" id="radecRate"><a class="viewcode-back" href="../../api/ssapy.compute.radecRate.html#ssapy.compute.radecRate">[docs]</a><span class="k">def</span><span class="w"> </span><span class="nf">radecRate</span><span class="p">(</span>
    <span class="n">orbit</span><span class="p">,</span> <span class="n">time</span><span class="p">,</span> <span class="n">obsPos</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">obsVel</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">observer</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span>
    <span class="n">propagator</span><span class="o">=</span><span class="n">KeplerianPropagator</span><span class="p">(),</span>
    <span class="n">obsAngleCorrection</span><span class="o">=</span><span class="kc">None</span>
<span class="p">):</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;Calculate ra/dec rate and slant range rate of orbit at specified times</span>
<span class="sd">    and observer positions and velocities.</span>

<span class="sd">    DEPRECATED.  Use radec(..., rate=True) in new code.</span>

<span class="sd">    Parameters</span>
<span class="sd">    ----------</span>
<span class="sd">    orbit : Orbit or list of Orbit (n,)</span>
<span class="sd">        Orbit(s) for which to calculate slant range rate.</span>
<span class="sd">    time : array_like or astropy.time.Time (m,)</span>
<span class="sd">        If float (array), then should correspond to GPS seconds; i.e., seconds</span>
<span class="sd">        since 1980-01-06 00:00:00 UTC</span>
<span class="sd">    obsPos : array_like (m, 3), optional</span>
<span class="sd">        Positions of observers at given times.</span>
<span class="sd">    obsVel : array_like (m, 3), optional</span>
<span class="sd">        Velocity of observers at given times.</span>
<span class="sd">    observer : Observer or list of Observers (m,), optional</span>
<span class="sd">        Observer(s) used to calculate obsPos and obsVel.</span>
<span class="sd">    propagator : Propagator, optional</span>
<span class="sd">        The propagator instance to use.</span>
<span class="sd">    obsAngleCorrection : {None, &quot;linear&quot;, &quot;exact&quot;}, optional</span>
<span class="sd">        Correct actual angle to observed angle, meaning account for light-time</span>
<span class="sd">        delay, and aberration due to the observer&#39;s velocity.  None means don&#39;t</span>
<span class="sd">        do any correction.  &quot;linear&quot; means do an aberration correction and first</span>
<span class="sd">        order light-time correction.  &quot;exact&quot; means do an aberration correction</span>
<span class="sd">        and iteratively solve for the exact light-time correction.  (The</span>
<span class="sd">        &quot;linear&quot; correction is almost always sufficiently accurate).</span>

<span class="sd">    Notes</span>
<span class="sd">    -----</span>
<span class="sd">    Exactly 1 of `obsPos` and `observer` must be supplied.  `observer` and</span>
<span class="sd">    `obsPos` follow similar broadcasting rules as detailed below explicitly only</span>
<span class="sd">    for `obsPos`.  If `obsPos` is specified, `obsVel` must also be specified and</span>
<span class="sd">    congruent to `obsPos`.</span>

<span class="sd">    The length of `time` and `obsPos` must match or be broadcastable to match.</span>
<span class="sd">    If `orbit` is scalar-valued (an Orbit instead of a list of Orbit), then that</span>
<span class="sd">    dimension will be squeezed out in the return value.  Likewise, if both</span>
<span class="sd">    `time` and `obsPos` are scalar, that dimension will be squeezed out.</span>

<span class="sd">    For Keplerian orbit propagation it is more efficient to use a &quot;vector Orbit&quot;</span>
<span class="sd">    instead of a list of single scalar Orbits.</span>

<span class="sd">    When doing light time corrections, the time argument is the arrival time of</span>
<span class="sd">    the photons at the observer, as opposed to the emission time at the</span>
<span class="sd">    satellite.</span>

<span class="sd">    Returns</span>
<span class="sd">    -------</span>
<span class="sd">    ra : array_like (n, m)</span>
<span class="sd">        right ascension in radians</span>
<span class="sd">    raRate : array_like (n, m)</span>
<span class="sd">        Rate of change of right ascension*cos(dec) in radians per second.</span>
<span class="sd">    dec : array_link (n, m)</span>
<span class="sd">        declination in radians</span>
<span class="sd">    decRate : array_like (n, m)</span>
<span class="sd">        Rate of change of declination in radians per second.</span>
<span class="sd">    slantRange : array_like (n, m)</span>
<span class="sd">        Range in meters</span>
<span class="sd">    slantRangeRate : array_like (n, m)</span>
<span class="sd">        Slant range rate in meters per second.</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="kn">import</span><span class="w"> </span><span class="nn">warnings</span>
    <span class="n">warnings</span><span class="o">.</span><span class="n">warn</span><span class="p">(</span><span class="s2">&quot;This function is deprecated; use &quot;</span>
                  <span class="s2">&quot;ssapy.compute.radec(..., rate=True)&quot;</span><span class="p">)</span>
    <span class="n">ra</span><span class="p">,</span> <span class="n">dec</span><span class="p">,</span> <span class="n">slant</span><span class="p">,</span> <span class="n">raRate</span><span class="p">,</span> <span class="n">decRate</span><span class="p">,</span> <span class="n">slantRate</span> <span class="o">=</span> <span class="n">radec</span><span class="p">(</span>
        <span class="n">orbit</span><span class="p">,</span> <span class="n">time</span><span class="p">,</span> <span class="n">obsPos</span><span class="o">=</span><span class="n">obsPos</span><span class="p">,</span> <span class="n">obsVel</span><span class="o">=</span><span class="n">obsVel</span><span class="p">,</span> <span class="n">observer</span><span class="o">=</span><span class="n">observer</span><span class="p">,</span>
        <span class="n">propagator</span><span class="o">=</span><span class="n">propagator</span><span class="p">,</span> <span class="n">obsAngleCorrection</span><span class="o">=</span><span class="n">obsAngleCorrection</span>
    <span class="p">)</span>

    <span class="k">return</span> <span class="n">raRate</span><span class="p">,</span> <span class="n">decRate</span><span class="p">,</span> <span class="n">slantRate</span></div>


<div class="viewcode-block" id="rvObsToRaDecRate"><a class="viewcode-back" href="../../api/ssapy.compute.rvObsToRaDecRate.html#ssapy.compute.rvObsToRaDecRate">[docs]</a><span class="k">def</span><span class="w"> </span><span class="nf">rvObsToRaDecRate</span><span class="p">(</span><span class="n">r</span><span class="p">,</span> <span class="n">v</span><span class="p">,</span> <span class="n">obsPos</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">obsVel</span><span class="o">=</span><span class="kc">None</span><span class="p">):</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;Convert object and observer position and velocity to angles.</span>

<span class="sd">    This only does the geometric part; it ignores light travel time,</span>
<span class="sd">    which may be applied to the object location before input.  Assumes</span>
<span class="sd">    that r, v, obsPos, and obsVel all have common shape.</span>

<span class="sd">    Parameters</span>
<span class="sd">    ----------</span>
<span class="sd">    r : array_like (..., 3)</span>
<span class="sd">        object position in meters</span>
<span class="sd">    v : array_like (..., 3)</span>
<span class="sd">        object velocity in meters per second</span>
<span class="sd">    obsPos : array_like (..., 3)</span>
<span class="sd">        observer position in meters</span>
<span class="sd">    obsVel : array_like (..., 3), optional</span>
<span class="sd">        observer velocity in meters per second</span>

<span class="sd">    Returns</span>
<span class="sd">    -------</span>
<span class="sd">    ra : array_like (...)</span>
<span class="sd">        right ascension in radians</span>
<span class="sd">    dec : array_link (...)</span>
<span class="sd">        declination in radians</span>
<span class="sd">    slantRange : array_like (...)</span>
<span class="sd">        Range in meters</span>
<span class="sd">    raRate : array_like (...)</span>
<span class="sd">        Rate of change of right ascension*cos(dec) in radians per second.</span>
<span class="sd">    decRate : array_like (...)</span>
<span class="sd">        Rate of change of declination in radians per second.</span>
<span class="sd">    slantRangeRate : array_like (...)</span>
<span class="sd">        Slant range rate in meters per second.</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="k">if</span> <span class="n">obsPos</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
        <span class="n">obsPos</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">zeros_like</span><span class="p">(</span><span class="n">r</span><span class="p">)</span>

    <span class="n">dr</span> <span class="o">=</span> <span class="n">r</span> <span class="o">-</span> <span class="n">obsPos</span>
    <span class="n">slantRange</span> <span class="o">=</span> <span class="n">norm</span><span class="p">(</span><span class="n">dr</span><span class="p">)</span>
    <span class="n">ra</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">arctan2</span><span class="p">(</span><span class="n">dr</span><span class="p">[</span><span class="o">...</span><span class="p">,</span> <span class="mi">1</span><span class="p">],</span> <span class="n">dr</span><span class="p">[</span><span class="o">...</span><span class="p">,</span> <span class="mi">0</span><span class="p">])</span>
    <span class="n">dec</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">arcsin</span><span class="p">(</span><span class="n">dr</span><span class="p">[</span><span class="o">...</span><span class="p">,</span> <span class="mi">2</span><span class="p">]</span> <span class="o">/</span> <span class="n">slantRange</span><span class="p">)</span>

    <span class="k">if</span> <span class="n">obsVel</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
        <span class="n">obsVel</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">zeros_like</span><span class="p">(</span><span class="n">v</span><span class="p">)</span>
    <span class="n">dv</span> <span class="o">=</span> <span class="n">v</span> <span class="o">-</span> <span class="n">obsVel</span>

    <span class="c1"># Now need to rotate to ra/dec coords</span>
    <span class="n">sd</span><span class="p">,</span> <span class="n">cd</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">sin</span><span class="p">(</span><span class="n">dec</span><span class="p">),</span> <span class="n">np</span><span class="o">.</span><span class="n">cos</span><span class="p">(</span><span class="n">dec</span><span class="p">)</span>
    <span class="n">sa</span><span class="p">,</span> <span class="n">ca</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">sin</span><span class="p">(</span><span class="n">ra</span><span class="p">),</span> <span class="n">np</span><span class="o">.</span><span class="n">cos</span><span class="p">(</span><span class="n">ra</span><span class="p">)</span>

    <span class="n">rHat</span> <span class="o">=</span> <span class="n">normed</span><span class="p">(</span><span class="n">dr</span><span class="p">)</span>  <span class="c1"># (n, m, 3)</span>

    <span class="n">raHat</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">zeros_like</span><span class="p">(</span><span class="n">rHat</span><span class="p">,</span> <span class="n">dtype</span><span class="o">=</span><span class="nb">float</span><span class="p">)</span>
    <span class="n">raHat</span><span class="p">[</span><span class="o">...</span><span class="p">,</span> <span class="mi">0</span><span class="p">]</span> <span class="o">=</span> <span class="o">-</span><span class="n">sa</span>
    <span class="n">raHat</span><span class="p">[</span><span class="o">...</span><span class="p">,</span> <span class="mi">1</span><span class="p">]</span> <span class="o">=</span> <span class="n">ca</span>

    <span class="n">decHat</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">zeros_like</span><span class="p">(</span><span class="n">raHat</span><span class="p">)</span>
    <span class="n">decHat</span><span class="p">[</span><span class="o">...</span><span class="p">,</span> <span class="mi">0</span><span class="p">]</span> <span class="o">=</span> <span class="o">-</span><span class="n">sd</span> <span class="o">*</span> <span class="n">ca</span>
    <span class="n">decHat</span><span class="p">[</span><span class="o">...</span><span class="p">,</span> <span class="mi">1</span><span class="p">]</span> <span class="o">=</span> <span class="o">-</span><span class="n">sd</span> <span class="o">*</span> <span class="n">sa</span>
    <span class="n">decHat</span><span class="p">[</span><span class="o">...</span><span class="p">,</span> <span class="mi">2</span><span class="p">]</span> <span class="o">=</span> <span class="n">cd</span>

    <span class="n">raRate</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">einsum</span><span class="p">(</span><span class="s2">&quot;...i,...i-&gt;...&quot;</span><span class="p">,</span> <span class="n">dv</span><span class="p">,</span> <span class="n">raHat</span><span class="p">)</span> <span class="o">/</span> <span class="n">slantRange</span>
    <span class="n">decRate</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">einsum</span><span class="p">(</span><span class="s2">&quot;...i,...i-&gt;...&quot;</span><span class="p">,</span> <span class="n">dv</span><span class="p">,</span> <span class="n">decHat</span><span class="p">)</span> <span class="o">/</span> <span class="n">slantRange</span>
    <span class="n">rangeRate</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">einsum</span><span class="p">(</span><span class="s2">&quot;...i,...i-&gt;...&quot;</span><span class="p">,</span> <span class="n">dv</span><span class="p">,</span> <span class="n">rHat</span><span class="p">)</span>
    <span class="k">return</span> <span class="n">ra</span><span class="p">,</span> <span class="n">dec</span><span class="p">,</span> <span class="n">slantRange</span><span class="p">,</span> <span class="n">raRate</span><span class="p">,</span> <span class="n">decRate</span><span class="p">,</span> <span class="n">rangeRate</span></div>


<div class="viewcode-block" id="radecRateObsToRV"><a class="viewcode-back" href="../../api/ssapy.compute.radecRateObsToRV.html#ssapy.compute.radecRateObsToRV">[docs]</a><span class="k">def</span><span class="w"> </span><span class="nf">radecRateObsToRV</span><span class="p">(</span><span class="n">ra</span><span class="p">,</span> <span class="n">dec</span><span class="p">,</span> <span class="n">slantRange</span><span class="p">,</span> <span class="n">raRate</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">decRate</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">slantRangeRate</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">obsPos</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">obsVel</span><span class="o">=</span><span class="kc">None</span><span class="p">):</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;Convert object angles and observer position to 3D observer position</span>

<span class="sd">    This only does the geometric part; it ignores light travel time.  This</span>
<span class="sd">    is the inverse of rvObsToRaDecRate.</span>

<span class="sd">    If obsVel is None, then the returned velocity will also be None.</span>

<span class="sd">    Parameters</span>
<span class="sd">    ----------</span>
<span class="sd">    ra : array_like (...)</span>
<span class="sd">        right ascension in radians</span>
<span class="sd">    dec : array_like (...)</span>
<span class="sd">        declination in radians</span>
<span class="sd">    slantRange : array_like (...)</span>
<span class="sd">        Range in meters</span>
<span class="sd">    raRate : array_like (...)</span>
<span class="sd">        Rate of change of right ascension*cos(dec) in radians per second.</span>
<span class="sd">    decRate : array_like (...)</span>
<span class="sd">        Rate of change of declination in radians per second.</span>
<span class="sd">    slantRangeRate : array_like (...)</span>
<span class="sd">        Slant range rate in meters per second.</span>
<span class="sd">    obsPos : array_like (..., 3)</span>
<span class="sd">        Observer position in meters</span>
<span class="sd">    obsVel : array_like (..., 3)</span>
<span class="sd">        Observer velocity in meters</span>

<span class="sd">    Returns</span>
<span class="sd">    -------</span>
<span class="sd">    r : array_like (..., 3)</span>
<span class="sd">        object position in meters</span>
<span class="sd">    v : array_like (..., 3)</span>
<span class="sd">        object velocity in meters per second</span>
<span class="sd">        observer velocity in meters per second</span>

<span class="sd">    v is None if obsVel is None.</span>
<span class="sd">    &quot;&quot;&quot;</span>

    <span class="k">if</span> <span class="n">obsPos</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
        <span class="k">return</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s1">&#39;obsPos must be set!&#39;</span><span class="p">)</span>

    <span class="n">rHat</span> <span class="o">=</span> <span class="n">lb_to_unit</span><span class="p">(</span><span class="n">ra</span><span class="p">,</span> <span class="n">dec</span><span class="p">)</span>

    <span class="n">sd</span><span class="p">,</span> <span class="n">cd</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">sin</span><span class="p">(</span><span class="n">dec</span><span class="p">),</span> <span class="n">np</span><span class="o">.</span><span class="n">cos</span><span class="p">(</span><span class="n">dec</span><span class="p">)</span>
    <span class="n">sa</span><span class="p">,</span> <span class="n">ca</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">sin</span><span class="p">(</span><span class="n">ra</span><span class="p">),</span> <span class="n">np</span><span class="o">.</span><span class="n">cos</span><span class="p">(</span><span class="n">ra</span><span class="p">)</span>

    <span class="n">raHat</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">zeros_like</span><span class="p">(</span><span class="n">rHat</span><span class="p">,</span> <span class="n">dtype</span><span class="o">=</span><span class="nb">float</span><span class="p">)</span>
    <span class="n">raHat</span><span class="p">[</span><span class="o">...</span><span class="p">,</span> <span class="mi">0</span><span class="p">]</span> <span class="o">=</span> <span class="o">-</span><span class="n">sa</span>
    <span class="n">raHat</span><span class="p">[</span><span class="o">...</span><span class="p">,</span> <span class="mi">1</span><span class="p">]</span> <span class="o">=</span> <span class="n">ca</span>

    <span class="n">decHat</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">zeros_like</span><span class="p">(</span><span class="n">raHat</span><span class="p">)</span>
    <span class="n">decHat</span><span class="p">[</span><span class="o">...</span><span class="p">,</span> <span class="mi">0</span><span class="p">]</span> <span class="o">=</span> <span class="o">-</span><span class="n">sd</span> <span class="o">*</span> <span class="n">ca</span>
    <span class="n">decHat</span><span class="p">[</span><span class="o">...</span><span class="p">,</span> <span class="mi">1</span><span class="p">]</span> <span class="o">=</span> <span class="o">-</span><span class="n">sd</span> <span class="o">*</span> <span class="n">sa</span>
    <span class="n">decHat</span><span class="p">[</span><span class="o">...</span><span class="p">,</span> <span class="mi">2</span><span class="p">]</span> <span class="o">=</span> <span class="n">cd</span>
    <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">rHat</span><span class="o">.</span><span class="n">shape</span><span class="p">)</span> <span class="o">&gt;</span> <span class="mi">1</span><span class="p">:</span>
        <span class="n">slantRange</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">(</span><span class="n">slantRange</span><span class="p">)[</span><span class="o">...</span><span class="p">,</span> <span class="kc">None</span><span class="p">]</span>
        <span class="n">raRate</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">(</span><span class="n">raRate</span><span class="p">)[</span><span class="o">...</span><span class="p">,</span> <span class="kc">None</span><span class="p">]</span>
        <span class="n">decRate</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">(</span><span class="n">decRate</span><span class="p">)[</span><span class="o">...</span><span class="p">,</span> <span class="kc">None</span><span class="p">]</span>
        <span class="n">slantRangeRate</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">(</span><span class="n">slantRangeRate</span><span class="p">)[</span><span class="o">...</span><span class="p">,</span> <span class="kc">None</span><span class="p">]</span>

    <span class="n">r</span> <span class="o">=</span> <span class="n">obsPos</span> <span class="o">+</span> <span class="n">rHat</span> <span class="o">*</span> <span class="n">slantRange</span>
    <span class="k">if</span> <span class="n">obsVel</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
        <span class="n">v</span> <span class="o">=</span> <span class="kc">None</span>
    <span class="k">else</span><span class="p">:</span>
        <span class="n">v</span> <span class="o">=</span> <span class="p">(</span><span class="n">obsVel</span> <span class="o">+</span> <span class="n">rHat</span> <span class="o">*</span> <span class="n">slantRangeRate</span> <span class="o">+</span> <span class="n">slantRange</span> <span class="o">*</span> <span class="p">(</span><span class="n">raHat</span> <span class="o">*</span> <span class="n">raRate</span> <span class="o">+</span> <span class="n">decHat</span> <span class="o">*</span> <span class="n">decRate</span><span class="p">))</span>
    <span class="k">return</span> <span class="n">r</span><span class="p">,</span> <span class="n">v</span></div>


<div class="viewcode-block" id="earthShadowCoords"><a class="viewcode-back" href="../../api/ssapy.compute.earthShadowCoords.html#ssapy.compute.earthShadowCoords">[docs]</a><span class="k">def</span><span class="w"> </span><span class="nf">earthShadowCoords</span><span class="p">(</span><span class="n">r</span><span class="p">,</span> <span class="n">time</span><span class="p">):</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;Determine components of position `r` parallel and perpendicular to sun</span>
<span class="sd">    unit vector.</span>

<span class="sd">    The sun unit vector points from the center of the sun through the center of</span>
<span class="sd">    the Earth.  Decomposing a satellite position into these coordinates yields a</span>
<span class="sd">    simple model of whether or not the satellite is in Earth&#39;s shadow:</span>

<span class="sd">        r_par, r_perp = earthShadowCoords(r, time)</span>
<span class="sd">        inShadow = r_par &gt; 0 and r_perp &lt; EARTH_RADIUS</span>

<span class="sd">    Parameters</span>
<span class="sd">    ----------</span>
<span class="sd">    r : ndarray (3,)</span>
<span class="sd">        Position (GCRF) in meters</span>
<span class="sd">    time : float or astropy.time.Time</span>
<span class="sd">        If float, then should correspond to GPS seconds; i.e., seconds</span>
<span class="sd">        since 1980-01-06 00:00:00 UTC</span>

<span class="sd">    Returns</span>
<span class="sd">    -------</span>
<span class="sd">    r_par : float</span>
<span class="sd">        Position of satellite projected onto the sun unit vector in meters.</span>
<span class="sd">    r_perp : float</span>
<span class="sd">        Distance of satellite from Earth-Sun line in meters.</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">time</span><span class="p">,</span> <span class="n">Time</span><span class="p">):</span>
        <span class="n">time</span> <span class="o">=</span> <span class="n">time</span><span class="o">.</span><span class="n">gps</span>
    <span class="n">r_sun</span> <span class="o">=</span> <span class="n">sunPos</span><span class="p">(</span><span class="n">time</span><span class="p">,</span> <span class="n">fast</span><span class="o">=</span><span class="kc">False</span><span class="p">)</span>
    <span class="k">if</span> <span class="n">r</span><span class="o">.</span><span class="n">ndim</span> <span class="o">==</span> <span class="mi">1</span><span class="p">:</span>
        <span class="n">n_sun</span> <span class="o">=</span> <span class="o">-</span> <span class="n">r_sun</span> <span class="o">/</span> <span class="n">norm</span><span class="p">(</span><span class="n">r_sun</span><span class="p">)</span>
        <span class="n">r_par</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">dot</span><span class="p">(</span><span class="n">r</span><span class="p">,</span> <span class="n">n_sun</span><span class="p">)</span>
        <span class="n">r_perp</span> <span class="o">=</span> <span class="n">norm</span><span class="p">(</span><span class="n">r</span> <span class="o">-</span> <span class="n">n_sun</span> <span class="o">*</span> <span class="n">r_par</span><span class="p">)</span>
    <span class="k">else</span><span class="p">:</span>
        <span class="n">n_sun</span> <span class="o">=</span> <span class="o">-</span> <span class="n">r_sun</span> <span class="o">/</span> <span class="n">norm</span><span class="p">(</span><span class="n">r_sun</span><span class="p">)[:,</span> <span class="kc">None</span><span class="p">]</span>
        <span class="n">r_par</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">sum</span><span class="p">(</span><span class="n">r</span> <span class="o">*</span> <span class="n">n_sun</span><span class="p">,</span> <span class="n">axis</span><span class="o">=</span><span class="mi">1</span><span class="p">)</span>
        <span class="n">r_perp</span> <span class="o">=</span> <span class="n">norm</span><span class="p">(</span><span class="n">r</span> <span class="o">-</span> <span class="n">n_sun</span> <span class="o">*</span> <span class="n">r_par</span><span class="p">[:,</span> <span class="kc">None</span><span class="p">])</span>
    <span class="k">return</span> <span class="n">r_par</span><span class="p">,</span> <span class="n">r_perp</span></div>


<div class="viewcode-block" id="find_passes"><a class="viewcode-back" href="../../api/ssapy.compute.find_passes.html#ssapy.compute.find_passes">[docs]</a><span class="k">def</span><span class="w"> </span><span class="nf">find_passes</span><span class="p">(</span>
    <span class="n">orbit</span><span class="p">,</span> <span class="n">observers</span><span class="p">,</span>
    <span class="n">tStart</span><span class="p">,</span> <span class="n">tSpan</span><span class="p">,</span> <span class="n">dt</span><span class="p">,</span>
    <span class="n">propagator</span><span class="o">=</span><span class="n">KeplerianPropagator</span><span class="p">(),</span>
    <span class="n">horizon</span><span class="o">=</span><span class="n">np</span><span class="o">.</span><span class="n">deg2rad</span><span class="p">(</span><span class="mi">20</span><span class="p">)</span>
<span class="p">):</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;Find satellite overhead passes for a collection of observers.</span>

<span class="sd">    Uses a brute force test of a grid of time points from tStart to tStart+tSpan</span>
<span class="sd">    separated by dt.</span>

<span class="sd">    Returns passes even if they occur during the daytime or if the satellite is</span>
<span class="sd">    not illuminated by the sun.  The only criterion for a successful &quot;pass&quot; is</span>
<span class="sd">    for the topocentric altitude of the satellite to be above the input</span>
<span class="sd">    `horizon`.  More details about a pass can subsequently be obtained by</span>
<span class="sd">    running the `refine_passes` function.</span>

<span class="sd">    Note this function is only suitable for `EarthObserver`s and not</span>
<span class="sd">    `OrbitalObserver`s.</span>

<span class="sd">    Parameters</span>
<span class="sd">    ----------</span>
<span class="sd">    orbit : Orbit</span>
<span class="sd">        Satellite orbit in question.</span>
<span class="sd">    observers : List of EarthObserver.</span>
<span class="sd">        Earth observers for which to check satellite visibility.</span>
<span class="sd">    tStart : float or astropy.time.Time</span>
<span class="sd">        Beginning of search window.</span>
<span class="sd">        If float, then should correspond to GPS seconds; i.e., seconds</span>
<span class="sd">        since 1980-01-06 00:00:00 UTC</span>
<span class="sd">    tSpan : float or Quantity</span>
<span class="sd">        Time span in which to search for passes.</span>
<span class="sd">        If float, then seconds.</span>
<span class="sd">    dt : float or Quantity</span>
<span class="sd">        Time increment to use during search.  Satellite visibility will be</span>
<span class="sd">        computed every dt increment.  Smaller values will decrease the</span>
<span class="sd">        probability that a short duration pass will be missed, but will make the</span>
<span class="sd">        search take longer to complete.</span>
<span class="sd">        If float, then seconds.</span>
<span class="sd">    propagator : Propagator, optional</span>
<span class="sd">        The propagator instance to use.</span>
<span class="sd">    horizon : float or Quantity, optional</span>
<span class="sd">        Minimum altitude for which to consider a satellite &quot;visible&quot;.</span>
<span class="sd">        If float, then should be in radians.</span>

<span class="sd">    Returns</span>
<span class="sd">    -------</span>
<span class="sd">    passDict : dict</span>
<span class="sd">        keys are `EarthObserver`s.</span>
<span class="sd">        values are lists (possibly empty) of `astropy.Time` corresponding to</span>
<span class="sd">        visible passes of the satellite.  Only one time is returned per pass,</span>
<span class="sd">        so multiple times in the return list indicate multiple distinct passes.</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="kn">import</span><span class="w"> </span><span class="nn">astropy.units</span><span class="w"> </span><span class="k">as</span><span class="w"> </span><span class="nn">u</span>
    <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">tStart</span><span class="p">,</span> <span class="n">Time</span><span class="p">):</span>
        <span class="n">tStart</span> <span class="o">=</span> <span class="n">tStart</span><span class="o">.</span><span class="n">gps</span>
    <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">tSpan</span><span class="p">,</span> <span class="n">u</span><span class="o">.</span><span class="n">Quantity</span><span class="p">):</span>
        <span class="n">tSpan</span> <span class="o">=</span> <span class="n">tSpan</span><span class="o">.</span><span class="n">to</span><span class="p">(</span><span class="n">u</span><span class="o">.</span><span class="n">s</span><span class="p">)</span><span class="o">.</span><span class="n">value</span>
    <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">dt</span><span class="p">,</span> <span class="n">u</span><span class="o">.</span><span class="n">Quantity</span><span class="p">):</span>
        <span class="n">dt</span> <span class="o">=</span> <span class="n">dt</span><span class="o">.</span><span class="n">to</span><span class="p">(</span><span class="n">u</span><span class="o">.</span><span class="n">s</span><span class="p">)</span><span class="o">.</span><span class="n">value</span>
    <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">horizon</span><span class="p">,</span> <span class="n">u</span><span class="o">.</span><span class="n">Quantity</span><span class="p">):</span>
        <span class="n">horizon</span> <span class="o">=</span> <span class="n">horizon</span><span class="o">.</span><span class="n">to</span><span class="p">(</span><span class="n">u</span><span class="o">.</span><span class="n">rad</span><span class="p">)</span><span class="o">.</span><span class="n">value</span>
    <span class="n">times</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">arange</span><span class="p">(</span><span class="n">tStart</span><span class="p">,</span> <span class="n">tStart</span> <span class="o">+</span> <span class="n">tSpan</span><span class="p">,</span> <span class="n">dt</span><span class="p">)</span>
    <span class="n">out</span> <span class="o">=</span> <span class="p">{}</span>
    <span class="k">for</span> <span class="n">observer</span> <span class="ow">in</span> <span class="n">observers</span><span class="p">:</span>
        <span class="n">out</span><span class="p">[</span><span class="n">observer</span><span class="p">]</span> <span class="o">=</span> <span class="p">[]</span>
        <span class="n">alt</span><span class="p">,</span> <span class="n">_</span> <span class="o">=</span> <span class="n">quickAltAz</span><span class="p">(</span><span class="n">orbit</span><span class="p">,</span> <span class="n">times</span><span class="p">,</span> <span class="n">observer</span><span class="p">,</span> <span class="n">propagator</span><span class="o">=</span><span class="n">propagator</span><span class="p">)</span>
        <span class="n">w</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">nonzero</span><span class="p">(</span><span class="n">alt</span> <span class="o">&gt;</span> <span class="n">horizon</span><span class="p">)[</span><span class="mi">0</span><span class="p">]</span>
        <span class="k">for</span> <span class="n">wi</span> <span class="ow">in</span> <span class="n">w</span><span class="p">:</span>
            <span class="k">if</span> <span class="p">(</span><span class="n">wi</span> <span class="o">-</span> <span class="mi">1</span><span class="p">)</span> <span class="ow">in</span> <span class="n">w</span><span class="p">:</span>  <span class="c1"># already caught this pass</span>
                <span class="k">continue</span>
            <span class="n">out</span><span class="p">[</span><span class="n">observer</span><span class="p">]</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">Time</span><span class="p">(</span><span class="n">times</span><span class="p">[</span><span class="n">wi</span><span class="p">],</span> <span class="nb">format</span><span class="o">=</span><span class="s1">&#39;gps&#39;</span><span class="p">))</span>
    <span class="k">return</span> <span class="n">out</span></div>


<div class="viewcode-block" id="refine_pass"><a class="viewcode-back" href="../../api/ssapy.compute.refine_pass.html#ssapy.compute.refine_pass">[docs]</a><span class="k">def</span><span class="w"> </span><span class="nf">refine_pass</span><span class="p">(</span>
    <span class="n">orbit</span><span class="p">,</span>
    <span class="n">observer</span><span class="p">,</span>
    <span class="n">time</span><span class="p">,</span>
    <span class="n">propagator</span><span class="o">=</span><span class="n">KeplerianPropagator</span><span class="p">(),</span>
    <span class="n">horizon</span><span class="o">=</span><span class="n">np</span><span class="o">.</span><span class="n">deg2rad</span><span class="p">(</span><span class="mi">20</span><span class="p">),</span>
    <span class="n">maxSpan</span><span class="o">=</span><span class="mf">86400.0</span>
<span class="p">):</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;Refine a satellite overhead pass.</span>

<span class="sd">    Parameters</span>
<span class="sd">    ----------</span>
<span class="sd">    orbit : Orbit</span>
<span class="sd">        Orbit in question.</span>
<span class="sd">    observer : EarthObserver.</span>
<span class="sd">        Observer for which to refine pass.</span>
<span class="sd">    time : float or astropy.time.Time</span>
<span class="sd">        A time when satellite is visible to observer.  (Found using</span>
<span class="sd">        find_passes, for instance)</span>
<span class="sd">        If float, then should correspond to GPS seconds; i.e., seconds</span>
<span class="sd">        since 1980-01-06 00:00:00 UTC</span>
<span class="sd">    propagator : Propagator, optional</span>
<span class="sd">        The propagator instance to use.</span>
<span class="sd">    horizon : float or Quantity, optional</span>
<span class="sd">        Minimum altitude for which to consider a satellite &quot;visible&quot;.</span>
<span class="sd">        If float, then should be in radians.</span>
<span class="sd">    maxSpan : float or Quantity, optional</span>
<span class="sd">        Maximum amount of time before or after `time` to search for</span>
<span class="sd">        rise/set times, or time of max altitude.</span>
<span class="sd">        If float, then seconds.</span>

<span class="sd">    Returns</span>
<span class="sd">    -------</span>
<span class="sd">    dict</span>
<span class="sd">        Key/values are:</span>
<span class="sd">        tStart : Time</span>
<span class="sd">            Time at which Orbit rises above horizon</span>
<span class="sd">        tEnd : Time</span>
<span class="sd">            Time at which Orbit rises above horizon</span>
<span class="sd">        tMaxAlt : Time</span>
<span class="sd">            Time Orbit passes through maximum altitude</span>
<span class="sd">        maxAlt : Quantity</span>
<span class="sd">            Maximum altitude</span>
<span class="sd">        duration : Quantity</span>
<span class="sd">            Duration of pass.</span>
<span class="sd">        illumAtStart : bool</span>
<span class="sd">            Is satellite illuminated at `tStart`?</span>
<span class="sd">        illumAtEnd : bool</span>
<span class="sd">            Is satellite illuminated at `tEnd`?</span>
<span class="sd">        tTerminator : Time or None</span>
<span class="sd">            If illumAtStart != illumAtEnd, then time satellite passes through</span>
<span class="sd">            cylindrical terminator shadow.  Otherwise, None.</span>
<span class="sd">        sunAltStart : Quantity</span>
<span class="sd">            Altitude of sun at `tStart`</span>
<span class="sd">        sunAltEnd : Quantity</span>
<span class="sd">            Altitude of sun at `tEnd`</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="kn">from</span><span class="w"> </span><span class="nn">scipy.optimize</span><span class="w"> </span><span class="kn">import</span> <span class="n">bisect</span><span class="p">,</span> <span class="n">minimize_scalar</span>
    <span class="kn">import</span><span class="w"> </span><span class="nn">astropy.units</span><span class="w"> </span><span class="k">as</span><span class="w"> </span><span class="nn">u</span>
    <span class="kn">import</span><span class="w"> </span><span class="nn">warnings</span>

    <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">time</span><span class="p">,</span> <span class="n">Time</span><span class="p">):</span>
        <span class="n">time</span> <span class="o">=</span> <span class="n">time</span><span class="o">.</span><span class="n">gps</span>
    <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">horizon</span><span class="p">,</span> <span class="n">u</span><span class="o">.</span><span class="n">Quantity</span><span class="p">):</span>
        <span class="n">horizon</span> <span class="o">=</span> <span class="n">horizon</span><span class="o">.</span><span class="n">to</span><span class="p">(</span><span class="n">u</span><span class="o">.</span><span class="n">rad</span><span class="p">)</span><span class="o">.</span><span class="n">value</span>
    <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">maxSpan</span><span class="p">,</span> <span class="n">u</span><span class="o">.</span><span class="n">Quantity</span><span class="p">):</span>
        <span class="n">maxSpan</span> <span class="o">=</span> <span class="n">maxSpan</span><span class="o">.</span><span class="n">to</span><span class="p">(</span><span class="n">u</span><span class="o">.</span><span class="n">s</span><span class="p">)</span><span class="o">.</span><span class="n">value</span>

    <span class="k">def</span><span class="w"> </span><span class="nf">dalt</span><span class="p">(</span><span class="n">t</span><span class="p">):</span>
        <span class="k">return</span> <span class="p">(</span>
            <span class="n">horizon</span> <span class="o">-</span> <span class="n">quickAltAz</span><span class="p">(</span><span class="n">orbit</span><span class="p">,</span> <span class="n">t</span><span class="p">,</span> <span class="n">observer</span><span class="p">,</span> <span class="n">propagator</span><span class="o">=</span><span class="n">propagator</span><span class="p">)[</span><span class="mi">0</span><span class="p">]</span>
        <span class="p">)</span>

    <span class="c1"># Height &quot;outside&quot; of cylindrical Earth shadow model.</span>
    <span class="k">def</span><span class="w"> </span><span class="nf">dshadow</span><span class="p">(</span><span class="n">t</span><span class="p">):</span>
        <span class="n">r</span><span class="p">,</span> <span class="n">_</span> <span class="o">=</span> <span class="n">rv</span><span class="p">(</span><span class="n">orbit</span><span class="p">,</span> <span class="n">t</span><span class="p">,</span> <span class="n">propagator</span><span class="o">=</span><span class="n">propagator</span><span class="p">)</span>
        <span class="n">r_par</span><span class="p">,</span> <span class="n">r_perp</span> <span class="o">=</span> <span class="n">earthShadowCoords</span><span class="p">(</span><span class="n">r</span><span class="p">,</span> <span class="n">t</span><span class="p">)</span>
        <span class="n">height</span> <span class="o">=</span> <span class="n">r_perp</span> <span class="o">-</span> <span class="n">EARTH_RADIUS</span>
        <span class="k">if</span> <span class="n">r_par</span> <span class="o">&lt;</span> <span class="mi">0</span><span class="p">:</span>
            <span class="c1"># a bit of a hack, if the sat is on the sun side, then we&#39;ll</span>
            <span class="c1"># return abs(dshadow) so that the value is positive, which indicates</span>
            <span class="c1"># illumination.</span>
            <span class="k">return</span> <span class="nb">abs</span><span class="p">(</span><span class="n">height</span><span class="p">)</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="k">return</span> <span class="n">height</span>

    <span class="c1"># Bracket and then bisect to find rise/set times</span>
    <span class="k">def</span><span class="w"> </span><span class="nf">bracket</span><span class="p">(</span><span class="n">f</span><span class="p">,</span> <span class="n">x</span><span class="p">,</span> <span class="n">dx</span><span class="p">,</span> <span class="n">xmax</span><span class="p">):</span>
        <span class="n">x0</span><span class="p">,</span> <span class="n">x1</span> <span class="o">=</span> <span class="n">x</span><span class="p">,</span> <span class="n">x</span> <span class="o">+</span> <span class="n">dx</span>
        <span class="n">f0</span><span class="p">,</span> <span class="n">f1</span> <span class="o">=</span> <span class="n">f</span><span class="p">(</span><span class="n">x0</span><span class="p">),</span> <span class="n">f</span><span class="p">(</span><span class="n">x1</span><span class="p">)</span>
        <span class="k">while</span> <span class="n">f0</span> <span class="o">*</span> <span class="n">f1</span> <span class="o">&gt;</span> <span class="mi">0</span> <span class="ow">and</span> <span class="nb">abs</span><span class="p">(</span><span class="n">x1</span> <span class="o">-</span> <span class="n">x0</span><span class="p">)</span> <span class="o">&lt;</span> <span class="n">xmax</span><span class="p">:</span>
            <span class="n">x1</span> <span class="o">+=</span> <span class="n">dx</span>
            <span class="n">f1</span> <span class="o">=</span> <span class="n">f</span><span class="p">(</span><span class="n">x1</span><span class="p">)</span>
        <span class="k">return</span> <span class="n">x1</span>

    <span class="n">tLow</span> <span class="o">=</span> <span class="n">bracket</span><span class="p">(</span><span class="n">dalt</span><span class="p">,</span> <span class="n">time</span><span class="p">,</span> <span class="o">-</span><span class="mi">300</span><span class="p">,</span> <span class="n">maxSpan</span><span class="p">)</span>
    <span class="k">if</span> <span class="n">dalt</span><span class="p">(</span><span class="n">tLow</span><span class="p">)</span> <span class="o">*</span> <span class="n">dalt</span><span class="p">(</span><span class="n">time</span><span class="p">)</span> <span class="o">&gt;</span> <span class="mi">0</span><span class="p">:</span>  <span class="c1"># didn&#39;t bracket, use tLow and issue warning</span>
        <span class="n">warnings</span><span class="o">.</span><span class="n">warn</span><span class="p">(</span><span class="s2">&quot;Failed to bracket.  tStart is not rise time!&quot;</span><span class="p">)</span>
        <span class="n">tStart</span> <span class="o">=</span> <span class="n">tLow</span>
    <span class="k">else</span><span class="p">:</span>
        <span class="n">tStart</span> <span class="o">=</span> <span class="n">bisect</span><span class="p">(</span><span class="n">dalt</span><span class="p">,</span> <span class="n">tLow</span><span class="p">,</span> <span class="n">time</span><span class="p">)</span>
    <span class="n">tStart</span> <span class="o">=</span> <span class="n">Time</span><span class="p">(</span><span class="n">tStart</span><span class="p">,</span> <span class="nb">format</span><span class="o">=</span><span class="s1">&#39;gps&#39;</span><span class="p">)</span>
    <span class="n">tStart</span><span class="o">.</span><span class="n">format</span> <span class="o">=</span> <span class="s1">&#39;iso&#39;</span>

    <span class="n">tHigh</span> <span class="o">=</span> <span class="n">bracket</span><span class="p">(</span><span class="n">dalt</span><span class="p">,</span> <span class="n">time</span><span class="p">,</span> <span class="mi">300</span><span class="p">,</span> <span class="n">maxSpan</span><span class="p">)</span>
    <span class="k">if</span> <span class="n">dalt</span><span class="p">(</span><span class="n">tHigh</span><span class="p">)</span> <span class="o">*</span> <span class="n">dalt</span><span class="p">(</span><span class="n">time</span><span class="p">)</span> <span class="o">&gt;</span> <span class="mi">0</span><span class="p">:</span>
        <span class="n">warnings</span><span class="o">.</span><span class="n">warn</span><span class="p">(</span><span class="s2">&quot;Failed to bracket.  tEnd is not set time!&quot;</span><span class="p">)</span>
        <span class="n">tEnd</span> <span class="o">=</span> <span class="n">tHigh</span>
    <span class="k">else</span><span class="p">:</span>
        <span class="n">tEnd</span> <span class="o">=</span> <span class="n">bisect</span><span class="p">(</span><span class="n">dalt</span><span class="p">,</span> <span class="n">time</span><span class="p">,</span> <span class="n">tHigh</span><span class="p">)</span>
    <span class="n">tEnd</span> <span class="o">=</span> <span class="n">Time</span><span class="p">(</span><span class="n">tEnd</span><span class="p">,</span> <span class="nb">format</span><span class="o">=</span><span class="s1">&#39;gps&#39;</span><span class="p">)</span>
    <span class="n">tEnd</span><span class="o">.</span><span class="n">format</span> <span class="o">=</span> <span class="s1">&#39;iso&#39;</span>

    <span class="c1"># Find maximum altitude</span>
    <span class="n">dalt1</span> <span class="o">=</span> <span class="n">dalt</span><span class="p">(</span><span class="n">tStart</span><span class="o">.</span><span class="n">gps</span><span class="p">)</span>
    <span class="n">dalt2</span> <span class="o">=</span> <span class="n">dalt</span><span class="p">(</span><span class="n">time</span><span class="p">)</span>
    <span class="n">dalt3</span> <span class="o">=</span> <span class="n">dalt</span><span class="p">(</span><span class="n">tEnd</span><span class="o">.</span><span class="n">gps</span><span class="p">)</span>
    <span class="k">if</span> <span class="n">dalt2</span> <span class="o">&lt;</span> <span class="n">dalt1</span> <span class="ow">and</span> <span class="n">dalt2</span> <span class="o">&lt;</span> <span class="n">dalt3</span><span class="p">:</span>
        <span class="n">result</span> <span class="o">=</span> <span class="n">minimize_scalar</span><span class="p">(</span><span class="n">dalt</span><span class="p">,</span> <span class="p">(</span><span class="n">tStart</span><span class="o">.</span><span class="n">gps</span><span class="p">,</span> <span class="n">time</span><span class="p">,</span> <span class="n">tEnd</span><span class="o">.</span><span class="n">gps</span><span class="p">))</span>
        <span class="n">tMaxAlt</span> <span class="o">=</span> <span class="n">Time</span><span class="p">(</span><span class="n">result</span><span class="o">.</span><span class="n">x</span><span class="p">,</span> <span class="nb">format</span><span class="o">=</span><span class="s1">&#39;gps&#39;</span><span class="p">)</span>
        <span class="n">tMaxAlt</span><span class="o">.</span><span class="n">format</span> <span class="o">=</span> <span class="s1">&#39;iso&#39;</span>
        <span class="n">maxAlt</span> <span class="o">=</span> <span class="o">-</span><span class="n">result</span><span class="o">.</span><span class="n">fun</span> <span class="o">+</span> <span class="n">horizon</span>
    <span class="k">else</span><span class="p">:</span>
        <span class="n">ama</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">argmin</span><span class="p">([</span><span class="n">dalt1</span><span class="p">,</span> <span class="n">dalt2</span><span class="p">,</span> <span class="n">dalt3</span><span class="p">])</span>
        <span class="n">tMaxAlt</span> <span class="o">=</span> <span class="n">Time</span><span class="p">([</span><span class="n">tStart</span><span class="o">.</span><span class="n">gps</span><span class="p">,</span> <span class="n">time</span><span class="p">,</span> <span class="n">tEnd</span><span class="o">.</span><span class="n">gps</span><span class="p">][</span><span class="n">ama</span><span class="p">],</span> <span class="nb">format</span><span class="o">=</span><span class="s1">&#39;gps&#39;</span><span class="p">)</span>
        <span class="n">tMaxAlt</span><span class="o">.</span><span class="n">format</span> <span class="o">=</span> <span class="s1">&#39;iso&#39;</span>
        <span class="n">maxAlt</span> <span class="o">=</span> <span class="o">-</span><span class="p">[</span><span class="n">dalt1</span><span class="p">,</span> <span class="n">dalt2</span><span class="p">,</span> <span class="n">dalt3</span><span class="p">][</span><span class="n">ama</span><span class="p">]</span> <span class="o">+</span> <span class="n">horizon</span>
    <span class="n">duration</span> <span class="o">=</span> <span class="p">(</span><span class="n">tEnd</span> <span class="o">-</span> <span class="n">tStart</span><span class="p">)</span><span class="o">.</span><span class="n">to</span><span class="p">(</span><span class="n">u</span><span class="o">.</span><span class="n">min</span><span class="p">)</span>

    <span class="c1"># Find illumination state</span>
    <span class="n">illumAtStart</span> <span class="o">=</span> <span class="n">dshadow</span><span class="p">(</span><span class="n">tStart</span><span class="o">.</span><span class="n">gps</span><span class="p">)</span> <span class="o">&gt;</span> <span class="mi">0</span>
    <span class="n">sunAltStart</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">rad2deg</span><span class="p">(</span><span class="n">observer</span><span class="o">.</span><span class="n">sunAlt</span><span class="p">(</span><span class="n">tStart</span><span class="o">.</span><span class="n">gps</span><span class="p">))</span> <span class="o">*</span> <span class="n">u</span><span class="o">.</span><span class="n">deg</span>
    <span class="n">illumAtEnd</span> <span class="o">=</span> <span class="n">dshadow</span><span class="p">(</span><span class="n">tEnd</span><span class="o">.</span><span class="n">gps</span><span class="p">)</span> <span class="o">&gt;</span> <span class="mi">0</span>
    <span class="n">sunAltEnd</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">rad2deg</span><span class="p">(</span><span class="n">observer</span><span class="o">.</span><span class="n">sunAlt</span><span class="p">(</span><span class="n">tEnd</span><span class="o">.</span><span class="n">gps</span><span class="p">))</span> <span class="o">*</span> <span class="n">u</span><span class="o">.</span><span class="n">deg</span>

    <span class="c1"># If we transition between shadow/illuminated, then find the time of</span>
    <span class="c1"># transition (time of terminator pass)</span>
    <span class="k">if</span> <span class="n">illumAtStart</span> <span class="o">!=</span> <span class="n">illumAtEnd</span><span class="p">:</span>
        <span class="n">tTerminator</span> <span class="o">=</span> <span class="n">bisect</span><span class="p">(</span><span class="n">dshadow</span><span class="p">,</span> <span class="n">tStart</span><span class="o">.</span><span class="n">gps</span><span class="p">,</span> <span class="n">tEnd</span><span class="o">.</span><span class="n">gps</span><span class="p">)</span>
        <span class="n">tTerminator</span> <span class="o">=</span> <span class="n">Time</span><span class="p">(</span><span class="n">tTerminator</span><span class="p">,</span> <span class="nb">format</span><span class="o">=</span><span class="s1">&#39;gps&#39;</span><span class="p">)</span>
        <span class="n">tTerminator</span><span class="o">.</span><span class="n">format</span> <span class="o">=</span> <span class="s1">&#39;iso&#39;</span>
    <span class="k">else</span><span class="p">:</span>
        <span class="n">tTerminator</span> <span class="o">=</span> <span class="kc">None</span>

    <span class="k">return</span> <span class="p">{</span>
        <span class="s2">&quot;orbit&quot;</span><span class="p">:</span> <span class="n">orbit</span><span class="p">,</span>
        <span class="s2">&quot;observer&quot;</span><span class="p">:</span> <span class="n">observer</span><span class="p">,</span>
        <span class="s2">&quot;propagator&quot;</span><span class="p">:</span> <span class="n">propagator</span><span class="p">,</span>
        <span class="s2">&quot;horizon&quot;</span><span class="p">:</span> <span class="n">horizon</span><span class="p">,</span>
        <span class="s2">&quot;tStart&quot;</span><span class="p">:</span> <span class="n">tStart</span><span class="p">,</span>
        <span class="s2">&quot;tEnd&quot;</span><span class="p">:</span> <span class="n">tEnd</span><span class="p">,</span>
        <span class="s2">&quot;altStart&quot;</span><span class="p">:</span> <span class="n">np</span><span class="o">.</span><span class="n">rad2deg</span><span class="p">(</span><span class="o">-</span><span class="n">dalt</span><span class="p">(</span><span class="n">tStart</span><span class="o">.</span><span class="n">gps</span><span class="p">)</span> <span class="o">+</span> <span class="n">horizon</span><span class="p">)</span> <span class="o">*</span> <span class="n">u</span><span class="o">.</span><span class="n">deg</span><span class="p">,</span>
        <span class="s2">&quot;altEnd&quot;</span><span class="p">:</span> <span class="n">np</span><span class="o">.</span><span class="n">rad2deg</span><span class="p">(</span><span class="o">-</span><span class="n">dalt</span><span class="p">(</span><span class="n">tEnd</span><span class="o">.</span><span class="n">gps</span><span class="p">)</span> <span class="o">+</span> <span class="n">horizon</span><span class="p">)</span> <span class="o">*</span> <span class="n">u</span><span class="o">.</span><span class="n">deg</span><span class="p">,</span>
        <span class="s2">&quot;tMaxAlt&quot;</span><span class="p">:</span> <span class="n">tMaxAlt</span><span class="p">,</span>
        <span class="s2">&quot;maxAlt&quot;</span><span class="p">:</span> <span class="n">np</span><span class="o">.</span><span class="n">rad2deg</span><span class="p">(</span><span class="n">maxAlt</span><span class="p">)</span> <span class="o">*</span> <span class="n">u</span><span class="o">.</span><span class="n">deg</span><span class="p">,</span>
        <span class="s2">&quot;duration&quot;</span><span class="p">:</span> <span class="n">duration</span><span class="p">,</span>
        <span class="s2">&quot;illumAtStart&quot;</span><span class="p">:</span> <span class="n">illumAtStart</span><span class="p">,</span>
        <span class="s2">&quot;illumAtEnd&quot;</span><span class="p">:</span> <span class="n">illumAtEnd</span><span class="p">,</span>
        <span class="s2">&quot;tTerminator&quot;</span><span class="p">:</span> <span class="n">tTerminator</span><span class="p">,</span>
        <span class="s2">&quot;sunAltStart&quot;</span><span class="p">:</span> <span class="n">sunAltStart</span><span class="p">,</span>
        <span class="s2">&quot;sunAltEnd&quot;</span><span class="p">:</span> <span class="n">sunAltEnd</span>
    <span class="p">}</span></div>


<div class="viewcode-block" id="nby3shape"><a class="viewcode-back" href="../../api/ssapy.compute.nby3shape.html#ssapy.compute.nby3shape">[docs]</a><span class="k">def</span><span class="w"> </span><span class="nf">nby3shape</span><span class="p">(</span><span class="n">arr_</span><span class="p">):</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Reshapes or transforms an input NumPy array into a shape compatible with (n, 3).</span>

<span class="sd">    This function takes a NumPy array and ensures it has a shape of `(n, 3)`, </span>
<span class="sd">    where `n` is the number of rows. The behavior depends on the dimensionality of the input array:</span>

<span class="sd">    - If the input array is 1-dimensional, it reshapes it into a `(1, 3)` array.</span>
<span class="sd">    - If the input array is 2-dimensional:</span>
<span class="sd">        - If the second dimension already has size 3, the array is returned as-is.</span>
<span class="sd">        - Otherwise, the array is transposed.</span>

<span class="sd">    Parameters:</span>
<span class="sd">        arr_ (numpy.ndarray): The input NumPy array to reshape or transform.</span>

<span class="sd">    Returns:</span>
<span class="sd">        numpy.ndarray: The reshaped or transformed array with a shape of `(n, 3)`.</span>

<span class="sd">    Raises:</span>
<span class="sd">        ValueError: If the input array cannot be reshaped or transformed into the desired shape.</span>

<span class="sd">    Examples:</span>
<span class="sd">        &gt;&gt;&gt; import numpy as np</span>
<span class="sd">        &gt;&gt;&gt; arr1 = np.array([1, 2, 3])</span>
<span class="sd">        &gt;&gt;&gt; nby3shape(arr1)</span>
<span class="sd">        array([[1, 2, 3]])</span>

<span class="sd">        &gt;&gt;&gt; arr2 = np.array([[1, 2, 3], [4, 5, 6]])</span>
<span class="sd">        &gt;&gt;&gt; nby3shape(arr2)</span>
<span class="sd">        array([[1, 2, 3],</span>
<span class="sd">               [4, 5, 6]])</span>

<span class="sd">        &gt;&gt;&gt; arr3 = np.array([[1, 4], [2, 5], [3, 6]])</span>
<span class="sd">        &gt;&gt;&gt; nby3shape(arr3)</span>
<span class="sd">        array([[1, 2, 3],</span>
<span class="sd">               [4, 5, 6]])</span>
<span class="sd">    &quot;&quot;&quot;</span>

    <span class="k">if</span> <span class="n">arr_</span><span class="o">.</span><span class="n">ndim</span> <span class="o">==</span> <span class="mi">1</span><span class="p">:</span>
        <span class="k">return</span> <span class="n">np</span><span class="o">.</span><span class="n">reshape</span><span class="p">(</span><span class="n">arr_</span><span class="p">,</span> <span class="p">(</span><span class="mi">1</span><span class="p">,</span> <span class="mi">3</span><span class="p">))</span>
    <span class="k">if</span> <span class="n">arr_</span><span class="o">.</span><span class="n">ndim</span> <span class="o">==</span> <span class="mi">2</span><span class="p">:</span>
        <span class="k">if</span> <span class="n">np</span><span class="o">.</span><span class="n">shape</span><span class="p">(</span><span class="n">arr_</span><span class="p">)[</span><span class="mi">1</span><span class="p">]</span> <span class="o">==</span> <span class="mi">3</span><span class="p">:</span>
            <span class="k">return</span> <span class="n">arr_</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="k">return</span> <span class="n">arr_</span><span class="o">.</span><span class="n">T</span></div>


<div class="viewcode-block" id="calculate_orbital_elements"><a class="viewcode-back" href="../../api/ssapy.compute.calculate_orbital_elements.html#ssapy.compute.calculate_orbital_elements">[docs]</a><span class="k">def</span><span class="w"> </span><span class="nf">calculate_orbital_elements</span><span class="p">(</span><span class="n">r_</span><span class="p">,</span> <span class="n">v_</span><span class="p">,</span> <span class="n">mu_barycenter</span><span class="o">=</span><span class="n">EARTH_MU</span><span class="p">):</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Calculate the Keplerian orbital elements from position and velocity vectors.</span>

<span class="sd">    This function computes the Keplerian orbital elements (semi-major axis, eccentricity, inclination, true longitude, argument of periapsis, longitude of ascending node, true anomaly, and specific angular momentum) for one or more celestial objects given their position and velocity vectors.</span>

<span class="sd">    Parameters:</span>
<span class="sd">    ----------</span>
<span class="sd">    r_ : (n, 3) numpy.ndarray</span>
<span class="sd">        Array of position vectors (in meters) of the celestial objects. Each row represents a position vector.</span>
<span class="sd">    v_ : (n, 3) numpy.ndarray</span>
<span class="sd">        Array of velocity vectors (in meters per second) of the celestial objects. Each row represents a velocity vector.</span>
<span class="sd">    mu_barycenter : float, optional</span>
<span class="sd">        Gravitational parameter (standard gravitational constant times mass) of the central body (default is `EARTH_MU`). This parameter defines the gravitational influence of the central body on the orbiting object.</span>

<span class="sd">    Returns:</span>
<span class="sd">    -------</span>
<span class="sd">    dict</span>
<span class="sd">        A dictionary containing the orbital elements for each celestial object:</span>
<span class="sd">        - &#39;a&#39;: Semi-major axis (in meters).</span>
<span class="sd">        - &#39;e&#39;: Eccentricity (dimensionless).</span>
<span class="sd">        - &#39;i&#39;: Inclination (in radians).</span>
<span class="sd">        - &#39;tl&#39;: True longitude (in radians).</span>
<span class="sd">        - &#39;ap&#39;: Argument of periapsis (in radians).</span>
<span class="sd">        - &#39;raan&#39;: Longitude of ascending node (in radians).</span>
<span class="sd">        - &#39;ta&#39;: True anomaly (in radians).</span>
<span class="sd">        - &#39;L&#39;: Specific angular momentum (in meters squared per second).</span>

<span class="sd">    Notes:</span>
<span class="sd">    ------</span>
<span class="sd">    - Position and velocity vectors should be provided in the same units.</span>
<span class="sd">    - The function assumes that the input vectors are provided in an array where each row corresponds to a different celestial object.</span>
<span class="sd">    - Orbital elements are computed using standard orbital mechanics formulas.</span>
<span class="sd">    - The inclination is measured from the reference plane, and the argument of periapsis and true anomaly are measured in the orbital plane.</span>

<span class="sd">    Example:</span>
<span class="sd">    --------</span>
<span class="sd">    &gt;&gt;&gt; r = np.array([[1e7, 1e7, 1e7], [1e8, 1e8, 1e8]])</span>
<span class="sd">    &gt;&gt;&gt; v = np.array([[1e3, 2e3, 3e3], [4e3, 5e3, 6e3]])</span>
<span class="sd">    &gt;&gt;&gt; calculate_orbital_elements(r, v, mu_barycenter=3.986e14)</span>
<span class="sd">    {&#39;a&#39;: [1.5707e7, 2.234e8], &#39;e&#39;: [0.123, 0.456], &#39;i&#39;: [0.785, 0.654], &#39;tl&#39;: [2.345, 3.456], &#39;ap&#39;: [0.123, 0.456], &#39;raan&#39;: [1.234, 2.345], &#39;ta&#39;: [0.567, 1.678], &#39;L&#39;: [1.234e10, 2.345e11]}</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="c1"># mu_barycenter - all bodies interior to Earth</span>
    <span class="c1"># 1.0013415732186798 #All bodies of solar system</span>
    <span class="n">mu_</span> <span class="o">=</span> <span class="n">mu_barycenter</span>
    <span class="n">rarr</span> <span class="o">=</span> <span class="n">nby3shape</span><span class="p">(</span><span class="n">r_</span><span class="p">)</span>
    <span class="n">varr</span> <span class="o">=</span> <span class="n">nby3shape</span><span class="p">(</span><span class="n">v_</span><span class="p">)</span>
    <span class="n">aarr</span> <span class="o">=</span> <span class="p">[]</span>
    <span class="n">earr</span> <span class="o">=</span> <span class="p">[]</span>
    <span class="n">incarr</span> <span class="o">=</span> <span class="p">[]</span>
    <span class="n">true_longitudearr</span> <span class="o">=</span> <span class="p">[]</span>
    <span class="n">argument_of_periapsisarr</span> <span class="o">=</span> <span class="p">[]</span>
    <span class="n">longitude_of_ascending_nodearr</span> <span class="o">=</span> <span class="p">[]</span>
    <span class="n">true_anomalyarr</span> <span class="o">=</span> <span class="p">[]</span>
    <span class="n">hmagarr</span> <span class="o">=</span> <span class="p">[]</span>
    <span class="k">for</span> <span class="n">r</span><span class="p">,</span> <span class="n">v</span> <span class="ow">in</span> <span class="nb">zip</span><span class="p">(</span><span class="n">rarr</span><span class="p">,</span> <span class="n">varr</span><span class="p">):</span>
        <span class="n">r</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">(</span><span class="n">r</span><span class="p">)</span>  <span class="c1"># print(f&#39;r: {r}&#39;)</span>
        <span class="n">v</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">(</span><span class="n">v</span><span class="p">)</span>  <span class="c1"># print(f&#39;v: {v}&#39;)</span>

        <span class="n">rmag</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">sqrt</span><span class="p">(</span><span class="n">r</span><span class="o">.</span><span class="n">dot</span><span class="p">(</span><span class="n">r</span><span class="p">))</span>
        <span class="n">vmag</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">sqrt</span><span class="p">(</span><span class="n">v</span><span class="o">.</span><span class="n">dot</span><span class="p">(</span><span class="n">v</span><span class="p">))</span>

        <span class="n">h</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">cross</span><span class="p">(</span><span class="n">r</span><span class="p">,</span> <span class="n">v</span><span class="p">)</span>
        <span class="n">hmag</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">sqrt</span><span class="p">(</span><span class="n">h</span><span class="o">.</span><span class="n">dot</span><span class="p">(</span><span class="n">h</span><span class="p">))</span>
        <span class="n">n</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">cross</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">([</span><span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">1</span><span class="p">]),</span> <span class="n">h</span><span class="p">)</span>

        <span class="n">a</span> <span class="o">=</span> <span class="mi">1</span> <span class="o">/</span> <span class="p">((</span><span class="mi">2</span> <span class="o">/</span> <span class="n">rmag</span><span class="p">)</span> <span class="o">-</span> <span class="p">(</span><span class="n">vmag</span> <span class="o">**</span> <span class="mi">2</span><span class="p">)</span> <span class="o">/</span> <span class="n">mu_</span><span class="p">)</span>

        <span class="n">evector</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">cross</span><span class="p">(</span><span class="n">v</span><span class="p">,</span> <span class="n">h</span><span class="p">)</span> <span class="o">/</span> <span class="p">(</span><span class="n">mu_</span><span class="p">)</span> <span class="o">-</span> <span class="n">r</span> <span class="o">/</span> <span class="n">rmag</span>
        <span class="n">e</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">sqrt</span><span class="p">(</span><span class="n">evector</span><span class="o">.</span><span class="n">dot</span><span class="p">(</span><span class="n">evector</span><span class="p">))</span>

        <span class="n">inc</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">arccos</span><span class="p">(</span><span class="n">h</span><span class="p">[</span><span class="mi">2</span><span class="p">]</span> <span class="o">/</span> <span class="n">hmag</span><span class="p">)</span>

        <span class="k">if</span> <span class="n">np</span><span class="o">.</span><span class="n">dot</span><span class="p">(</span><span class="n">r</span><span class="p">,</span> <span class="n">v</span><span class="p">)</span> <span class="o">&gt;</span> <span class="mi">0</span><span class="p">:</span>
            <span class="n">true_anomaly</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">arccos</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">dot</span><span class="p">(</span><span class="n">evector</span><span class="p">,</span> <span class="n">r</span><span class="p">)</span> <span class="o">/</span> <span class="p">(</span><span class="n">e</span> <span class="o">*</span> <span class="n">rmag</span><span class="p">))</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">true_anomaly</span> <span class="o">=</span> <span class="mi">2</span> <span class="o">*</span> <span class="n">np</span><span class="o">.</span><span class="n">pi</span> <span class="o">-</span> <span class="n">np</span><span class="o">.</span><span class="n">arccos</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">dot</span><span class="p">(</span><span class="n">evector</span><span class="p">,</span> <span class="n">r</span><span class="p">)</span> <span class="o">/</span> <span class="p">(</span><span class="n">e</span> <span class="o">*</span> <span class="n">rmag</span><span class="p">))</span>
        <span class="k">if</span> <span class="n">evector</span><span class="p">[</span><span class="mi">2</span><span class="p">]</span> <span class="o">&gt;=</span> <span class="mi">0</span><span class="p">:</span>
            <span class="n">argument_of_periapsis</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">arccos</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">dot</span><span class="p">(</span><span class="n">n</span><span class="p">,</span> <span class="n">evector</span><span class="p">)</span> <span class="o">/</span> <span class="p">(</span><span class="n">e</span> <span class="o">*</span> <span class="n">np</span><span class="o">.</span><span class="n">sqrt</span><span class="p">(</span><span class="n">n</span><span class="o">.</span><span class="n">dot</span><span class="p">(</span><span class="n">n</span><span class="p">))))</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">argument_of_periapsis</span> <span class="o">=</span> <span class="mi">2</span> <span class="o">*</span> <span class="n">np</span><span class="o">.</span><span class="n">pi</span> <span class="o">-</span> <span class="n">np</span><span class="o">.</span><span class="n">arccos</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">dot</span><span class="p">(</span><span class="n">n</span><span class="p">,</span> <span class="n">evector</span><span class="p">)</span> <span class="o">/</span> <span class="p">(</span><span class="n">e</span> <span class="o">*</span> <span class="n">np</span><span class="o">.</span><span class="n">sqrt</span><span class="p">(</span><span class="n">n</span><span class="o">.</span><span class="n">dot</span><span class="p">(</span><span class="n">n</span><span class="p">))))</span>
        <span class="k">if</span> <span class="n">n</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span> <span class="o">&gt;=</span> <span class="mi">0</span><span class="p">:</span>
            <span class="n">longitude_of_ascending_node</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">arccos</span><span class="p">(</span><span class="n">n</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">/</span> <span class="n">np</span><span class="o">.</span><span class="n">sqrt</span><span class="p">(</span><span class="n">n</span><span class="o">.</span><span class="n">dot</span><span class="p">(</span><span class="n">n</span><span class="p">)))</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">longitude_of_ascending_node</span> <span class="o">=</span> <span class="mi">2</span> <span class="o">*</span> <span class="n">np</span><span class="o">.</span><span class="n">pi</span> <span class="o">-</span> <span class="n">np</span><span class="o">.</span><span class="n">arccos</span><span class="p">(</span><span class="n">n</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">/</span> <span class="n">np</span><span class="o">.</span><span class="n">sqrt</span><span class="p">(</span><span class="n">n</span><span class="o">.</span><span class="n">dot</span><span class="p">(</span><span class="n">n</span><span class="p">)))</span>

        <span class="n">true_longitude</span> <span class="o">=</span> <span class="n">true_anomaly</span> <span class="o">+</span> <span class="n">argument_of_periapsis</span> <span class="o">+</span> <span class="n">longitude_of_ascending_node</span>
        <span class="n">aarr</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">a</span><span class="p">)</span>
        <span class="n">earr</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">e</span><span class="p">)</span>
        <span class="n">incarr</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">inc</span><span class="p">)</span>
        <span class="n">true_longitudearr</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">true_longitude</span><span class="p">)</span>
        <span class="n">argument_of_periapsisarr</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">argument_of_periapsis</span><span class="p">)</span>
        <span class="n">longitude_of_ascending_nodearr</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">longitude_of_ascending_node</span><span class="p">)</span>
        <span class="n">true_anomalyarr</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">true_anomaly</span><span class="p">)</span>
        <span class="n">hmagarr</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">hmag</span><span class="p">)</span>
    <span class="k">return</span> <span class="p">{</span>
        <span class="s1">&#39;a&#39;</span><span class="p">:</span> <span class="n">aarr</span><span class="p">,</span>
        <span class="s1">&#39;e&#39;</span><span class="p">:</span> <span class="n">earr</span><span class="p">,</span>
        <span class="s1">&#39;i&#39;</span><span class="p">:</span> <span class="n">incarr</span><span class="p">,</span>
        <span class="s1">&#39;tl&#39;</span><span class="p">:</span> <span class="n">true_longitudearr</span><span class="p">,</span>
        <span class="s1">&#39;ap&#39;</span><span class="p">:</span> <span class="n">argument_of_periapsisarr</span><span class="p">,</span>
        <span class="s1">&#39;raan&#39;</span><span class="p">:</span> <span class="n">longitude_of_ascending_nodearr</span><span class="p">,</span>
        <span class="s1">&#39;ta&#39;</span><span class="p">:</span> <span class="n">true_anomalyarr</span><span class="p">,</span>
        <span class="s1">&#39;L&#39;</span><span class="p">:</span> <span class="n">hmagarr</span>
    <span class="p">}</span></div>


<span class="c1">######################################################################################</span>
<span class="c1"># Lambertian brightness functions</span>
<span class="c1">######################################################################################</span>


<div class="viewcode-block" id="moon_shine"><a class="viewcode-back" href="../../api/ssapy.compute.moon_shine.html#ssapy.compute.moon_shine">[docs]</a><span class="k">def</span><span class="w"> </span><span class="nf">moon_shine</span><span class="p">(</span><span class="n">r_moon</span><span class="p">,</span> <span class="n">r_sat</span><span class="p">,</span> <span class="n">r_earth</span><span class="p">,</span> <span class="n">r_sun</span><span class="p">,</span> <span class="n">radius</span><span class="p">,</span> <span class="n">albedo</span><span class="p">,</span> <span class="n">albedo_moon</span><span class="p">,</span> <span class="n">albedo_back</span><span class="p">,</span> <span class="n">albedo_front</span><span class="p">,</span> <span class="n">area_panels</span><span class="p">):</span>  <span class="c1"># In SI units, takes single values or arrays returns a fractional flux</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Calculate the fractional solar flux reflected from the Moon to the satellite.</span>

<span class="sd">    This function computes the fraction of solar flux reflected from the Moon to the satellite, including contributions from both the front and back surfaces of the satellite&#39;s solar panels.</span>

<span class="sd">    Parameters:</span>
<span class="sd">    ----------</span>
<span class="sd">    r_moon : (n, 3) numpy.ndarray</span>
<span class="sd">        Array of coordinates representing the position of the Moon.</span>
<span class="sd">    r_sat : (n, 3) numpy.ndarray</span>
<span class="sd">        Array of coordinates representing the position of the satellite.</span>
<span class="sd">    r_earth : (n, 3) numpy.ndarray</span>
<span class="sd">        Array of coordinates representing the position of the Earth.</span>
<span class="sd">    r_sun : (n, 3) numpy.ndarray</span>
<span class="sd">        Array of coordinates representing the position of the Sun.</span>
<span class="sd">    radius : float</span>
<span class="sd">        Radius of the satellite in meters.</span>
<span class="sd">    albedo : float</span>
<span class="sd">        Albedo of the satellite&#39;s surface.</span>
<span class="sd">    albedo_moon : float</span>
<span class="sd">        Albedo of the Moon.</span>
<span class="sd">    albedo_back : float</span>
<span class="sd">        Albedo of the back surface of the satellite&#39;s solar panels.</span>
<span class="sd">    albedo_front : float</span>
<span class="sd">        Albedo of the front surface of the satellite&#39;s solar panels.</span>
<span class="sd">    area_panels : float</span>
<span class="sd">        Area of the satellite&#39;s solar panels in square meters.</span>

<span class="sd">    Returns:</span>
<span class="sd">    -------</span>
<span class="sd">    dict</span>
<span class="sd">        Dictionary containing the flux contributions from the Moon to the satellite:</span>
<span class="sd">        - &#39;moon_bus&#39;: Fraction of solar flux reflected off the satellite&#39;s bus from the Moon.</span>
<span class="sd">        - &#39;moon_panels&#39;: Fraction of solar flux reflected off the satellite&#39;s panels from the Moon.</span>

<span class="sd">    Notes:</span>
<span class="sd">    ------</span>
<span class="sd">    - The function assumes that the solar panels are always facing the Sun and calculates flux based on the phase angles.</span>
<span class="sd">    - Fraction of solar flux contributions from both the front and back surfaces of the solar panels are computed.</span>

<span class="sd">    Example:</span>
<span class="sd">    --------</span>
<span class="sd">    &gt;&gt;&gt; r_moon = np.array([[1e8, 1e8, 1e8]])</span>
<span class="sd">    &gt;&gt;&gt; r_sat = np.array([[1e7, 1e7, 1e7]])</span>
<span class="sd">    &gt;&gt;&gt; r_earth = np.array([[0, 0, 0]])</span>
<span class="sd">    &gt;&gt;&gt; r_sun = np.array([[1e11, 0, 0]])</span>
<span class="sd">    &gt;&gt;&gt; moon_shine(r_moon, r_sat, r_earth, r_sun, radius=0.4, albedo=0.20, albedo_moon=0.12, albedo_back=0.50, albedo_front=0.05, area_panels=100)</span>
<span class="sd">    {&#39;moon_bus&#39;: array([...]), &#39;moon_panels&#39;: array([...])}</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="c1"># https://amostech.com/TechnicalPapers/2013/POSTER/COGNION.pdf</span>
    <span class="n">moon_phase_angle</span> <span class="o">=</span> <span class="n">get_angle</span><span class="p">(</span><span class="n">r_sun</span><span class="p">,</span> <span class="n">r_moon</span><span class="p">,</span> <span class="n">r_sat</span><span class="p">)</span>  <span class="c1"># Phase of the moon as viewed from the sat.</span>
    <span class="n">sun_angle</span> <span class="o">=</span> <span class="n">get_angle</span><span class="p">(</span><span class="n">r_sun</span><span class="p">,</span> <span class="n">r_sat</span><span class="p">,</span> <span class="n">r_moon</span><span class="p">)</span>  <span class="c1"># angle from Sun to object to Earth</span>
    <span class="n">moon_to_earth_angle</span> <span class="o">=</span> <span class="n">get_angle</span><span class="p">(</span><span class="n">r_moon</span><span class="p">,</span> <span class="n">r_sat</span><span class="p">,</span> <span class="n">r_earth</span><span class="p">)</span>
    <span class="n">r_moon_sat</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">linalg</span><span class="o">.</span><span class="n">norm</span><span class="p">(</span><span class="n">r_sat</span> <span class="o">-</span> <span class="n">r_moon</span><span class="p">,</span> <span class="n">axis</span><span class="o">=-</span><span class="mi">1</span><span class="p">)</span>
    <span class="n">r_earth_sat</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">linalg</span><span class="o">.</span><span class="n">norm</span><span class="p">(</span><span class="n">r_sat</span> <span class="o">-</span> <span class="n">r_earth</span><span class="p">,</span> <span class="n">axis</span><span class="o">=-</span><span class="mi">1</span><span class="p">)</span>  <span class="c1"># Earth is the observer.</span>
    <span class="n">flux_moon_to_sat</span> <span class="o">=</span> <span class="mi">2</span> <span class="o">/</span> <span class="mi">3</span> <span class="o">*</span> <span class="n">albedo_moon</span> <span class="o">*</span> <span class="n">MOON_RADIUS</span><span class="o">**</span><span class="mi">2</span> <span class="o">/</span> <span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">pi</span> <span class="o">*</span> <span class="p">(</span><span class="n">r_moon_sat</span><span class="p">)</span><span class="o">**</span><span class="mi">2</span><span class="p">)</span> <span class="o">*</span> <span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">sin</span><span class="p">(</span><span class="n">moon_phase_angle</span><span class="p">)</span> <span class="o">+</span> <span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">pi</span> <span class="o">-</span> <span class="n">moon_phase_angle</span><span class="p">)</span> <span class="o">*</span> <span class="n">np</span><span class="o">.</span><span class="n">cos</span><span class="p">(</span><span class="n">moon_phase_angle</span><span class="p">))</span>  <span class="c1"># Fraction of sunlight reflected from the Moon to satellite</span>
    <span class="c1"># Fraction of light from back of solar panel</span>
    <span class="n">flux_back</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">zeros_like</span><span class="p">(</span><span class="n">sun_angle</span><span class="p">)</span>
    <span class="n">flux_back</span><span class="p">[</span><span class="n">sun_angle</span> <span class="o">&gt;</span> <span class="n">np</span><span class="o">.</span><span class="n">pi</span> <span class="o">/</span> <span class="mi">2</span><span class="p">]</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">abs</span><span class="p">(</span><span class="n">albedo_back</span> <span class="o">*</span> <span class="n">area_panels</span> <span class="o">/</span> <span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">pi</span> <span class="o">*</span> <span class="n">r_earth_sat</span><span class="p">[</span><span class="n">sun_angle</span> <span class="o">&gt;</span> <span class="n">np</span><span class="o">.</span><span class="n">pi</span> <span class="o">/</span> <span class="mi">2</span><span class="p">]</span><span class="o">**</span><span class="mi">2</span><span class="p">)</span> <span class="o">*</span> <span class="n">np</span><span class="o">.</span><span class="n">cos</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">pi</span> <span class="o">-</span> <span class="n">moon_to_earth_angle</span><span class="p">[</span><span class="n">sun_angle</span> <span class="o">&gt;</span> <span class="n">np</span><span class="o">.</span><span class="n">pi</span> <span class="o">/</span> <span class="mi">2</span><span class="p">])</span> <span class="o">*</span> <span class="n">flux_moon_to_sat</span><span class="p">[</span><span class="n">sun_angle</span> <span class="o">&gt;</span> <span class="n">np</span><span class="o">.</span><span class="n">pi</span> <span class="o">/</span> <span class="mi">2</span><span class="p">])</span>  <span class="c1"># Fraction of Moon light reflected off back of solar panels - which are assumed to be always facing the Sun. Angle: Sun - Observer - Sat</span>
    <span class="n">flux_front</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">zeros_like</span><span class="p">(</span><span class="n">sun_angle</span><span class="p">)</span>
    <span class="n">flux_front</span><span class="p">[</span><span class="n">sun_angle</span> <span class="o">&lt;</span> <span class="n">np</span><span class="o">.</span><span class="n">pi</span> <span class="o">/</span> <span class="mi">2</span><span class="p">]</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">abs</span><span class="p">(</span><span class="n">albedo_front</span> <span class="o">*</span> <span class="n">area_panels</span> <span class="o">/</span> <span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">pi</span> <span class="o">*</span> <span class="n">r_earth_sat</span><span class="p">[</span><span class="n">sun_angle</span> <span class="o">&lt;</span> <span class="n">np</span><span class="o">.</span><span class="n">pi</span> <span class="o">/</span> <span class="mi">2</span><span class="p">]</span><span class="o">**</span><span class="mi">2</span><span class="p">)</span> <span class="o">*</span> <span class="n">np</span><span class="o">.</span><span class="n">cos</span><span class="p">(</span><span class="n">moon_to_earth_angle</span><span class="p">[</span><span class="n">sun_angle</span> <span class="o">&lt;</span> <span class="n">np</span><span class="o">.</span><span class="n">pi</span> <span class="o">/</span> <span class="mi">2</span><span class="p">])</span> <span class="o">*</span> <span class="n">flux_moon_to_sat</span><span class="p">[</span><span class="n">sun_angle</span> <span class="o">&lt;</span> <span class="n">np</span><span class="o">.</span><span class="n">pi</span> <span class="o">/</span> <span class="mi">2</span><span class="p">])</span>  <span class="c1"># Fraction of Sun light scattered off front of the solar panels - which are assumed to be always facing the Sun. Angle: Sun - Sat - Observer</span>
    <span class="n">flux_panels</span> <span class="o">=</span> <span class="n">flux_back</span> <span class="o">+</span> <span class="n">flux_front</span>
    <span class="n">flux_bus</span> <span class="o">=</span> <span class="mi">2</span> <span class="o">/</span> <span class="mi">3</span> <span class="o">*</span> <span class="n">albedo</span> <span class="o">*</span> <span class="n">radius</span><span class="o">**</span><span class="mi">2</span> <span class="o">/</span> <span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">pi</span> <span class="o">*</span> <span class="n">r_earth_sat</span><span class="o">**</span><span class="mi">2</span><span class="p">)</span> <span class="o">*</span> <span class="n">flux_moon_to_sat</span>
    <span class="k">return</span> <span class="p">{</span><span class="s1">&#39;moon_bus&#39;</span><span class="p">:</span> <span class="n">flux_bus</span><span class="p">,</span> <span class="s1">&#39;moon_panels&#39;</span><span class="p">:</span> <span class="n">flux_panels</span><span class="p">}</span></div>


<div class="viewcode-block" id="earth_shine"><a class="viewcode-back" href="../../api/ssapy.compute.earth_shine.html#ssapy.compute.earth_shine">[docs]</a><span class="k">def</span><span class="w"> </span><span class="nf">earth_shine</span><span class="p">(</span><span class="n">r_sat</span><span class="p">,</span> <span class="n">r_earth</span><span class="p">,</span> <span class="n">r_sun</span><span class="p">,</span> <span class="n">radius</span><span class="p">,</span> <span class="n">albedo</span><span class="p">,</span> <span class="n">albedo_earth</span><span class="p">,</span> <span class="n">albedo_back</span><span class="p">,</span> <span class="n">area_panels</span><span class="p">):</span>  <span class="c1"># In SI units, takes single values or arrays returns a flux</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Calculate the fractional flux of sunlight reflected from the Earth to the satellite.</span>

<span class="sd">    This function computes the flux of sunlight reflected from the Earth to the satellite, including contributions from the back surface of the satellite&#39;s solar panels.</span>

<span class="sd">    Parameters:</span>
<span class="sd">    ----------</span>
<span class="sd">    r_sat : (n, 3) numpy.ndarray</span>
<span class="sd">        Array of coordinates representing the position of the satellite.</span>
<span class="sd">    r_earth : (n, 3) numpy.ndarray</span>
<span class="sd">        Array of coordinates representing the position of the Earth.</span>
<span class="sd">    r_sun : (n, 3) numpy.ndarray</span>
<span class="sd">        Array of coordinates representing the position of the Sun.</span>
<span class="sd">    radius : float</span>
<span class="sd">        Radius of the satellite in meters.</span>
<span class="sd">    albedo : float</span>
<span class="sd">        Albedo of the satellite&#39;s surface.</span>
<span class="sd">    albedo_earth : float</span>
<span class="sd">        Albedo of the Earth.</span>
<span class="sd">    albedo_back : float</span>
<span class="sd">        Albedo of the back surface of the satellite&#39;s solar panels.</span>
<span class="sd">    area_panels : float</span>
<span class="sd">        Area of the satellite&#39;s solar panels in square meters.</span>

<span class="sd">    Returns:</span>
<span class="sd">    -------</span>
<span class="sd">    dict</span>
<span class="sd">        Dictionary containing the flux contributions from the Earth to the satellite:</span>
<span class="sd">        - &#39;earth_bus&#39;: Fraction of solar flux reflected off the satellite&#39;s bus from the Earth.</span>
<span class="sd">        - &#39;earth_panels&#39;: Fraction of solar flux reflected off the satellite&#39;s panels from the Earth.</span>

<span class="sd">    Notes:</span>
<span class="sd">    ------</span>
<span class="sd">    - The function assumes that the solar panels are always facing the Sun and calculates flux based on the phase angle.</span>
<span class="sd">    - Fraction of solar flux contributions from the back surface of the solar panels are computed.</span>

<span class="sd">    Example:</span>
<span class="sd">    --------</span>
<span class="sd">    &gt;&gt;&gt; r_sat = np.array([[1e7, 1e7, 1e7]])</span>
<span class="sd">    &gt;&gt;&gt; r_earth = np.array([[1.496e11, 0, 0]])</span>
<span class="sd">    &gt;&gt;&gt; r_sun = np.array([[0, 0, 0]])</span>
<span class="sd">    &gt;&gt;&gt; earth_shine(r_sat, r_earth, r_sun, radius=0.4, albedo=0.20, albedo_earth=0.30, albedo_back=0.50, area_panels=100)</span>
<span class="sd">    {&#39;earth_bus&#39;: array([...]), &#39;earth_panels&#39;: array([...])}</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="c1"># https://amostech.com/TechnicalPapers/2013/POSTER/COGNION.pdf</span>
    <span class="n">phase_angle</span> <span class="o">=</span> <span class="n">get_angle</span><span class="p">(</span><span class="n">r_sun</span><span class="p">,</span> <span class="n">r_sat</span><span class="p">,</span> <span class="n">r_earth</span><span class="p">)</span>  <span class="c1"># angle from Sun to object to Earth</span>
    <span class="n">earth_angle</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">pi</span> <span class="o">-</span> <span class="n">phase_angle</span>  <span class="c1"># Sun to Earth to object.</span>
    <span class="n">r_earth_sat</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">linalg</span><span class="o">.</span><span class="n">norm</span><span class="p">(</span><span class="n">r_sat</span> <span class="o">-</span> <span class="n">r_earth</span><span class="p">,</span> <span class="n">axis</span><span class="o">=-</span><span class="mi">1</span><span class="p">)</span>  <span class="c1"># Earth is the observer.</span>
    <span class="n">flux_earth_to_sat</span> <span class="o">=</span> <span class="mi">2</span> <span class="o">/</span> <span class="mi">3</span> <span class="o">*</span> <span class="n">albedo_earth</span> <span class="o">*</span> <span class="n">EARTH_RADIUS</span><span class="o">**</span><span class="mi">2</span> <span class="o">/</span> <span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">pi</span> <span class="o">*</span> <span class="p">(</span><span class="n">r_earth_sat</span><span class="p">)</span><span class="o">**</span><span class="mi">2</span><span class="p">)</span> <span class="o">*</span> <span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">sin</span><span class="p">(</span><span class="n">earth_angle</span><span class="p">)</span> <span class="o">+</span> <span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">pi</span> <span class="o">-</span> <span class="n">earth_angle</span><span class="p">)</span> <span class="o">*</span> <span class="n">np</span><span class="o">.</span><span class="n">cos</span><span class="p">(</span><span class="n">earth_angle</span><span class="p">))</span>  <span class="c1"># Fraction of sunlight reflected from the Earth to satellite</span>
    <span class="c1"># Fraction of light from back of solar panel</span>
    <span class="n">flux_back</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">zeros_like</span><span class="p">(</span><span class="n">phase_angle</span><span class="p">)</span>
    <span class="n">flux_back</span><span class="p">[</span><span class="n">phase_angle</span> <span class="o">&gt;</span> <span class="n">np</span><span class="o">.</span><span class="n">pi</span> <span class="o">/</span> <span class="mi">2</span><span class="p">]</span> <span class="o">=</span> <span class="n">albedo_back</span> <span class="o">*</span> <span class="n">area_panels</span> <span class="o">/</span> <span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">pi</span> <span class="o">*</span> <span class="n">r_earth_sat</span><span class="p">[</span><span class="n">phase_angle</span> <span class="o">&gt;</span> <span class="n">np</span><span class="o">.</span><span class="n">pi</span> <span class="o">/</span> <span class="mi">2</span><span class="p">]</span><span class="o">**</span><span class="mi">2</span><span class="p">)</span> <span class="o">*</span> <span class="n">np</span><span class="o">.</span><span class="n">cos</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">pi</span> <span class="o">-</span> <span class="n">phase_angle</span><span class="p">[</span><span class="n">phase_angle</span> <span class="o">&gt;</span> <span class="n">np</span><span class="o">.</span><span class="n">pi</span> <span class="o">/</span> <span class="mi">2</span><span class="p">])</span> <span class="o">*</span> <span class="n">flux_earth_to_sat</span><span class="p">[</span><span class="n">phase_angle</span> <span class="o">&gt;</span> <span class="n">np</span><span class="o">.</span><span class="n">pi</span> <span class="o">/</span> <span class="mi">2</span><span class="p">]</span>  <span class="c1"># Fraction of Earth light reflected off back of solar panels - which are assumed to be always facing the Sun. Angle: Sun - Observer - Sat</span>
    <span class="n">flux_bus</span> <span class="o">=</span> <span class="mi">2</span> <span class="o">/</span> <span class="mi">3</span> <span class="o">*</span> <span class="n">albedo</span> <span class="o">*</span> <span class="n">radius</span><span class="o">**</span><span class="mi">2</span> <span class="o">/</span> <span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">pi</span> <span class="o">*</span> <span class="n">r_earth_sat</span><span class="o">**</span><span class="mi">2</span><span class="p">)</span> <span class="o">*</span> <span class="n">flux_earth_to_sat</span>
    <span class="k">return</span> <span class="p">{</span><span class="s1">&#39;earth_bus&#39;</span><span class="p">:</span> <span class="n">flux_bus</span><span class="p">,</span> <span class="s1">&#39;earth_panels&#39;</span><span class="p">:</span> <span class="n">flux_back</span><span class="p">}</span></div>


<div class="viewcode-block" id="sun_shine"><a class="viewcode-back" href="../../api/ssapy.compute.sun_shine.html#ssapy.compute.sun_shine">[docs]</a><span class="k">def</span><span class="w"> </span><span class="nf">sun_shine</span><span class="p">(</span><span class="n">r_sat</span><span class="p">,</span> <span class="n">r_earth</span><span class="p">,</span> <span class="n">r_sun</span><span class="p">,</span> <span class="n">radius</span><span class="p">,</span> <span class="n">albedo</span><span class="p">,</span> <span class="n">albedo_front</span><span class="p">,</span> <span class="n">area_panels</span><span class="p">):</span>  <span class="c1"># In SI units, takes single values or arrays returns a fractional flux</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Calculate the fractional flux of sunlight reflected from the Sun to the satellite.</span>

<span class="sd">    This function computes the fractional flux of sunlight reflected from the Sun to the satellite, including contributions from the front surface of the satellite&#39;s solar panels.</span>

<span class="sd">    Parameters:</span>
<span class="sd">    ----------</span>
<span class="sd">    r_sat : (n, 3) numpy.ndarray</span>
<span class="sd">        Array of coordinates representing the position of the satellite.</span>
<span class="sd">    r_earth : (n, 3) numpy.ndarray</span>
<span class="sd">        Array of coordinates representing the position of the Earth.</span>
<span class="sd">    r_sun : (n, 3) numpy.ndarray</span>
<span class="sd">        Array of coordinates representing the position of the Sun.</span>
<span class="sd">    radius : float</span>
<span class="sd">        Radius of the satellite in meters.</span>
<span class="sd">    albedo : float</span>
<span class="sd">        Albedo of the satellite&#39;s surface.</span>
<span class="sd">    albedo_front : float</span>
<span class="sd">        Albedo of the front surface of the satellite&#39;s solar panels.</span>
<span class="sd">    area_panels : float</span>
<span class="sd">        Area of the satellite&#39;s solar panels in square meters.</span>

<span class="sd">    Returns:</span>
<span class="sd">    -------</span>
<span class="sd">    dict</span>
<span class="sd">        Dictionary containing the flux contributions from the Sun to the satellite:</span>
<span class="sd">        - &#39;sun_bus&#39;: Fraction of solar flux reflected off the satellite&#39;s bus from the Sun.</span>
<span class="sd">        - &#39;sun_panels&#39;: Fraction of solar flux reflected off the satellite&#39;s panels from the Sun.</span>

<span class="sd">    Notes:</span>
<span class="sd">    ------</span>
<span class="sd">    - The function assumes that the solar panels are always facing the Sun and calculates flux based on the phase angle.</span>
<span class="sd">    - Fraction of solar flux contributions from the front surface of the solar panels are computed.</span>

<span class="sd">    Example:</span>
<span class="sd">    --------</span>
<span class="sd">    &gt;&gt;&gt; r_sat = np.array([[1e7, 1e7, 1e7]])</span>
<span class="sd">    &gt;&gt;&gt; r_earth = np.array([[0, 0, 0]])</span>
<span class="sd">    &gt;&gt;&gt; r_sun = np.array([[1e11, 0, 0]])</span>
<span class="sd">    &gt;&gt;&gt; sun_shine(r_sat, r_earth, r_sun, radius=0.4, albedo=0.20, albedo_front=0.05, area_panels=100)</span>
<span class="sd">    {&#39;sun_bus&#39;: array([...]), &#39;sun_panels&#39;: array([...])}</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="c1"># https://amostech.com/TechnicalPapers/2013/POSTER/COGNION.pdf</span>
    <span class="n">phase_angle</span> <span class="o">=</span> <span class="n">get_angle</span><span class="p">(</span><span class="n">r_sun</span><span class="p">,</span> <span class="n">r_sat</span><span class="p">,</span> <span class="n">r_earth</span><span class="p">)</span>  <span class="c1"># angle from Sun to object to Earth</span>
    <span class="n">r_earth_sat</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">linalg</span><span class="o">.</span><span class="n">norm</span><span class="p">(</span><span class="n">r_sat</span> <span class="o">-</span> <span class="n">r_earth</span><span class="p">,</span> <span class="n">axis</span><span class="o">=-</span><span class="mi">1</span><span class="p">)</span>  <span class="c1"># Earth is the observer.</span>
    <span class="n">flux_front</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">zeros_like</span><span class="p">(</span><span class="n">phase_angle</span><span class="p">)</span>
    <span class="n">flux_front</span><span class="p">[</span><span class="n">phase_angle</span> <span class="o">&lt;</span> <span class="n">np</span><span class="o">.</span><span class="n">pi</span> <span class="o">/</span> <span class="mi">2</span><span class="p">]</span> <span class="o">=</span> <span class="n">albedo_front</span> <span class="o">*</span> <span class="n">area_panels</span> <span class="o">/</span> <span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">pi</span> <span class="o">*</span> <span class="n">r_earth_sat</span><span class="p">[</span><span class="n">phase_angle</span> <span class="o">&lt;</span> <span class="n">np</span><span class="o">.</span><span class="n">pi</span> <span class="o">/</span> <span class="mi">2</span><span class="p">]</span><span class="o">**</span><span class="mi">2</span><span class="p">)</span> <span class="o">*</span> <span class="n">np</span><span class="o">.</span><span class="n">cos</span><span class="p">(</span><span class="n">phase_angle</span><span class="p">[</span><span class="n">phase_angle</span> <span class="o">&lt;</span> <span class="n">np</span><span class="o">.</span><span class="n">pi</span> <span class="o">/</span> <span class="mi">2</span><span class="p">])</span>  <span class="c1"># Fraction of Sun light scattered off front of the solar panels - which are assumed to be always facing the Sun. Angle: Sun - Sat - Observer</span>
    <span class="n">flux_bus</span> <span class="o">=</span> <span class="mi">2</span> <span class="o">/</span> <span class="mi">3</span> <span class="o">*</span> <span class="n">albedo</span> <span class="o">*</span> <span class="n">radius</span><span class="o">**</span><span class="mi">2</span> <span class="o">/</span> <span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">pi</span> <span class="o">*</span> <span class="p">(</span><span class="n">r_earth_sat</span><span class="p">)</span><span class="o">**</span><span class="mi">2</span><span class="p">)</span> <span class="o">*</span> <span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">sin</span><span class="p">(</span><span class="n">phase_angle</span><span class="p">)</span> <span class="o">+</span> <span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">pi</span> <span class="o">-</span> <span class="n">phase_angle</span><span class="p">)</span> <span class="o">*</span> <span class="n">np</span><span class="o">.</span><span class="n">cos</span><span class="p">(</span><span class="n">phase_angle</span><span class="p">))</span>  <span class="c1"># Fraction of light reflected off satellite from Sun</span>
    <span class="k">return</span> <span class="p">{</span><span class="s1">&#39;sun_bus&#39;</span><span class="p">:</span> <span class="n">flux_bus</span><span class="p">,</span> <span class="s1">&#39;sun_panels&#39;</span><span class="p">:</span> <span class="n">flux_front</span><span class="p">}</span></div>


<div class="viewcode-block" id="calc_M_v"><a class="viewcode-back" href="../../api/ssapy.compute.calc_M_v.html#ssapy.compute.calc_M_v">[docs]</a><span class="k">def</span><span class="w"> </span><span class="nf">calc_M_v</span><span class="p">(</span><span class="n">r_sat</span><span class="p">,</span> <span class="n">r_earth</span><span class="p">,</span> <span class="n">r_sun</span><span class="p">,</span> <span class="n">r_moon</span><span class="o">=</span><span class="kc">False</span><span class="p">,</span> <span class="n">radius</span><span class="o">=</span><span class="mf">0.4</span><span class="p">,</span> <span class="n">albedo</span><span class="o">=</span><span class="mf">0.20</span><span class="p">,</span> <span class="n">sun_Mag</span><span class="o">=</span><span class="mf">4.80</span><span class="p">,</span> <span class="n">albedo_earth</span><span class="o">=</span><span class="mf">0.30</span><span class="p">,</span> <span class="n">albedo_moon</span><span class="o">=</span><span class="mf">0.12</span><span class="p">,</span> <span class="n">albedo_back</span><span class="o">=</span><span class="mf">0.50</span><span class="p">,</span> <span class="n">albedo_front</span><span class="o">=</span><span class="mf">0.05</span><span class="p">,</span> <span class="n">area_panels</span><span class="o">=</span><span class="mi">100</span><span class="p">,</span> <span class="n">return_components</span><span class="o">=</span><span class="kc">False</span><span class="p">):</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Calculate the apparent magnitude (M_v) of a satellite due to reflections from the Sun, Earth, and optionally the Moon.</span>

<span class="sd">    This function computes the apparent magnitude of a satellite based on its reflected light from the Sun, Earth, and optionally the Moon. It uses separate functions to calculate the flux contributions from each of these sources and combines them to determine the overall apparent magnitude.</span>

<span class="sd">    Parameters:</span>
<span class="sd">    ----------</span>
<span class="sd">    r_sat : (n, 3) numpy.ndarray</span>
<span class="sd">        Position of the satellite in meters.</span>
<span class="sd">    r_earth : (n, 3) numpy.ndarray</span>
<span class="sd">        Position of the Earth in meters.</span>
<span class="sd">    r_sun : (n, 3) numpy.ndarray</span>
<span class="sd">        Position of the Sun in meters.</span>
<span class="sd">    r_moon : (n, 3) numpy.ndarray or False, optional</span>
<span class="sd">        Position of the Moon in meters. If False, the Moon&#39;s contribution is ignored (default is False).</span>
<span class="sd">    radius : float, optional</span>
<span class="sd">        Radius of the satellite in meters (default is 0.4 m).</span>
<span class="sd">    albedo : float, optional</span>
<span class="sd">        Albedo of the satellite&#39;s surface, representing its reflectivity (default is 0.20).</span>
<span class="sd">    sun_Mag : float, optional</span>
<span class="sd">        Solar magnitude (apparent magnitude of the Sun) used in magnitude calculations (default is 4.80).</span>
<span class="sd">    albedo_earth : float, optional</span>
<span class="sd">        Albedo of the Earth, representing its reflectivity (default is 0.30).</span>
<span class="sd">    albedo_moon : float, optional</span>
<span class="sd">        Albedo of the Moon, representing its reflectivity (default is 0.12).</span>
<span class="sd">    albedo_back : float, optional</span>
<span class="sd">        Albedo of the back surface of the satellite (default is 0.50).</span>
<span class="sd">    albedo_front : float, optional</span>
<span class="sd">        Albedo of the front surface of the satellite (default is 0.05).</span>
<span class="sd">    area_panels : float, optional</span>
<span class="sd">        Area of the satellite&#39;s panels in square meters (default is 100 m^2).</span>
<span class="sd">    return_components : bool, optional</span>
<span class="sd">        If True, returns the magnitude as well as the flux components from the Sun, Earth, and Moon (default is False).</span>

<span class="sd">    Returns:</span>
<span class="sd">    -------</span>
<span class="sd">    float</span>
<span class="sd">        The apparent magnitude (M_v) of the satellite as observed from Earth.</span>

<span class="sd">    dict, optional</span>
<span class="sd">        If `return_components` is True, a dictionary containing the flux components from the Sun, Earth, and Moon.</span>

<span class="sd">    Notes:</span>
<span class="sd">    ------</span>
<span class="sd">    - The function uses separate calculations for flux contributions from the Sun, Earth, and Moon:</span>
<span class="sd">        - `sun_shine` calculates the flux from the Sun.</span>
<span class="sd">        - `earth_shine` calculates the flux from the Earth.</span>
<span class="sd">        - `moon_shine` calculates the flux from the Moon (if applicable).</span>
<span class="sd">    - The apparent magnitude is calculated based on the distances between the satellite, Sun, Earth, and optionally the Moon, as well as their respective albedos and other parameters.</span>

<span class="sd">    Example usage:</span>
<span class="sd">    --------------</span>
<span class="sd">    &gt;&gt;&gt; r_sat = np.array([[1e7, 2e7, 3e7]])</span>
<span class="sd">    &gt;&gt;&gt; r_earth = np.array([1.496e11, 0, 0])</span>
<span class="sd">    &gt;&gt;&gt; r_sun = np.array([0, 0, 0])</span>
<span class="sd">    &gt;&gt;&gt; Mag_v = calc_M_v(r_sat, r_earth, r_sun, return_components=True)</span>
<span class="sd">    &gt;&gt;&gt; Mag_v</span>
<span class="sd">    (15.63, {&#39;sun_bus&#39;: 0.1, &#39;sun_panels&#39;: 0.2, &#39;earth_bus&#39;: 0.05, &#39;earth_panels&#39;: 0.1, &#39;moon_bus&#39;: 0.03, &#39;moon_panels&#39;: 0.07})</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="n">r_sun_sat</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">linalg</span><span class="o">.</span><span class="n">norm</span><span class="p">(</span><span class="n">r_sat</span> <span class="o">-</span> <span class="n">r_sun</span><span class="p">,</span> <span class="n">axis</span><span class="o">=-</span><span class="mi">1</span><span class="p">)</span>
    <span class="n">frac_flux_sun</span> <span class="o">=</span> <span class="p">{</span><span class="s1">&#39;sun_bus&#39;</span><span class="p">:</span> <span class="mi">0</span><span class="p">,</span> <span class="s1">&#39;sun_panels&#39;</span><span class="p">:</span> <span class="mi">0</span><span class="p">}</span>
    <span class="n">frac_flux_earth</span> <span class="o">=</span> <span class="p">{</span><span class="s1">&#39;earth_bus&#39;</span><span class="p">:</span> <span class="mi">0</span><span class="p">,</span> <span class="s1">&#39;earth_panels&#39;</span><span class="p">:</span> <span class="mi">0</span><span class="p">}</span>
    <span class="n">frac_flux_moon</span> <span class="o">=</span> <span class="p">{</span><span class="s1">&#39;moon_bus&#39;</span><span class="p">:</span> <span class="mi">0</span><span class="p">,</span> <span class="s1">&#39;moon_panels&#39;</span><span class="p">:</span> <span class="mi">0</span><span class="p">}</span>
    <span class="n">frac_flux_sun</span> <span class="o">=</span> <span class="n">sun_shine</span><span class="p">(</span><span class="n">r_sat</span><span class="p">,</span> <span class="n">r_earth</span><span class="p">,</span> <span class="n">r_sun</span><span class="p">,</span> <span class="n">radius</span><span class="p">,</span> <span class="n">albedo</span><span class="p">,</span> <span class="n">albedo_front</span><span class="p">,</span> <span class="n">area_panels</span><span class="p">)</span>
    <span class="n">frac_flux_earth</span> <span class="o">=</span> <span class="n">earth_shine</span><span class="p">(</span><span class="n">r_sat</span><span class="p">,</span> <span class="n">r_earth</span><span class="p">,</span> <span class="n">r_sun</span><span class="p">,</span> <span class="n">radius</span><span class="p">,</span> <span class="n">albedo</span><span class="p">,</span> <span class="n">albedo_earth</span><span class="p">,</span> <span class="n">albedo_back</span><span class="p">,</span> <span class="n">area_panels</span><span class="p">)</span>
    <span class="k">if</span> <span class="n">r_moon</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">False</span><span class="p">:</span>
        <span class="n">frac_flux_moon</span> <span class="o">=</span> <span class="n">moon_shine</span><span class="p">(</span><span class="n">r_moon</span><span class="p">,</span> <span class="n">r_sat</span><span class="p">,</span> <span class="n">r_earth</span><span class="p">,</span> <span class="n">r_sun</span><span class="p">,</span> <span class="n">radius</span><span class="p">,</span> <span class="n">albedo</span><span class="p">,</span> <span class="n">albedo_moon</span><span class="p">,</span> <span class="n">albedo_back</span><span class="p">,</span> <span class="n">albedo_front</span><span class="p">,</span> <span class="n">area_panels</span><span class="p">)</span>
    <span class="n">merged_dict</span> <span class="o">=</span> <span class="p">{</span><span class="o">**</span><span class="n">frac_flux_sun</span><span class="p">,</span> <span class="o">**</span><span class="n">frac_flux_earth</span><span class="p">,</span> <span class="o">**</span><span class="n">frac_flux_moon</span><span class="p">}</span>
    <span class="n">total_frac_flux</span> <span class="o">=</span> <span class="nb">sum</span><span class="p">(</span><span class="n">merged_dict</span><span class="o">.</span><span class="n">values</span><span class="p">())</span>
    <span class="n">Mag_v</span> <span class="o">=</span> <span class="p">(</span><span class="mf">2.5</span> <span class="o">*</span> <span class="n">np</span><span class="o">.</span><span class="n">log10</span><span class="p">((</span><span class="n">r_sun_sat</span> <span class="o">/</span> <span class="p">(</span><span class="mi">10</span> <span class="o">*</span> <span class="n">u</span><span class="o">.</span><span class="n">Unit</span><span class="p">(</span><span class="s1">&#39;parsec&#39;</span><span class="p">)</span><span class="o">.</span><span class="n">to</span><span class="p">(</span><span class="n">u</span><span class="o">.</span><span class="n">Unit</span><span class="p">(</span><span class="s1">&#39;m&#39;</span><span class="p">))))</span><span class="o">**</span><span class="mi">2</span><span class="p">)</span> <span class="o">+</span> <span class="n">sun_Mag</span><span class="p">)</span> <span class="o">-</span> <span class="mf">2.5</span> <span class="o">*</span> <span class="n">np</span><span class="o">.</span><span class="n">log10</span><span class="p">(</span><span class="n">total_frac_flux</span><span class="p">)</span>
    <span class="k">if</span> <span class="n">return_components</span><span class="p">:</span>
        <span class="k">return</span> <span class="n">Mag_v</span><span class="p">,</span> <span class="n">merged_dict</span>
    <span class="k">else</span><span class="p">:</span>
        <span class="k">return</span> <span class="n">Mag_v</span></div>


<div class="viewcode-block" id="M_v_lambertian"><a class="viewcode-back" href="../../api/ssapy.compute.M_v_lambertian.html#ssapy.compute.M_v_lambertian">[docs]</a><span class="k">def</span><span class="w"> </span><span class="nf">M_v_lambertian</span><span class="p">(</span><span class="n">r_sat</span><span class="p">,</span> <span class="n">times</span><span class="p">,</span> <span class="n">radius</span><span class="o">=</span><span class="mf">1.0</span><span class="p">,</span> <span class="n">albedo</span><span class="o">=</span><span class="mf">0.20</span><span class="p">,</span> <span class="n">sun_Mag</span><span class="o">=</span><span class="mf">4.80</span><span class="p">,</span> <span class="n">albedo_earth</span><span class="o">=</span><span class="mf">0.30</span><span class="p">,</span> <span class="n">albedo_moon</span><span class="o">=</span><span class="mf">0.12</span><span class="p">,</span> <span class="n">plot</span><span class="o">=</span><span class="kc">False</span><span class="p">):</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Calculate the apparent magnitude (M_v) of a satellite due to reflections from the Sun, Earth, and Moon.</span>

<span class="sd">    This function computes the apparent magnitude of a satellite based on its reflected light from the Sun, Earth, and Moon, using the Lambertian reflection model. It optionally generates plots to visualize the results.</span>

<span class="sd">    Parameters:</span>
<span class="sd">    ----------</span>
<span class="sd">    r_sat : (n, 3) numpy.ndarray</span>
<span class="sd">        Position of the satellite in meters.</span>
<span class="sd">    times : Time or array_like</span>
<span class="sd">        The times corresponding to the satellite and celestial body positions. Used to obtain the positions of the Sun and Moon.</span>
<span class="sd">    radius : float, optional</span>
<span class="sd">        Radius of the satellite in meters (default is 1.0 m).</span>
<span class="sd">    albedo : float, optional</span>
<span class="sd">        Albedo of the satellite&#39;s surface, representing its reflectivity (default is 0.20).</span>
<span class="sd">    sun_Mag : float, optional</span>
<span class="sd">        Solar magnitude (apparent magnitude of the Sun) used in magnitude calculations (default is 4.80).</span>
<span class="sd">    albedo_earth : float, optional</span>
<span class="sd">        Albedo of the Earth, representing its reflectivity (default is 0.30).</span>
<span class="sd">    albedo_moon : float, optional</span>
<span class="sd">        Albedo of the Moon, representing its reflectivity (default is 0.12).</span>
<span class="sd">    plot : bool, optional</span>
<span class="sd">        If True, generates plots to visualize solar phase angle and magnitudes (default is False).</span>

<span class="sd">    Returns:</span>
<span class="sd">    -------</span>
<span class="sd">    numpy.ndarray</span>
<span class="sd">        The apparent magnitude (M_v) of the satellite as observed from Earth, considering reflections from the Sun, Earth, and Moon.</span>

<span class="sd">    Notes:</span>
<span class="sd">    ------</span>
<span class="sd">    - The function uses a Lambertian reflection model to compute the fraction of sunlight reflected by the satellite, Earth, and Moon.</span>
<span class="sd">    - The apparent magnitude is calculated based on the distances between the satellite, Sun, Earth, and Moon, as well as their respective albedos.</span>
<span class="sd">    - The function generates four subplots if `plot` is set to True:</span>
<span class="sd">      1. Solar phase angle of the satellite.</span>
<span class="sd">      2. Solar magnitude (M_v) of the satellite due to the Sun.</span>
<span class="sd">      3. Magnitude (M_v) of the satellite due to reflections from the Earth.</span>
<span class="sd">      4. Magnitude (M_v) of the satellite due to reflections from the Moon.</span>

<span class="sd">    Example usage:</span>
<span class="sd">    --------------</span>
<span class="sd">    &gt;&gt;&gt; r_sat = np.array([[1e7, 2e7, 3e7]])</span>
<span class="sd">    &gt;&gt;&gt; times = Time(&quot;2024-01-01&quot;)</span>
<span class="sd">    &gt;&gt;&gt; M_v = M_v_lambertian(r_sat, times, plot=True)</span>
<span class="sd">    &gt;&gt;&gt; M_v</span>
<span class="sd">    array([15.63])</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="n">pc_to_m</span> <span class="o">=</span> <span class="mf">3.085677581491367e+16</span>
    <span class="n">r_sun</span> <span class="o">=</span> <span class="n">get_body</span><span class="p">(</span><span class="s1">&#39;Sun&#39;</span><span class="p">)</span><span class="o">.</span><span class="n">position</span><span class="p">(</span><span class="n">times</span><span class="p">)</span><span class="o">.</span><span class="n">T</span>
    <span class="n">r_moon</span> <span class="o">=</span> <span class="n">get_body</span><span class="p">(</span><span class="s1">&#39;Moon&#39;</span><span class="p">)</span><span class="o">.</span><span class="n">position</span><span class="p">(</span><span class="n">times</span><span class="p">)</span><span class="o">.</span><span class="n">T</span>
    <span class="n">r_earth</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">zeros_like</span><span class="p">(</span><span class="n">r_sun</span><span class="p">)</span>

    <span class="n">r_sun_sat</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">linalg</span><span class="o">.</span><span class="n">norm</span><span class="p">(</span><span class="n">r_sat</span> <span class="o">-</span> <span class="n">r_sun</span><span class="p">,</span> <span class="n">axis</span><span class="o">=-</span><span class="mi">1</span><span class="p">)</span>
    <span class="n">r_earth_sat</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">linalg</span><span class="o">.</span><span class="n">norm</span><span class="p">(</span><span class="n">r_sat</span><span class="p">,</span> <span class="n">axis</span><span class="o">=-</span><span class="mi">1</span><span class="p">)</span>
    <span class="n">r_moon_sat</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">linalg</span><span class="o">.</span><span class="n">norm</span><span class="p">(</span><span class="n">r_sat</span> <span class="o">-</span> <span class="n">r_moon</span><span class="p">,</span> <span class="n">axis</span><span class="o">=-</span><span class="mi">1</span><span class="p">)</span>

    <span class="n">sun_angle</span> <span class="o">=</span> <span class="n">get_angle</span><span class="p">(</span><span class="n">r_sun</span><span class="p">,</span> <span class="n">r_sat</span><span class="p">,</span> <span class="n">r_earth</span><span class="p">)</span>
    <span class="n">earth_angle</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">pi</span> <span class="o">-</span> <span class="n">sun_angle</span>
    <span class="n">moon_phase_angle</span> <span class="o">=</span> <span class="n">get_angle</span><span class="p">(</span><span class="n">r_sun</span><span class="p">,</span> <span class="n">r_moon</span><span class="p">,</span> <span class="n">r_sat</span><span class="p">)</span>  <span class="c1"># Phase of the moon as viewed from the sat.</span>
    <span class="n">moon_to_earth_angle</span> <span class="o">=</span> <span class="n">get_angle</span><span class="p">(</span><span class="n">r_moon</span><span class="p">,</span> <span class="n">r_sat</span><span class="p">,</span> <span class="n">r_earth</span><span class="p">)</span>

    <span class="n">flux_moon_to_sat</span> <span class="o">=</span> <span class="mi">2</span> <span class="o">/</span> <span class="mi">3</span> <span class="o">*</span> <span class="n">albedo_moon</span> <span class="o">*</span> <span class="n">MOON_RADIUS</span><span class="o">**</span><span class="mi">2</span> <span class="o">/</span> <span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">pi</span> <span class="o">*</span> <span class="p">(</span><span class="n">r_moon_sat</span><span class="p">)</span><span class="o">**</span><span class="mi">2</span><span class="p">)</span> <span class="o">*</span> <span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">sin</span><span class="p">(</span><span class="n">moon_phase_angle</span><span class="p">)</span> <span class="o">+</span> <span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">pi</span> <span class="o">-</span> <span class="n">moon_phase_angle</span><span class="p">)</span> <span class="o">*</span> <span class="n">np</span><span class="o">.</span><span class="n">cos</span><span class="p">(</span><span class="n">moon_phase_angle</span><span class="p">))</span>  <span class="c1"># Fraction of sunlight reflected from the Moon to satellite</span>
    <span class="n">flux_earth_to_sat</span> <span class="o">=</span> <span class="mi">2</span> <span class="o">/</span> <span class="mi">3</span> <span class="o">*</span> <span class="n">albedo_earth</span> <span class="o">*</span> <span class="n">EARTH_RADIUS</span><span class="o">**</span><span class="mi">2</span> <span class="o">/</span> <span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">pi</span> <span class="o">*</span> <span class="p">(</span><span class="n">r_earth_sat</span><span class="p">)</span><span class="o">**</span><span class="mi">2</span><span class="p">)</span> <span class="o">*</span> <span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">sin</span><span class="p">(</span><span class="n">earth_angle</span><span class="p">)</span> <span class="o">+</span> <span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">pi</span> <span class="o">-</span> <span class="n">earth_angle</span><span class="p">)</span> <span class="o">*</span> <span class="n">np</span><span class="o">.</span><span class="n">cos</span><span class="p">(</span><span class="n">earth_angle</span><span class="p">))</span>  <span class="c1"># Fraction of sunlight reflected from the Earth to satellite</span>

    <span class="n">frac_flux_sun</span> <span class="o">=</span> <span class="mi">2</span> <span class="o">/</span> <span class="mi">3</span> <span class="o">*</span> <span class="n">albedo</span> <span class="o">*</span> <span class="n">radius</span><span class="o">**</span><span class="mi">2</span> <span class="o">/</span> <span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">pi</span> <span class="o">*</span> <span class="p">(</span><span class="n">r_earth_sat</span><span class="p">)</span><span class="o">**</span><span class="mi">2</span><span class="p">)</span> <span class="o">*</span> <span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">sin</span><span class="p">(</span><span class="n">sun_angle</span><span class="p">)</span> <span class="o">+</span> <span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">pi</span> <span class="o">-</span> <span class="n">sun_angle</span><span class="p">)</span> <span class="o">*</span> <span class="n">np</span><span class="o">.</span><span class="n">cos</span><span class="p">(</span><span class="n">sun_angle</span><span class="p">))</span>  <span class="c1"># Fraction of light reflected off satellite from Sun</span>
    <span class="n">frac_flux_earth</span> <span class="o">=</span> <span class="mi">2</span> <span class="o">/</span> <span class="mi">3</span> <span class="o">*</span> <span class="n">albedo</span> <span class="o">*</span> <span class="n">radius</span><span class="o">**</span><span class="mi">2</span> <span class="o">/</span> <span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">pi</span> <span class="o">*</span> <span class="n">r_earth_sat</span><span class="o">**</span><span class="mi">2</span><span class="p">)</span> <span class="o">*</span> <span class="n">flux_earth_to_sat</span>
    <span class="n">frac_flux_moon</span> <span class="o">=</span> <span class="mi">2</span> <span class="o">/</span> <span class="mi">3</span> <span class="o">*</span> <span class="n">albedo</span> <span class="o">*</span> <span class="n">radius</span><span class="o">**</span><span class="mi">2</span> <span class="o">/</span> <span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">pi</span> <span class="o">*</span> <span class="n">r_earth_sat</span><span class="o">**</span><span class="mi">2</span><span class="p">)</span> <span class="o">*</span> <span class="n">flux_moon_to_sat</span>
    <span class="n">Mag_v</span> <span class="o">=</span> <span class="p">(</span><span class="mf">2.5</span> <span class="o">*</span> <span class="n">np</span><span class="o">.</span><span class="n">log10</span><span class="p">((</span><span class="n">r_sun_sat</span> <span class="o">/</span> <span class="p">(</span><span class="mi">10</span> <span class="o">*</span> <span class="n">pc_to_m</span><span class="p">))</span><span class="o">**</span><span class="mi">2</span><span class="p">)</span> <span class="o">+</span> <span class="n">sun_Mag</span><span class="p">)</span> <span class="o">-</span> <span class="mf">2.5</span> <span class="o">*</span> <span class="n">np</span><span class="o">.</span><span class="n">log10</span><span class="p">(</span><span class="n">frac_flux_sun</span> <span class="o">+</span> <span class="n">frac_flux_earth</span> <span class="o">+</span> <span class="n">frac_flux_moon</span><span class="p">)</span>
    <span class="k">if</span> <span class="n">plot</span><span class="p">:</span>
        <span class="kn">import</span><span class="w"> </span><span class="nn">matplotlib.pyplot</span><span class="w"> </span><span class="k">as</span><span class="w"> </span><span class="nn">plt</span>
        <span class="n">sun_scale</span> <span class="o">=</span> <span class="mf">149597870700.0</span> <span class="o">*</span> <span class="p">(</span><span class="n">RGEO</span> <span class="o">/</span> <span class="n">np</span><span class="o">.</span><span class="n">max</span><span class="p">(</span><span class="n">r_earth_sat</span><span class="p">)</span> <span class="p">)</span> <span class="o">*</span> <span class="mf">0.75</span>
        <span class="n">color_map</span> <span class="o">=</span><span class="s1">&#39;inferno_r&#39;</span>
        <span class="n">fig</span> <span class="o">=</span> <span class="n">plt</span><span class="o">.</span><span class="n">figure</span><span class="p">(</span><span class="n">figsize</span><span class="o">=</span><span class="p">(</span><span class="mi">18</span><span class="p">,</span> <span class="mi">4</span><span class="p">))</span>
        <span class="n">ax</span> <span class="o">=</span> <span class="n">fig</span><span class="o">.</span><span class="n">add_subplot</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span> <span class="mi">4</span><span class="p">,</span> <span class="mi">1</span><span class="p">)</span>
        <span class="n">ax</span><span class="o">.</span><span class="n">scatter</span><span class="p">(</span><span class="n">r_earth</span><span class="p">[:,</span> <span class="mi">0</span><span class="p">],</span> <span class="n">r_earth</span><span class="p">[:,</span> <span class="mi">1</span><span class="p">],</span> <span class="n">c</span><span class="o">=</span><span class="s1">&#39;Blue&#39;</span><span class="p">,</span> <span class="n">s</span><span class="o">=</span><span class="mi">10</span><span class="p">)</span>
        <span class="n">scatter</span> <span class="o">=</span> <span class="n">ax</span><span class="o">.</span><span class="n">scatter</span><span class="p">(</span><span class="n">r_sat</span><span class="p">[:,</span> <span class="mi">0</span><span class="p">]</span> <span class="o">/</span> <span class="n">RGEO</span><span class="p">,</span> <span class="n">r_sat</span><span class="p">[:,</span> <span class="mi">1</span><span class="p">]</span> <span class="o">/</span> <span class="n">RGEO</span><span class="p">,</span> <span class="n">c</span><span class="o">=</span><span class="n">sun_angle</span><span class="p">,</span> <span class="n">cmap</span><span class="o">=</span><span class="n">color_map</span><span class="p">)</span>
        <span class="n">colorbar</span> <span class="o">=</span> <span class="n">plt</span><span class="o">.</span><span class="n">colorbar</span><span class="p">(</span><span class="n">scatter</span><span class="p">)</span>
        <span class="n">ax</span><span class="o">.</span><span class="n">scatter</span><span class="p">(</span><span class="n">r_sun</span><span class="p">[:,</span> <span class="mi">0</span><span class="p">]</span> <span class="o">/</span> <span class="n">sun_scale</span><span class="p">,</span> <span class="n">r_sun</span><span class="p">[:,</span> <span class="mi">1</span><span class="p">]</span> <span class="o">/</span> <span class="n">sun_scale</span><span class="p">,</span> <span class="n">c</span><span class="o">=</span><span class="n">plt</span><span class="o">.</span><span class="n">cm</span><span class="o">.</span><span class="n">Oranges</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">linspace</span><span class="p">(</span><span class="mf">0.25</span><span class="p">,</span> <span class="mf">0.75</span><span class="p">,</span> <span class="nb">len</span><span class="p">(</span><span class="n">r_sat</span><span class="p">[:,</span> <span class="mi">0</span><span class="p">]))),</span> <span class="n">s</span><span class="o">=</span><span class="mi">10</span><span class="p">)</span>
        <span class="n">ax</span><span class="o">.</span><span class="n">set_title</span><span class="p">(</span><span class="s1">&#39;Solar Phase&#39;</span><span class="p">)</span>
        <span class="n">ax</span><span class="o">.</span><span class="n">set_xlabel</span><span class="p">(</span><span class="s1">&#39;X [GEO]&#39;</span><span class="p">)</span>
        <span class="n">ax</span><span class="o">.</span><span class="n">set_ylabel</span><span class="p">(</span><span class="s1">&#39;Y [GEO]&#39;</span><span class="p">)</span>
        <span class="n">ax</span><span class="o">.</span><span class="n">axis</span><span class="p">(</span><span class="s1">&#39;equal&#39;</span><span class="p">)</span>

        <span class="n">ax</span> <span class="o">=</span> <span class="n">fig</span><span class="o">.</span><span class="n">add_subplot</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span> <span class="mi">4</span><span class="p">,</span> <span class="mi">2</span><span class="p">)</span>
        <span class="n">ax</span><span class="o">.</span><span class="n">scatter</span><span class="p">(</span><span class="n">r_earth</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span> <span class="n">r_earth</span><span class="p">[</span><span class="mi">1</span><span class="p">],</span> <span class="n">c</span><span class="o">=</span><span class="s1">&#39;Blue&#39;</span><span class="p">,</span> <span class="n">s</span><span class="o">=</span><span class="mi">10</span><span class="p">)</span>
        <span class="n">scatter</span> <span class="o">=</span> <span class="n">ax</span><span class="o">.</span><span class="n">scatter</span><span class="p">(</span><span class="n">r_sat</span><span class="p">[:,</span> <span class="mi">0</span><span class="p">]</span> <span class="o">/</span> <span class="n">RGEO</span><span class="p">,</span> <span class="n">r_sat</span><span class="p">[:,</span> <span class="mi">1</span><span class="p">]</span> <span class="o">/</span> <span class="n">RGEO</span><span class="p">,</span> <span class="n">c</span><span class="o">=</span><span class="p">(</span><span class="mf">2.5</span> <span class="o">*</span> <span class="n">np</span><span class="o">.</span><span class="n">log10</span><span class="p">((</span><span class="n">r_sun_sat</span> <span class="o">/</span> <span class="p">(</span><span class="mi">10</span> <span class="o">*</span> <span class="n">pc_to_m</span><span class="p">))</span><span class="o">**</span><span class="mi">2</span><span class="p">)</span> <span class="o">+</span> <span class="n">sun_Mag</span><span class="p">)</span> <span class="o">-</span> <span class="mf">2.5</span> <span class="o">*</span> <span class="n">np</span><span class="o">.</span><span class="n">log10</span><span class="p">(</span><span class="n">frac_flux_sun</span><span class="p">),</span> <span class="n">cmap</span><span class="o">=</span><span class="n">color_map</span><span class="p">)</span>
        <span class="n">colorbar</span> <span class="o">=</span> <span class="n">plt</span><span class="o">.</span><span class="n">colorbar</span><span class="p">(</span><span class="n">scatter</span><span class="p">)</span>
        <span class="n">ax</span><span class="o">.</span><span class="n">scatter</span><span class="p">(</span><span class="n">r_sun</span><span class="p">[:,</span> <span class="mi">0</span><span class="p">]</span> <span class="o">/</span> <span class="n">sun_scale</span><span class="p">,</span> <span class="n">r_sun</span><span class="p">[:,</span> <span class="mi">1</span><span class="p">]</span> <span class="o">/</span> <span class="n">sun_scale</span><span class="p">,</span> <span class="n">c</span><span class="o">=</span><span class="n">plt</span><span class="o">.</span><span class="n">cm</span><span class="o">.</span><span class="n">Oranges</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">linspace</span><span class="p">(</span><span class="mf">0.25</span><span class="p">,</span> <span class="mf">0.75</span><span class="p">,</span> <span class="nb">len</span><span class="p">(</span><span class="n">r_sat</span><span class="p">[:,</span> <span class="mi">0</span><span class="p">]))),</span> <span class="n">s</span><span class="o">=</span><span class="mi">10</span><span class="p">)</span>
        <span class="n">ax</span><span class="o">.</span><span class="n">set_title</span><span class="p">(</span><span class="s1">&#39;Solar M_v&#39;</span><span class="p">)</span>
        <span class="n">ax</span><span class="o">.</span><span class="n">axis</span><span class="p">(</span><span class="s1">&#39;equal&#39;</span><span class="p">)</span>

        <span class="n">ax</span> <span class="o">=</span> <span class="n">fig</span><span class="o">.</span><span class="n">add_subplot</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span> <span class="mi">4</span><span class="p">,</span> <span class="mi">3</span><span class="p">)</span>
        <span class="n">ax</span><span class="o">.</span><span class="n">scatter</span><span class="p">(</span><span class="n">r_earth</span><span class="p">[:,</span> <span class="mi">0</span><span class="p">],</span> <span class="n">r_earth</span><span class="p">[:,</span> <span class="mi">1</span><span class="p">],</span> <span class="n">c</span><span class="o">=</span><span class="s1">&#39;Blue&#39;</span><span class="p">,</span> <span class="n">s</span><span class="o">=</span><span class="mi">10</span><span class="p">)</span>
        <span class="n">scatter</span> <span class="o">=</span> <span class="n">ax</span><span class="o">.</span><span class="n">scatter</span><span class="p">(</span><span class="n">r_sat</span><span class="p">[:,</span> <span class="mi">0</span><span class="p">]</span> <span class="o">/</span> <span class="n">RGEO</span><span class="p">,</span> <span class="n">r_sat</span><span class="p">[:,</span> <span class="mi">1</span><span class="p">]</span> <span class="o">/</span> <span class="n">RGEO</span><span class="p">,</span> <span class="n">c</span><span class="o">=</span><span class="p">(</span><span class="mf">2.5</span> <span class="o">*</span> <span class="n">np</span><span class="o">.</span><span class="n">log10</span><span class="p">((</span><span class="n">r_sun_sat</span> <span class="o">/</span> <span class="p">(</span><span class="mi">10</span> <span class="o">*</span> <span class="n">pc_to_m</span><span class="p">))</span><span class="o">**</span><span class="mi">2</span><span class="p">)</span> <span class="o">+</span> <span class="n">sun_Mag</span><span class="p">)</span> <span class="o">-</span> <span class="mf">2.5</span> <span class="o">*</span> <span class="n">np</span><span class="o">.</span><span class="n">log10</span><span class="p">(</span><span class="n">frac_flux_earth</span><span class="p">),</span> <span class="n">cmap</span><span class="o">=</span><span class="n">color_map</span><span class="p">)</span>
        <span class="n">colorbar</span> <span class="o">=</span> <span class="n">plt</span><span class="o">.</span><span class="n">colorbar</span><span class="p">(</span><span class="n">scatter</span><span class="p">)</span>
        <span class="n">ax</span><span class="o">.</span><span class="n">scatter</span><span class="p">(</span><span class="n">r_sun</span><span class="p">[:,</span> <span class="mi">0</span><span class="p">]</span> <span class="o">/</span> <span class="n">sun_scale</span><span class="p">,</span> <span class="n">r_sun</span><span class="p">[:,</span> <span class="mi">1</span><span class="p">]</span> <span class="o">/</span> <span class="n">sun_scale</span><span class="p">,</span> <span class="n">c</span><span class="o">=</span><span class="n">plt</span><span class="o">.</span><span class="n">cm</span><span class="o">.</span><span class="n">Oranges</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">linspace</span><span class="p">(</span><span class="mf">0.25</span><span class="p">,</span> <span class="mf">0.75</span><span class="p">,</span> <span class="nb">len</span><span class="p">(</span><span class="n">r_sat</span><span class="p">[:,</span> <span class="mi">0</span><span class="p">]))),</span> <span class="n">s</span><span class="o">=</span><span class="mi">10</span><span class="p">)</span>

        <span class="n">ax</span><span class="o">.</span><span class="n">set_title</span><span class="p">(</span><span class="s1">&#39;Earth M_v&#39;</span><span class="p">)</span>
        <span class="n">ax</span><span class="o">.</span><span class="n">axis</span><span class="p">(</span><span class="s1">&#39;equal&#39;</span><span class="p">)</span>

        <span class="n">ax</span> <span class="o">=</span> <span class="n">fig</span><span class="o">.</span><span class="n">add_subplot</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span> <span class="mi">4</span><span class="p">,</span> <span class="mi">4</span><span class="p">)</span>
        <span class="n">ax</span><span class="o">.</span><span class="n">scatter</span><span class="p">(</span><span class="n">r_earth</span><span class="p">[:,</span> <span class="mi">0</span><span class="p">],</span> <span class="n">r_earth</span><span class="p">[:,</span> <span class="mi">1</span><span class="p">],</span> <span class="n">c</span><span class="o">=</span><span class="s1">&#39;Blue&#39;</span><span class="p">,</span> <span class="n">s</span><span class="o">=</span><span class="mi">10</span><span class="p">)</span>
        <span class="n">scatter</span> <span class="o">=</span> <span class="n">ax</span><span class="o">.</span><span class="n">scatter</span><span class="p">(</span><span class="n">r_sat</span><span class="p">[:,</span> <span class="mi">0</span><span class="p">]</span> <span class="o">/</span> <span class="n">RGEO</span><span class="p">,</span> <span class="n">r_sat</span><span class="p">[:,</span> <span class="mi">1</span><span class="p">]</span> <span class="o">/</span> <span class="n">RGEO</span><span class="p">,</span> <span class="n">c</span><span class="o">=</span><span class="p">(</span><span class="mf">2.5</span> <span class="o">*</span> <span class="n">np</span><span class="o">.</span><span class="n">log10</span><span class="p">((</span><span class="n">r_sun_sat</span> <span class="o">/</span> <span class="p">(</span><span class="mi">10</span> <span class="o">*</span> <span class="n">pc_to_m</span><span class="p">))</span><span class="o">**</span><span class="mi">2</span><span class="p">)</span> <span class="o">+</span> <span class="n">sun_Mag</span><span class="p">)</span> <span class="o">-</span> <span class="mf">2.5</span> <span class="o">*</span> <span class="n">np</span><span class="o">.</span><span class="n">log10</span><span class="p">(</span><span class="n">frac_flux_moon</span><span class="p">),</span> <span class="n">cmap</span><span class="o">=</span><span class="n">color_map</span><span class="p">)</span>
        <span class="n">ax</span><span class="o">.</span><span class="n">scatter</span><span class="p">(</span><span class="n">r_moon</span><span class="p">[:,</span> <span class="mi">0</span><span class="p">]</span> <span class="o">/</span> <span class="n">RGEO</span><span class="p">,</span> <span class="n">r_moon</span><span class="p">[:,</span> <span class="mi">1</span><span class="p">]</span> <span class="o">/</span> <span class="n">RGEO</span><span class="p">,</span> <span class="n">c</span><span class="o">=</span><span class="n">plt</span><span class="o">.</span><span class="n">cm</span><span class="o">.</span><span class="n">Greys</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">linspace</span><span class="p">(</span><span class="mf">0.5</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="nb">len</span><span class="p">(</span><span class="n">r_sat</span><span class="p">[:,</span> <span class="mi">0</span><span class="p">]))),</span> <span class="n">s</span><span class="o">=</span><span class="mi">5</span><span class="p">)</span>

        <span class="n">colorbar</span> <span class="o">=</span> <span class="n">plt</span><span class="o">.</span><span class="n">colorbar</span><span class="p">(</span><span class="n">scatter</span><span class="p">)</span>
        <span class="n">ax</span><span class="o">.</span><span class="n">set_title</span><span class="p">(</span><span class="s1">&#39;Lunar M_v&#39;</span><span class="p">)</span>
        <span class="n">ax</span><span class="o">.</span><span class="n">axis</span><span class="p">(</span><span class="s1">&#39;equal&#39;</span><span class="p">)</span>
        <span class="n">plt</span><span class="o">.</span><span class="n">show</span><span class="p">()</span>

    <span class="k">return</span> <span class="n">Mag_v</span></div>


<div class="viewcode-block" id="calc_gamma"><a class="viewcode-back" href="../../api/ssapy.compute.calc_gamma.html#ssapy.compute.calc_gamma">[docs]</a><span class="k">def</span><span class="w"> </span><span class="nf">calc_gamma</span><span class="p">(</span><span class="n">r</span><span class="p">,</span> <span class="n">t</span><span class="p">):</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Calculate the gamma angle between position and velocity vectors in the ITRF frame.</span>

<span class="sd">    Parameters:</span>
<span class="sd">    r (numpy.ndarray): The position vectors in the GCRF frame, shaped (n, 3), where n is the number of vectors.</span>
<span class="sd">    t (numpy.ndarray or astropy.time.Time): The times corresponding to the position vectors. Can be an array of GPS seconds or an Astropy Time object.</span>

<span class="sd">    Returns:</span>
<span class="sd">    numpy.ndarray: An array of gamma angles in degrees between the position and velocity vectors for each time point.</span>

<span class="sd">    Notes:</span>
<span class="sd">    - This function first converts the given position vectors from the GCRF frame to the ITRF frame.</span>
<span class="sd">    - It then calculates the angle between the position and velocity vectors at each time point in the ITRF frame.</span>
<span class="sd">    - If the input time array is an Astropy Time object, it converts it to GPS time before processing.</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="n">r_itrf</span><span class="p">,</span> <span class="n">v_itrf</span> <span class="o">=</span> <span class="n">gcrf_to_itrf</span><span class="p">(</span><span class="n">r</span><span class="p">,</span> <span class="n">t</span><span class="p">,</span> <span class="n">v</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span>
    <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">t</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span> <span class="n">Time</span><span class="p">):</span>
        <span class="n">t</span> <span class="o">=</span> <span class="n">t</span><span class="o">.</span><span class="n">gps</span>
    <span class="n">gamma</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">degrees</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">apply_along_axis</span><span class="p">(</span><span class="k">lambda</span> <span class="n">x</span><span class="p">:</span> <span class="n">angle_between_vectors</span><span class="p">(</span><span class="n">x</span><span class="p">[:</span><span class="mi">3</span><span class="p">],</span> <span class="n">x</span><span class="p">[</span><span class="mi">3</span><span class="p">:]),</span> <span class="mi">1</span><span class="p">,</span> <span class="n">np</span><span class="o">.</span><span class="n">concatenate</span><span class="p">((</span><span class="n">r_itrf</span><span class="p">,</span> <span class="n">v_itrf</span><span class="p">),</span> <span class="n">axis</span><span class="o">=</span><span class="mi">1</span><span class="p">)))</span> <span class="o">-</span> <span class="mi">90</span>
    <span class="k">return</span> <span class="n">gamma</span></div>



<div class="viewcode-block" id="moon_normal_vector"><a class="viewcode-back" href="../../api/ssapy.compute.moon_normal_vector.html#ssapy.compute.moon_normal_vector">[docs]</a><span class="k">def</span><span class="w"> </span><span class="nf">moon_normal_vector</span><span class="p">(</span><span class="n">t</span><span class="p">):</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Calculate the normal vector to the Moon&#39;s orbital plane at a given time.</span>

<span class="sd">    This function computes the normal vector to the Moon&#39;s orbital plane by taking the cross product of the Moon&#39;s position vectors at two different times: the given time `t` and one week later. The resulting vector is normalized to provide the direction of the orbital plane&#39;s normal.</span>

<span class="sd">    Parameters:</span>
<span class="sd">    ----------</span>
<span class="sd">    t : Time</span>
<span class="sd">        The time at which to calculate the normal vector to the Moon&#39;s orbital plane.</span>

<span class="sd">    Returns:</span>
<span class="sd">    -------</span>
<span class="sd">    numpy.ndarray</span>
<span class="sd">        A 3-element array representing the normal vector to the Moon&#39;s orbital plane at the given time. The vector is normalized to have a unit length.</span>

<span class="sd">    Notes:</span>
<span class="sd">    ------</span>
<span class="sd">    - The function assumes a circular orbit for the Moon and uses a time step of one week (604800 seconds) to calculate the normal vector.</span>
<span class="sd">    - The normal vector is perpendicular to the plane defined by the Moon&#39;s position vectors at the given time and one week later.</span>

<span class="sd">    Example usage:</span>
<span class="sd">    --------------</span>
<span class="sd">    &gt;&gt;&gt; t = Time(&quot;2024-01-01&quot;)</span>
<span class="sd">    &gt;&gt;&gt; normal_vector = moon_normal_vector(t)</span>
<span class="sd">    &gt;&gt;&gt; normal_vector</span>
<span class="sd">    array([-0.093,  0.014,  0.995])</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="n">r</span> <span class="o">=</span> <span class="n">get_body</span><span class="p">(</span><span class="s2">&quot;moon&quot;</span><span class="p">)</span><span class="o">.</span><span class="n">position</span><span class="p">(</span><span class="n">t</span><span class="p">)</span><span class="o">.</span><span class="n">T</span>
    <span class="n">r_random</span> <span class="o">=</span> <span class="n">get_body</span><span class="p">(</span><span class="s2">&quot;moon&quot;</span><span class="p">)</span><span class="o">.</span><span class="n">position</span><span class="p">(</span><span class="n">t</span><span class="o">.</span><span class="n">gps</span> <span class="o">+</span> <span class="mi">604800</span><span class="p">)</span><span class="o">.</span><span class="n">T</span>
    <span class="k">return</span> <span class="n">np</span><span class="o">.</span><span class="n">cross</span><span class="p">(</span><span class="n">r</span><span class="p">,</span> <span class="n">r_random</span><span class="p">)</span> <span class="o">/</span> <span class="n">np</span><span class="o">.</span><span class="n">linalg</span><span class="o">.</span><span class="n">norm</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">cross</span><span class="p">(</span><span class="n">r</span><span class="p">,</span> <span class="n">r_random</span><span class="p">))</span></div>


<div class="viewcode-block" id="lunar_lagrange_points"><a class="viewcode-back" href="../../api/ssapy.compute.lunar_lagrange_points.html#ssapy.compute.lunar_lagrange_points">[docs]</a><span class="k">def</span><span class="w"> </span><span class="nf">lunar_lagrange_points</span><span class="p">(</span><span class="n">t</span><span class="p">):</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Calculate the positions of the lunar Lagrange points in the GCRF frame at a given time.</span>

<span class="sd">    This function computes the positions of the five Lagrange points (L1, L2, L3, L4, and L5) in the Earth-Moon system at a specific time `t`. It considers the positions of the Earth and Moon and uses the orbital period of the Moon to find the Lagrange points.</span>

<span class="sd">    Parameters:</span>
<span class="sd">    ----------</span>
<span class="sd">    t : Time</span>
<span class="sd">        The time at which to calculate the Lagrange points. The position of the Moon at this time is used to compute the Lagrange points.</span>

<span class="sd">    Returns:</span>
<span class="sd">    -------</span>
<span class="sd">    dict</span>
<span class="sd">        A dictionary containing the coordinates of the five Lagrange points:</span>
<span class="sd">        - &quot;L1&quot;: Position of the first Lagrange point between the Earth and the Moon.</span>
<span class="sd">        - &quot;L2&quot;: Position of the second Lagrange point beyond the Moon.</span>
<span class="sd">        - &quot;L3&quot;: Position of the third Lagrange point directly opposite the Moon, relative to the Earth.</span>
<span class="sd">        - &quot;L4&quot;: Position of the fourth Lagrange point, calculated as the Moon&#39;s position offset by one-sixth of the lunar period.</span>
<span class="sd">        - &quot;L5&quot;: Position of the fifth Lagrange point, calculated as the Moon&#39;s position offset by negative one-sixth of the lunar period.</span>

<span class="sd">    Notes:</span>
<span class="sd">    ------</span>
<span class="sd">    - The function assumes a circular orbit for the Moon.</span>
<span class="sd">    - The lunar period used is approximately 2.36 million seconds.</span>
<span class="sd">    - The gravitational parameters of the Earth and Moon are denoted as `EARTH_MU` and `MOON_MU`, respectively.</span>

<span class="sd">    Example usage:</span>
<span class="sd">    --------------</span>
<span class="sd">    &gt;&gt;&gt; t = Time(&quot;2024-01-01&quot;)</span>
<span class="sd">    &gt;&gt;&gt; lagrange_points = lunar_lagrange_points(t)</span>
<span class="sd">    &gt;&gt;&gt; lagrange_points[&quot;L1&quot;]</span>
<span class="sd">    array([1.02e6, 0.0, 0.0])</span>
<span class="sd">    &gt;&gt;&gt; lagrange_points[&quot;L4&quot;]</span>
<span class="sd">    array([1.5e6, 1.5e6, 0.0])</span>
<span class="sd">    &quot;&quot;&quot;</span>

    <span class="n">r</span> <span class="o">=</span> <span class="n">get_body</span><span class="p">(</span><span class="s2">&quot;moon&quot;</span><span class="p">)</span><span class="o">.</span><span class="n">position</span><span class="p">(</span><span class="n">t</span><span class="p">)</span><span class="o">.</span><span class="n">T</span>
    <span class="n">d</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">linalg</span><span class="o">.</span><span class="n">norm</span><span class="p">(</span><span class="n">r</span><span class="p">)</span>  <span class="c1"># Distance between Earth and Moon</span>
    <span class="n">unit_vector_moon</span> <span class="o">=</span> <span class="n">r</span> <span class="o">/</span> <span class="n">np</span><span class="o">.</span><span class="n">linalg</span><span class="o">.</span><span class="n">norm</span><span class="p">(</span><span class="n">r</span><span class="p">,</span> <span class="n">axis</span><span class="o">=-</span><span class="mi">1</span><span class="p">)</span>
    <span class="c1"># plane_vector = np.cross(r, r_random)</span>
    <span class="n">lunar_period_seconds</span> <span class="o">=</span> <span class="mf">2.3605915968e6</span>

    <span class="c1"># Coefficients of the quadratic equation</span>
    <span class="n">a</span> <span class="o">=</span> <span class="n">EARTH_MU</span> <span class="o">-</span> <span class="n">MOON_MU</span>
    <span class="n">b</span> <span class="o">=</span> <span class="mi">2</span> <span class="o">*</span> <span class="n">MOON_MU</span> <span class="o">*</span> <span class="n">d</span>
    <span class="n">c</span> <span class="o">=</span> <span class="o">-</span><span class="n">MOON_MU</span> <span class="o">*</span> <span class="n">d</span><span class="o">**</span><span class="mi">2</span>

    <span class="c1"># Solve the quadratic equation</span>
    <span class="n">discriminant</span> <span class="o">=</span> <span class="n">b</span><span class="o">**</span><span class="mi">2</span> <span class="o">-</span> <span class="mi">4</span><span class="o">*</span><span class="n">a</span><span class="o">*</span><span class="n">c</span>

    <span class="k">if</span> <span class="n">discriminant</span> <span class="o">&gt;=</span> <span class="mi">0</span><span class="p">:</span>
        <span class="n">L1_from_moon</span> <span class="o">=</span> <span class="p">(</span><span class="o">-</span><span class="n">b</span> <span class="o">-</span> <span class="n">np</span><span class="o">.</span><span class="n">sqrt</span><span class="p">(</span><span class="n">discriminant</span><span class="p">))</span> <span class="o">/</span> <span class="p">(</span><span class="mi">2</span><span class="o">*</span><span class="n">a</span><span class="p">)</span> <span class="o">*</span> <span class="n">unit_vector_moon</span>
        <span class="n">L2_from_moon</span> <span class="o">=</span> <span class="p">(</span><span class="o">-</span><span class="n">b</span> <span class="o">+</span> <span class="n">np</span><span class="o">.</span><span class="n">sqrt</span><span class="p">(</span><span class="n">discriminant</span><span class="p">))</span> <span class="o">/</span> <span class="p">(</span><span class="mi">2</span><span class="o">*</span><span class="n">a</span><span class="p">)</span> <span class="o">*</span> <span class="n">unit_vector_moon</span>
    <span class="k">else</span><span class="p">:</span>
        <span class="nb">print</span><span class="p">(</span><span class="s2">&quot;Discriminate is less than 0! THAT&#39;S WEIRD FIX IT.&quot;</span><span class="p">)</span>
        <span class="n">L1_from_moon</span> <span class="o">=</span> <span class="kc">None</span>
        <span class="n">L2_from_moon</span> <span class="o">=</span> <span class="kc">None</span>

    <span class="k">return</span> <span class="p">{</span>
        <span class="s2">&quot;L1&quot;</span><span class="p">:</span> <span class="n">L1_from_moon</span> <span class="o">+</span> <span class="n">r</span><span class="p">,</span>
        <span class="s2">&quot;L2&quot;</span><span class="p">:</span> <span class="n">L2_from_moon</span> <span class="o">+</span> <span class="n">r</span><span class="p">,</span>
        <span class="s2">&quot;L3&quot;</span><span class="p">:</span> <span class="o">-</span><span class="n">r</span><span class="p">,</span>
        <span class="s2">&quot;L4&quot;</span><span class="p">:</span> <span class="n">get_body</span><span class="p">(</span><span class="s2">&quot;moon&quot;</span><span class="p">)</span><span class="o">.</span><span class="n">position</span><span class="p">(</span><span class="n">t</span><span class="o">.</span><span class="n">gps</span> <span class="o">+</span> <span class="n">lunar_period_seconds</span> <span class="o">/</span> <span class="mi">6</span><span class="p">)</span><span class="o">.</span><span class="n">T</span><span class="p">,</span>
        <span class="s2">&quot;L5&quot;</span><span class="p">:</span> <span class="n">get_body</span><span class="p">(</span><span class="s2">&quot;moon&quot;</span><span class="p">)</span><span class="o">.</span><span class="n">position</span><span class="p">(</span><span class="n">t</span><span class="o">.</span><span class="n">gps</span> <span class="o">-</span> <span class="n">lunar_period_seconds</span> <span class="o">/</span> <span class="mi">6</span><span class="p">)</span><span class="o">.</span><span class="n">T</span>
    <span class="p">}</span></div>


<div class="viewcode-block" id="lunar_lagrange_points_circular"><a class="viewcode-back" href="../../api/ssapy.compute.lunar_lagrange_points_circular.html#ssapy.compute.lunar_lagrange_points_circular">[docs]</a><span class="k">def</span><span class="w"> </span><span class="nf">lunar_lagrange_points_circular</span><span class="p">(</span><span class="n">t</span><span class="p">):</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Calculate the positions of the lunar Lagrange points in the GCRF frame for a given time.</span>

<span class="sd">    This function calculates the positions of the five Lagrange points (L1, L2, L3, L4, and L5) in the Earth-Moon system at a specific time `t`. It accounts for the rotation of the Moon&#39;s orbit around the Earth, providing the positions in a circular approximation of the Earth-Moon system.</span>

<span class="sd">    Parameters:</span>
<span class="sd">    ----------</span>
<span class="sd">    t : Time</span>
<span class="sd">        The time at which to calculate the Lagrange points. The position of the Moon at this time is used to compute the Lagrange points.</span>

<span class="sd">    Returns:</span>
<span class="sd">    -------</span>
<span class="sd">    dict</span>
<span class="sd">        A dictionary containing the coordinates of the five Lagrange points:</span>
<span class="sd">        - &quot;L1&quot;: Position of the first Lagrange point between the Earth and the Moon.</span>
<span class="sd">        - &quot;L2&quot;: Position of the second Lagrange point beyond the Moon.</span>
<span class="sd">        - &quot;L3&quot;: Position of the third Lagrange point directly opposite the Moon, relative to the Earth.</span>
<span class="sd">        - &quot;L4&quot;: Position of the fourth Lagrange point, forming an equilateral triangle with the Earth and Moon.</span>
<span class="sd">        - &quot;L5&quot;: Position of the fifth Lagrange point, forming an equilateral triangle with the Earth and Moon, but on the opposite side.</span>

<span class="sd">    Notes:</span>
<span class="sd">    ------</span>
<span class="sd">    - The function assumes a circular orbit for the Moon and uses a rotation matrix to align the z-axis with the Moon&#39;s normal vector.</span>
<span class="sd">    - The positions of L4 and L5 are calculated using a rotation matrix to align with the Moon&#39;s orientation.</span>
<span class="sd">    - The gravitational parameters of the Earth and Moon are denoted as `EARTH_MU` and `MOON_MU`, respectively.</span>

<span class="sd">    Example usage:</span>
<span class="sd">    --------------</span>
<span class="sd">    &gt;&gt;&gt; t = Time(&quot;2024-01-01&quot;)</span>
<span class="sd">    &gt;&gt;&gt; lagrange_points = lunar_lagrange_points_circular(t)</span>
<span class="sd">    &gt;&gt;&gt; lagrange_points[&quot;L1&quot;]</span>
<span class="sd">    array([1.02e6, 0.0, 0.0])</span>
<span class="sd">    &gt;&gt;&gt; lagrange_points[&quot;L4&quot;]</span>
<span class="sd">    array([1.5e6, 1.5e6, 0.0])</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="n">r</span> <span class="o">=</span> <span class="n">get_body</span><span class="p">(</span><span class="s2">&quot;moon&quot;</span><span class="p">)</span><span class="o">.</span><span class="n">position</span><span class="p">(</span><span class="n">t</span><span class="p">)</span><span class="o">.</span><span class="n">T</span>
    <span class="n">d</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">linalg</span><span class="o">.</span><span class="n">norm</span><span class="p">(</span><span class="n">r</span><span class="p">)</span>  <span class="c1"># Distance between Earth and Moon</span>
    <span class="n">unit_vector_moon</span> <span class="o">=</span> <span class="n">r</span> <span class="o">/</span> <span class="n">np</span><span class="o">.</span><span class="n">linalg</span><span class="o">.</span><span class="n">norm</span><span class="p">(</span><span class="n">r</span><span class="p">,</span> <span class="n">axis</span><span class="o">=-</span><span class="mi">1</span><span class="p">)</span>

    <span class="c1"># Coefficients of the quadratic equation</span>
    <span class="n">a</span> <span class="o">=</span> <span class="n">EARTH_MU</span> <span class="o">-</span> <span class="n">MOON_MU</span>
    <span class="n">b</span> <span class="o">=</span> <span class="mi">2</span> <span class="o">*</span> <span class="n">MOON_MU</span> <span class="o">*</span> <span class="n">d</span>
    <span class="n">c</span> <span class="o">=</span> <span class="o">-</span><span class="n">MOON_MU</span> <span class="o">*</span> <span class="n">d</span><span class="o">**</span><span class="mi">2</span>

    <span class="c1"># Solve the quadratic equation</span>
    <span class="n">discriminant</span> <span class="o">=</span> <span class="n">b</span><span class="o">**</span><span class="mi">2</span> <span class="o">-</span> <span class="mi">4</span><span class="o">*</span><span class="n">a</span><span class="o">*</span><span class="n">c</span>

    <span class="k">if</span> <span class="n">discriminant</span> <span class="o">&gt;=</span> <span class="mi">0</span><span class="p">:</span>
        <span class="n">L1_from_moon</span> <span class="o">=</span> <span class="p">(</span><span class="o">-</span><span class="n">b</span> <span class="o">-</span> <span class="n">np</span><span class="o">.</span><span class="n">sqrt</span><span class="p">(</span><span class="n">discriminant</span><span class="p">))</span> <span class="o">/</span> <span class="p">(</span><span class="mi">2</span><span class="o">*</span><span class="n">a</span><span class="p">)</span> <span class="o">*</span> <span class="n">unit_vector_moon</span>
        <span class="n">L2_from_moon</span> <span class="o">=</span> <span class="p">(</span><span class="o">-</span><span class="n">b</span> <span class="o">+</span> <span class="n">np</span><span class="o">.</span><span class="n">sqrt</span><span class="p">(</span><span class="n">discriminant</span><span class="p">))</span> <span class="o">/</span> <span class="p">(</span><span class="mi">2</span><span class="o">*</span><span class="n">a</span><span class="p">)</span> <span class="o">*</span> <span class="n">unit_vector_moon</span>
    <span class="k">else</span><span class="p">:</span>
        <span class="nb">print</span><span class="p">(</span><span class="s2">&quot;Discriminate is less than 0! THAT&#39;S WEIRD FIX IT.&quot;</span><span class="p">)</span>
        <span class="n">L1_from_moon</span> <span class="o">=</span> <span class="kc">None</span>
        <span class="n">L2_from_moon</span> <span class="o">=</span> <span class="kc">None</span>

    <span class="c1"># L45</span>
    <span class="c1"># Create the rotation matrix to align z-axis with the normal vector</span>
    <span class="n">normal_vector</span> <span class="o">=</span> <span class="n">moon_normal_vector</span><span class="p">(</span><span class="n">t</span><span class="p">)</span>
    <span class="n">rotation_matrix</span> <span class="o">=</span> <span class="n">rotation_matrix_from_vectors</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">([</span><span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">1</span><span class="p">]),</span> <span class="n">normal_vector</span><span class="p">)</span>
    <span class="n">theta</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">radians</span><span class="p">(</span><span class="mi">60</span><span class="p">)</span> <span class="o">+</span> <span class="n">np</span><span class="o">.</span><span class="n">arctan2</span><span class="p">(</span><span class="n">unit_vector_moon</span><span class="p">[</span><span class="mi">1</span><span class="p">],</span> <span class="n">unit_vector_moon</span><span class="p">[</span><span class="mi">0</span><span class="p">])</span>
    <span class="n">L4</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">vstack</span><span class="p">((</span><span class="n">d</span> <span class="o">*</span> <span class="n">np</span><span class="o">.</span><span class="n">cos</span><span class="p">(</span><span class="n">theta</span><span class="p">),</span> <span class="n">d</span> <span class="o">*</span> <span class="n">np</span><span class="o">.</span><span class="n">sin</span><span class="p">(</span><span class="n">theta</span><span class="p">),</span> <span class="n">np</span><span class="o">.</span><span class="n">zeros_like</span><span class="p">(</span><span class="n">theta</span><span class="p">)))</span><span class="o">.</span><span class="n">T</span>
    <span class="n">L4</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">squeeze</span><span class="p">(</span><span class="n">L4</span> <span class="o">@</span> <span class="n">rotation_matrix</span><span class="o">.</span><span class="n">T</span><span class="p">)</span>
    <span class="n">theta</span> <span class="o">=</span> <span class="o">-</span><span class="n">np</span><span class="o">.</span><span class="n">radians</span><span class="p">(</span><span class="mi">60</span><span class="p">)</span> <span class="o">+</span> <span class="n">np</span><span class="o">.</span><span class="n">arctan2</span><span class="p">(</span><span class="n">unit_vector_moon</span><span class="p">[</span><span class="mi">1</span><span class="p">],</span> <span class="n">unit_vector_moon</span><span class="p">[</span><span class="mi">0</span><span class="p">])</span>
    <span class="n">L5</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">vstack</span><span class="p">((</span><span class="n">d</span> <span class="o">*</span> <span class="n">np</span><span class="o">.</span><span class="n">cos</span><span class="p">(</span><span class="n">theta</span><span class="p">),</span> <span class="n">d</span> <span class="o">*</span> <span class="n">np</span><span class="o">.</span><span class="n">sin</span><span class="p">(</span><span class="n">theta</span><span class="p">),</span> <span class="n">np</span><span class="o">.</span><span class="n">zeros_like</span><span class="p">(</span><span class="n">theta</span><span class="p">)))</span><span class="o">.</span><span class="n">T</span>
    <span class="n">L5</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">squeeze</span><span class="p">(</span><span class="n">L5</span> <span class="o">@</span> <span class="n">rotation_matrix</span><span class="o">.</span><span class="n">T</span><span class="p">)</span>

    <span class="k">return</span> <span class="p">{</span>
        <span class="s2">&quot;L1&quot;</span><span class="p">:</span> <span class="n">L1_from_moon</span> <span class="o">+</span> <span class="n">r</span><span class="p">,</span>
        <span class="s2">&quot;L2&quot;</span><span class="p">:</span> <span class="n">L2_from_moon</span> <span class="o">+</span> <span class="n">r</span><span class="p">,</span>
        <span class="s2">&quot;L3&quot;</span><span class="p">:</span> <span class="o">-</span><span class="n">r</span><span class="p">,</span>
        <span class="s2">&quot;L4&quot;</span><span class="p">:</span> <span class="n">L4</span><span class="p">,</span>
        <span class="s2">&quot;L5&quot;</span><span class="p">:</span> <span class="n">L5</span>
    <span class="p">}</span></div>


<div class="viewcode-block" id="lagrange_points_lunar_frame"><a class="viewcode-back" href="../../api/ssapy.compute.lagrange_points_lunar_frame.html#ssapy.compute.lagrange_points_lunar_frame">[docs]</a><span class="k">def</span><span class="w"> </span><span class="nf">lagrange_points_lunar_frame</span><span class="p">():</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Calculate the positions of the lunar Lagrange points in the lunar frame, This frame is defined by the coordinate transformation in utils.py gcrf_to_lunar().</span>

<span class="sd">    Returns:</span>
<span class="sd">    -------</span>
<span class="sd">    dict</span>
<span class="sd">        A dictionary containing the coordinates of the five Lagrange points:</span>
<span class="sd">        - &quot;L1&quot;: Position of the first Lagrange point between the Earth and the Moon.</span>
<span class="sd">        - &quot;L2&quot;: Position of the second Lagrange point beyond the Moon.</span>
<span class="sd">        - &quot;L3&quot;: Position of the third Lagrange point directly opposite the Moon, relative to the Earth.</span>
<span class="sd">        - &quot;L4&quot;: Position of the fourth Lagrange point, forming an equilateral triangle with the Earth and Moon.</span>
<span class="sd">        - &quot;L5&quot;: Position of the fifth Lagrange point, forming an equilateral triangle with the Earth and Moon, but on the opposite side.</span>

<span class="sd">    Notes:</span>
<span class="sd">    ------</span>
<span class="sd">    - The function assumes that the Earth and Moon are the two primary bodies, with the Earth-Moon distance denoted as `LD`.</span>
<span class="sd">    - The gravitational parameters of the Earth and Moon are denoted as `EARTH_MU` and `MOON_MU`, respectively.</span>
<span class="sd">    - The positions of L4 and L5 are calculated using the fact that these points form an equilateral triangle with the Earth and Moon.</span>

<span class="sd">    Example usage:</span>
<span class="sd">    --------------</span>
<span class="sd">    &gt;&gt;&gt; lagrange_points = lagrange_points_lunar_frame()</span>
<span class="sd">    &gt;&gt;&gt; lagrange_points[&quot;L1&quot;]</span>
<span class="sd">    array([1.01e6, 0.0, 0.0])</span>
<span class="sd">    &gt;&gt;&gt; lagrange_points[&quot;L4&quot;]</span>
<span class="sd">    array([1.5e6, 1.5e6, 0.0])</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="n">r</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">([</span><span class="n">LD</span> <span class="o">/</span> <span class="n">RGEO</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">])</span>
    <span class="n">d</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">linalg</span><span class="o">.</span><span class="n">norm</span><span class="p">(</span><span class="n">r</span><span class="p">)</span>  <span class="c1"># Distance between Earth and Moon</span>
    <span class="n">unit_vector_moon</span> <span class="o">=</span> <span class="n">r</span> <span class="o">/</span> <span class="n">np</span><span class="o">.</span><span class="n">linalg</span><span class="o">.</span><span class="n">norm</span><span class="p">(</span><span class="n">r</span><span class="p">,</span> <span class="n">axis</span><span class="o">=-</span><span class="mi">1</span><span class="p">)</span>

    <span class="c1"># Coefficients of the quadratic equation</span>
    <span class="n">a</span> <span class="o">=</span> <span class="n">EARTH_MU</span> <span class="o">-</span> <span class="n">MOON_MU</span>
    <span class="n">b</span> <span class="o">=</span> <span class="mi">2</span> <span class="o">*</span> <span class="n">MOON_MU</span> <span class="o">*</span> <span class="n">d</span>
    <span class="n">c</span> <span class="o">=</span> <span class="o">-</span><span class="n">MOON_MU</span> <span class="o">*</span> <span class="n">d</span><span class="o">**</span><span class="mi">2</span>

    <span class="c1"># Solve the quadratic equation</span>
    <span class="n">discriminant</span> <span class="o">=</span> <span class="n">b</span><span class="o">**</span><span class="mi">2</span> <span class="o">-</span> <span class="mi">4</span><span class="o">*</span><span class="n">a</span><span class="o">*</span><span class="n">c</span>

    <span class="k">if</span> <span class="n">discriminant</span> <span class="o">&gt;=</span> <span class="mi">0</span><span class="p">:</span>
        <span class="n">L1_from_moon</span> <span class="o">=</span> <span class="p">(</span><span class="o">-</span><span class="n">b</span> <span class="o">-</span> <span class="n">np</span><span class="o">.</span><span class="n">sqrt</span><span class="p">(</span><span class="n">discriminant</span><span class="p">))</span> <span class="o">/</span> <span class="p">(</span><span class="mi">2</span><span class="o">*</span><span class="n">a</span><span class="p">)</span> <span class="o">*</span> <span class="n">unit_vector_moon</span>
        <span class="n">L2_from_moon</span> <span class="o">=</span> <span class="p">(</span><span class="o">-</span><span class="n">b</span> <span class="o">+</span> <span class="n">np</span><span class="o">.</span><span class="n">sqrt</span><span class="p">(</span><span class="n">discriminant</span><span class="p">))</span> <span class="o">/</span> <span class="p">(</span><span class="mi">2</span><span class="o">*</span><span class="n">a</span><span class="p">)</span> <span class="o">*</span> <span class="n">unit_vector_moon</span>
    <span class="k">else</span><span class="p">:</span>
        <span class="nb">print</span><span class="p">(</span><span class="s2">&quot;Discriminate is less than 0! THAT&#39;S WEIRD FIX IT.&quot;</span><span class="p">)</span>
        <span class="n">L1_from_moon</span> <span class="o">=</span> <span class="kc">None</span>
        <span class="n">L2_from_moon</span> <span class="o">=</span> <span class="kc">None</span>

    <span class="c1"># L45</span>
    <span class="n">theta</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">radians</span><span class="p">(</span><span class="mi">60</span><span class="p">)</span>
    <span class="n">L4</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">squeeze</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">vstack</span><span class="p">((</span><span class="n">d</span> <span class="o">*</span> <span class="n">np</span><span class="o">.</span><span class="n">cos</span><span class="p">(</span><span class="n">theta</span><span class="p">),</span> <span class="n">d</span> <span class="o">*</span> <span class="n">np</span><span class="o">.</span><span class="n">sin</span><span class="p">(</span><span class="n">theta</span><span class="p">),</span> <span class="n">np</span><span class="o">.</span><span class="n">zeros_like</span><span class="p">(</span><span class="n">theta</span><span class="p">)))</span><span class="o">.</span><span class="n">T</span><span class="p">)</span>
    <span class="n">L5</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">squeeze</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">vstack</span><span class="p">((</span><span class="n">d</span> <span class="o">*</span> <span class="n">np</span><span class="o">.</span><span class="n">cos</span><span class="p">(</span><span class="o">-</span><span class="n">theta</span><span class="p">),</span> <span class="n">d</span> <span class="o">*</span> <span class="n">np</span><span class="o">.</span><span class="n">sin</span><span class="p">(</span><span class="o">-</span><span class="n">theta</span><span class="p">),</span> <span class="n">np</span><span class="o">.</span><span class="n">zeros_like</span><span class="p">(</span><span class="o">-</span><span class="n">theta</span><span class="p">)))</span><span class="o">.</span><span class="n">T</span><span class="p">)</span>
    <span class="k">return</span> <span class="p">{</span>
        <span class="s2">&quot;L1&quot;</span><span class="p">:</span> <span class="n">L1_from_moon</span> <span class="o">+</span> <span class="n">r</span><span class="p">,</span>
        <span class="s2">&quot;L2&quot;</span><span class="p">:</span> <span class="n">L2_from_moon</span> <span class="o">+</span> <span class="n">r</span><span class="p">,</span>
        <span class="s2">&quot;L3&quot;</span><span class="p">:</span> <span class="o">-</span><span class="n">r</span><span class="p">,</span>
        <span class="s2">&quot;L4&quot;</span><span class="p">:</span> <span class="n">L4</span><span class="p">,</span>
        <span class="s2">&quot;L5&quot;</span><span class="p">:</span> <span class="n">L5</span>
    <span class="p">}</span></div>
</pre></div>

           </div>
          </div>
          <footer>

  <hr/>

  <div role="contentinfo">
    <p>&#169; Copyright 2018, Lawrence Livermore National Security, LLC.</p>
  </div>

  Built with <a href="https://www.sphinx-doc.org/">Sphinx</a> using a
    <a href="https://github.com/readthedocs/sphinx_rtd_theme">theme</a>
    provided by <a href="https://readthedocs.org">Read the Docs</a>.
   

</footer>
        </div>
      </div>
    </section>
  </div>
  <script>
      jQuery(function () {
          SphinxRtdTheme.Navigation.enable(true);
      });
  </script> 

</body>
</html>