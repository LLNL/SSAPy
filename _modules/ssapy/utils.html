

<!DOCTYPE html>
<html class="writer-html5" lang="en">
<head>
  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1.0" />
  <title>ssapy.utils &mdash; SSAPy  documentation</title>
      <link rel="stylesheet" type="text/css" href="../../_static/pygments.css?v=b86133f3" />
      <link rel="stylesheet" type="text/css" href="../../_static/css/theme.css?v=e59714d7" />
      <link rel="stylesheet" type="text/css" href="../../_static/copybutton.css?v=76b2166b" />
      <link rel="stylesheet" type="text/css" href="../../_static/graphviz.css?v=eafc0fe6" />

  
    <link rel="shortcut icon" href="../../_static/ssapy_logo.ico"/>
      <script src="../../_static/jquery.js?v=5d32c60e"></script>
      <script src="../../_static/_sphinx_javascript_frameworks_compat.js?v=2cd50e6c"></script>
      <script data-url_root="../../" id="documentation_options" src="../../_static/documentation_options.js?v=b3ba4146"></script>
      <script src="../../_static/doctools.js?v=888ff710"></script>
      <script src="../../_static/sphinx_highlight.js?v=4825356b"></script>
      <script src="../../_static/clipboard.min.js?v=a7894cd8"></script>
      <script src="../../_static/copybutton.js?v=f281be69"></script>
    <script src="../../_static/js/theme.js"></script>
    <link rel="index" title="Index" href="../../genindex.html" />
    <link rel="search" title="Search" href="../../search.html" /> 
</head>

<body class="wy-body-for-nav"> 
  <div class="wy-grid-for-nav">
    <nav data-toggle="wy-nav-shift" class="wy-nav-side">
      <div class="wy-side-scroll">
        <div class="wy-side-nav-search" >

          
          
          <a href="../../index.html">
            
              <img src="../../_static/ssapy_logo.svg" class="logo" alt="Logo"/>
          </a>
<div role="search">
  <form id="rtd-search-form" class="wy-form" action="../../search.html" method="get">
    <input type="text" name="q" placeholder="Search docs" aria-label="Search docs" />
    <input type="hidden" name="check_keywords" value="yes" />
    <input type="hidden" name="area" value="default" />
  </form>
</div>
        </div><div class="wy-menu wy-menu-vertical" data-spy="affix" role="navigation" aria-label="Navigation menu">
              <p class="caption" role="heading"><span class="caption-text">Basics</span></p>
<ul>
<li class="toctree-l1"><a class="reference internal" href="../../installation.html">Getting Started</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../examples.html">SSAPy by Example</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../benchmarks.html">SSAPy Benchmarks</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../concepts.html">SSAPy Concepts</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../contribution_guide.html">Contribution Guide</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../references.html">References</a></li>
</ul>
<p class="caption" role="heading"><span class="caption-text">API DOCS</span></p>
<ul>
<li class="toctree-l1"><a class="reference internal" href="../../api.html">API Reference Guide</a></li>
</ul>

        </div>
      </div>
    </nav>

    <section data-toggle="wy-nav-shift" class="wy-nav-content-wrap"><nav class="wy-nav-top" aria-label="Mobile navigation menu" >
          <i data-toggle="wy-nav-top" class="fa fa-bars"></i>
          <a href="../../index.html">SSAPy</a>
      </nav>

      <div class="wy-nav-content">
        <div class="rst-content">
          <div role="navigation" aria-label="Page navigation">
  <ul class="wy-breadcrumbs">
      <li><a href="../../index.html" class="icon icon-home" aria-label="Home"></a></li>
          <li class="breadcrumb-item"><a href="../index.html">Module code</a></li>
      <li class="breadcrumb-item active">ssapy.utils</li>
      <li class="wy-breadcrumbs-aside">
      </li>
  </ul>
  <hr/>
</div>
          <div role="main" class="document" itemscope="itemscope" itemtype="http://schema.org/Article">
           <div itemprop="articleBody">
             
  <h1>Source code for ssapy.utils</h1><div class="highlight"><pre>
<span></span><span class="sd">&quot;&quot;&quot; This module provides functions for coordinate transformations, vector operations, celestial mechanics, and mathematical utilities. &quot;&quot;&quot;</span>


<span class="kn">import</span><span class="w"> </span><span class="nn">sys</span>
<span class="kn">import</span><span class="w"> </span><span class="nn">os</span>
<span class="kn">import</span><span class="w"> </span><span class="nn">numpy</span><span class="w"> </span><span class="k">as</span><span class="w"> </span><span class="nn">np</span>
<span class="kn">from</span><span class="w"> </span><span class="nn">astropy.time</span><span class="w"> </span><span class="kn">import</span> <span class="n">Time</span>
<span class="kn">import</span><span class="w"> </span><span class="nn">astropy.units</span><span class="w"> </span><span class="k">as</span><span class="w"> </span><span class="nn">u</span>
<span class="kn">from</span><span class="w"> </span><span class="nn">typing</span><span class="w"> </span><span class="kn">import</span> <span class="n">Union</span><span class="p">,</span> <span class="n">List</span><span class="p">,</span> <span class="n">Tuple</span>

<span class="kn">from</span><span class="w"> </span><span class="nn">.</span><span class="w"> </span><span class="kn">import</span> <span class="n">datadir</span>
<span class="kn">from</span><span class="w"> </span><span class="nn">.constants</span><span class="w"> </span><span class="kn">import</span> <span class="n">RGEO</span><span class="p">,</span> <span class="n">EARTH_RADIUS</span><span class="p">,</span> <span class="n">MOON_RADIUS</span><span class="p">,</span> <span class="n">WGS84_EARTH_OMEGA</span>

<span class="k">try</span><span class="p">:</span>
    <span class="kn">import</span><span class="w"> </span><span class="nn">erfa</span>
<span class="k">except</span> <span class="ne">ImportError</span><span class="p">:</span>
    <span class="kn">import</span><span class="w"> </span><span class="nn">astropy._erfa</span><span class="w"> </span><span class="k">as</span><span class="w"> </span><span class="nn">erfa</span>


<div class="viewcode-block" id="find_file"><a class="viewcode-back" href="../../api/ssapy.utils.find_file.html#ssapy.utils.find_file">[docs]</a><span class="k">def</span><span class="w"> </span><span class="nf">find_file</span><span class="p">(</span><span class="n">filename</span><span class="p">,</span> <span class="n">ext</span><span class="o">=</span><span class="kc">None</span><span class="p">):</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot; Find a file in the current directory or the ssapy datadir.  If ext is</span>
<span class="sd">    not None, also try appending ext to the filename.</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="n">candidates</span> <span class="o">=</span> <span class="p">[</span>
        <span class="n">filename</span><span class="p">,</span>
        <span class="n">os</span><span class="o">.</span><span class="n">path</span><span class="o">.</span><span class="n">join</span><span class="p">(</span><span class="n">datadir</span><span class="p">,</span> <span class="n">filename</span><span class="p">),</span>
        <span class="n">filename</span> <span class="o">+</span> <span class="n">ext</span><span class="p">,</span>
        <span class="n">os</span><span class="o">.</span><span class="n">path</span><span class="o">.</span><span class="n">join</span><span class="p">(</span><span class="n">datadir</span><span class="p">,</span> <span class="n">filename</span> <span class="o">+</span> <span class="n">ext</span><span class="p">),</span>
    <span class="p">]</span>
    <span class="k">for</span> <span class="n">candidate</span> <span class="ow">in</span> <span class="n">candidates</span><span class="p">:</span>
        <span class="k">if</span> <span class="n">os</span><span class="o">.</span><span class="n">path</span><span class="o">.</span><span class="n">isfile</span><span class="p">(</span><span class="n">candidate</span><span class="p">):</span>
            <span class="k">return</span> <span class="n">candidate</span>
    <span class="k">raise</span> <span class="ne">FileNotFoundError</span><span class="p">(</span><span class="n">filename</span><span class="p">)</span></div>


<span class="k">def</span><span class="w"> </span><span class="nf">_wrapToPi</span><span class="p">(</span><span class="n">angle</span><span class="p">):</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Wrap an angle to the range [-π, π].</span>

<span class="sd">    Parameters:</span>
<span class="sd">    -----------</span>
<span class="sd">    angle : float or array-like</span>
<span class="sd">        The input angle(s) in radians. Can be a single value or an array of values.</span>

<span class="sd">    Returns:</span>
<span class="sd">    --------</span>
<span class="sd">    wrapped_angle : float or array-like</span>
<span class="sd">        The angle(s) wrapped to the range [-π, π].</span>

<span class="sd">    Example:</span>
<span class="sd">    --------</span>
<span class="sd">    &gt;&gt;&gt; _wrapToPi(4)</span>
<span class="sd">    -2.283185307179586</span>
<span class="sd">    &gt;&gt;&gt; _wrapToPi(-4)</span>
<span class="sd">    2.283185307179586</span>
<span class="sd">    &gt;&gt;&gt; _wrapToPi([3.5, -3.5, 6.5])</span>
<span class="sd">    array([-2.78318531,  2.78318531,  0.28318531])</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="k">return</span> <span class="p">(</span><span class="n">angle</span> <span class="o">+</span> <span class="n">np</span><span class="o">.</span><span class="n">pi</span><span class="p">)</span> <span class="o">%</span> <span class="p">(</span><span class="mi">2</span> <span class="o">*</span> <span class="n">np</span><span class="o">.</span><span class="n">pi</span><span class="p">)</span> <span class="o">-</span> <span class="n">np</span><span class="o">.</span><span class="n">pi</span>


<div class="viewcode-block" id="num_wraps"><a class="viewcode-back" href="../../api/ssapy.utils.num_wraps.html#ssapy.utils.num_wraps">[docs]</a><span class="k">def</span><span class="w"> </span><span class="nf">num_wraps</span><span class="p">(</span><span class="n">ang</span><span class="p">):</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Return number of times angle `ang` has wrapped around.</span>

<span class="sd">    Returns</span>
<span class="sd">    -------</span>
<span class="sd">    int</span>
<span class="sd">        Number of wraps</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="kn">import</span><span class="w"> </span><span class="nn">astropy.units</span><span class="w"> </span><span class="k">as</span><span class="w"> </span><span class="nn">u</span>
    <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">ang</span><span class="p">,</span> <span class="n">u</span><span class="o">.</span><span class="n">Quantity</span><span class="p">):</span>
        <span class="n">ang</span> <span class="o">=</span> <span class="nb">float</span><span class="p">(</span><span class="n">ang</span> <span class="o">/</span> <span class="n">u</span><span class="o">.</span><span class="n">rad</span><span class="p">)</span>
    <span class="k">return</span> <span class="nb">int</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">floor</span><span class="p">(</span><span class="n">ang</span> <span class="o">/</span> <span class="p">(</span><span class="mi">2</span> <span class="o">*</span> <span class="n">np</span><span class="o">.</span><span class="n">pi</span><span class="p">)))</span></div>


<div class="viewcode-block" id="lazy_property"><a class="viewcode-back" href="../../api/ssapy.utils.lazy_property.html#ssapy.utils.lazy_property">[docs]</a><span class="k">class</span><span class="w"> </span><span class="nc">lazy_property</span><span class="p">:</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    meant to be used for lazy evaluation of an object attribute.</span>
<span class="sd">    property should represent non-mutable data, as it replaces itself.</span>
<span class="sd">    &quot;&quot;&quot;</span>

    <span class="k">def</span><span class="w"> </span><span class="fm">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">fget</span><span class="p">):</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">fget</span> <span class="o">=</span> <span class="n">fget</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">func_name</span> <span class="o">=</span> <span class="n">fget</span><span class="o">.</span><span class="vm">__name__</span>

    <span class="k">def</span><span class="w"> </span><span class="fm">__get__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">obj</span><span class="p">,</span> <span class="bp">cls</span><span class="p">):</span>
        <span class="k">if</span> <span class="n">obj</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
            <span class="k">return</span> <span class="bp">self</span>
        <span class="n">value</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">fget</span><span class="p">(</span><span class="n">obj</span><span class="p">)</span>
        <span class="nb">setattr</span><span class="p">(</span><span class="n">obj</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">func_name</span><span class="p">,</span> <span class="n">value</span><span class="p">)</span>
        <span class="k">return</span> <span class="n">value</span></div>


<div class="viewcode-block" id="newton_raphson"><a class="viewcode-back" href="../../api/ssapy.utils.newton_raphson.html#ssapy.utils.newton_raphson">[docs]</a><span class="k">def</span><span class="w"> </span><span class="nf">newton_raphson</span><span class="p">(</span><span class="n">guess</span><span class="p">,</span> <span class="n">f</span><span class="p">,</span> <span class="n">fprime</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">eps</span><span class="o">=</span><span class="mf">3e-16</span><span class="p">,</span> <span class="n">maxiter</span><span class="o">=</span><span class="mi">100</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">):</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Find a root of a univariate function with known gradient using</span>
<span class="sd">    Newton-Raphson iterations.</span>

<span class="sd">    Parameters</span>
<span class="sd">    ----------</span>
<span class="sd">    guess : float</span>
<span class="sd">        Initial guess.</span>
<span class="sd">    f : callable function of 1 argument.</span>
<span class="sd">        Function for which to find a zero.  If fprime is None, then the return</span>
<span class="sd">        value of f should be a 2-tuple with the value of the function and the</span>
<span class="sd">        first derivative.  If fprime is given separately, then f should just</span>
<span class="sd">        return the value of the function.</span>
<span class="sd">    fprime : callable function of 1 argument, optional</span>
<span class="sd">        Derivative of f.  Default None.</span>
<span class="sd">    eps : float, optional</span>
<span class="sd">        Absolute tolerance for finding a zero.  Default 3e-16.</span>
<span class="sd">    maxiter : int, optional</span>
<span class="sd">        Maximum number of iterations to try.  Default 100.</span>

<span class="sd">    Returns</span>
<span class="sd">    -------</span>
<span class="sd">    solution: float</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="n">delta</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">inf</span>
    <span class="n">niter</span> <span class="o">=</span> <span class="mi">0</span>
    <span class="n">x</span> <span class="o">=</span> <span class="n">guess</span>
    <span class="k">while</span> <span class="n">np</span><span class="o">.</span><span class="n">abs</span><span class="p">(</span><span class="n">delta</span><span class="p">)</span> <span class="o">&gt;</span> <span class="n">eps</span> <span class="ow">and</span> <span class="n">niter</span> <span class="o">&lt;</span> <span class="n">maxiter</span><span class="p">:</span>
        <span class="k">if</span> <span class="n">fprime</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
            <span class="n">val</span><span class="p">,</span> <span class="n">grad</span> <span class="o">=</span> <span class="n">f</span><span class="p">(</span><span class="n">x</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">)</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">val</span> <span class="o">=</span> <span class="n">f</span><span class="p">(</span><span class="n">x</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">)</span>
            <span class="n">grad</span> <span class="o">=</span> <span class="n">fprime</span><span class="p">(</span><span class="n">x</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">)</span>
        <span class="n">delta</span> <span class="o">=</span> <span class="n">val</span> <span class="o">/</span> <span class="n">grad</span>
        <span class="n">x</span> <span class="o">-=</span> <span class="n">delta</span>
        <span class="n">niter</span> <span class="o">+=</span> <span class="mi">1</span>
    <span class="k">return</span> <span class="n">x</span></div>


<div class="viewcode-block" id="find_extrema_brackets"><a class="viewcode-back" href="../../api/ssapy.utils.find_extrema_brackets.html#ssapy.utils.find_extrema_brackets">[docs]</a><span class="k">def</span><span class="w"> </span><span class="nf">find_extrema_brackets</span><span class="p">(</span><span class="n">fs</span><span class="p">):</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Find triplets bracketing extrema from an ordered set of function</span>
<span class="sd">    evaluations.</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="c1"># Want to find places where the sign of the finite difference changes.</span>
    <span class="n">diffs</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">trim_zeros</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">diff</span><span class="p">(</span><span class="n">fs</span><span class="p">),</span> <span class="s1">&#39;b&#39;</span><span class="p">)</span>
    <span class="n">w</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">where</span><span class="p">(</span><span class="n">diffs</span> <span class="o">==</span> <span class="mi">0</span><span class="p">)[</span><span class="mi">0</span><span class="p">]</span>
    <span class="k">while</span> <span class="n">np</span><span class="o">.</span><span class="n">any</span><span class="p">(</span><span class="n">w</span><span class="p">):</span>
        <span class="n">diffs</span><span class="p">[</span><span class="n">w</span><span class="p">]</span> <span class="o">=</span> <span class="n">diffs</span><span class="p">[</span><span class="n">w</span> <span class="o">+</span> <span class="mi">1</span><span class="p">]</span>
        <span class="n">w</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">where</span><span class="p">(</span><span class="n">diffs</span> <span class="o">==</span> <span class="mi">0</span><span class="p">)[</span><span class="mi">0</span><span class="p">]</span>
    <span class="n">w</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">where</span><span class="p">(</span><span class="n">diffs</span><span class="p">[:</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span> <span class="o">*</span> <span class="n">diffs</span><span class="p">[</span><span class="mi">1</span><span class="p">:]</span> <span class="o">&lt;</span> <span class="mi">0</span><span class="p">)[</span><span class="mi">0</span><span class="p">]</span>
    <span class="n">out</span> <span class="o">=</span> <span class="p">[]</span>
    <span class="k">for</span> <span class="n">wi</span> <span class="ow">in</span> <span class="n">w</span><span class="p">:</span>
        <span class="n">j</span> <span class="o">=</span> <span class="mi">2</span>
        <span class="k">while</span> <span class="n">fs</span><span class="p">[</span><span class="n">wi</span> <span class="o">+</span> <span class="n">j</span><span class="p">]</span> <span class="o">==</span> <span class="n">fs</span><span class="p">[</span><span class="n">wi</span> <span class="o">+</span> <span class="mi">1</span><span class="p">]:</span>
            <span class="n">j</span> <span class="o">+=</span> <span class="mi">1</span>
        <span class="n">out</span><span class="o">.</span><span class="n">append</span><span class="p">((</span><span class="n">wi</span><span class="p">,</span> <span class="n">wi</span> <span class="o">+</span> <span class="mi">1</span><span class="p">,</span> <span class="n">wi</span> <span class="o">+</span> <span class="n">j</span><span class="p">))</span>
    <span class="k">return</span> <span class="n">out</span></div>


<div class="viewcode-block" id="find_all_zeros"><a class="viewcode-back" href="../../api/ssapy.utils.find_all_zeros.html#ssapy.utils.find_all_zeros">[docs]</a><span class="k">def</span><span class="w"> </span><span class="nf">find_all_zeros</span><span class="p">(</span><span class="n">f</span><span class="p">,</span> <span class="n">low</span><span class="p">,</span> <span class="n">high</span><span class="p">,</span> <span class="n">n</span><span class="o">=</span><span class="mi">100</span><span class="p">):</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Attempt to find all zeros of a function between given bounds.  Uses n</span>
<span class="sd">    initial samples to characterize the zero-landscape of the interval.</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="kn">from</span><span class="w"> </span><span class="nn">scipy.optimize</span><span class="w"> </span><span class="kn">import</span> <span class="n">minimize_scalar</span><span class="p">,</span> <span class="n">brentq</span>
    <span class="c1"># Step one: Evaluate the function n times.</span>
    <span class="n">xs</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">linspace</span><span class="p">(</span><span class="n">low</span><span class="p">,</span> <span class="n">high</span><span class="p">,</span> <span class="n">n</span><span class="p">)</span>
    <span class="n">fs</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">([</span><span class="n">f</span><span class="p">(</span><span class="n">x</span><span class="p">)</span> <span class="k">for</span> <span class="n">x</span> <span class="ow">in</span> <span class="n">xs</span><span class="p">])</span>
    <span class="c1"># Step two: Identify extrema existence.</span>
    <span class="n">extrema</span> <span class="o">=</span> <span class="n">find_extrema_brackets</span><span class="p">(</span><span class="n">fs</span><span class="p">)</span>
    <span class="c1"># Step three: Fill in points for extrema that may lead to a zero-crossing.</span>
    <span class="n">newx</span><span class="p">,</span> <span class="n">newf</span> <span class="o">=</span> <span class="p">[],</span> <span class="p">[]</span>
    <span class="k">for</span> <span class="n">extremum</span> <span class="ow">in</span> <span class="n">extrema</span><span class="p">:</span>
        <span class="n">is_minimum</span> <span class="o">=</span> <span class="n">fs</span><span class="p">[</span><span class="n">extremum</span><span class="p">[</span><span class="mi">1</span><span class="p">]]</span> <span class="o">&lt;</span> <span class="n">fs</span><span class="p">[</span><span class="n">extremum</span><span class="p">[</span><span class="mi">0</span><span class="p">]]</span>
        <span class="k">if</span> <span class="p">(</span><span class="n">fs</span><span class="p">[</span><span class="n">extremum</span><span class="p">[</span><span class="mi">1</span><span class="p">]]</span> <span class="o">-</span> <span class="n">fs</span><span class="p">[</span><span class="n">extremum</span><span class="p">[</span><span class="mi">0</span><span class="p">]])</span> <span class="o">*</span> <span class="n">fs</span><span class="p">[</span><span class="n">extremum</span><span class="p">[</span><span class="mi">0</span><span class="p">]]</span> <span class="o">&gt;</span> <span class="mi">0</span><span class="p">:</span>
            <span class="k">continue</span>
        <span class="c1"># make a record of function evaluations.</span>

        <span class="k">def</span><span class="w"> </span><span class="nf">f2</span><span class="p">(</span><span class="n">x</span><span class="p">):</span>
            <span class="n">result</span> <span class="o">=</span> <span class="n">f</span><span class="p">(</span><span class="n">x</span><span class="p">)</span>
            <span class="n">newx</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">x</span><span class="p">)</span>
            <span class="n">newf</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">result</span><span class="p">)</span>
            <span class="k">if</span> <span class="ow">not</span> <span class="n">is_minimum</span><span class="p">:</span>
                <span class="n">result</span> <span class="o">*=</span> <span class="o">-</span><span class="mi">1</span>
            <span class="k">return</span> <span class="n">result</span>
        <span class="n">minimize_scalar</span><span class="p">(</span><span class="n">f2</span><span class="p">,</span> <span class="nb">tuple</span><span class="p">(</span><span class="n">xs</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="n">extremum</span><span class="p">))</span>

    <span class="n">xs</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">concatenate</span><span class="p">([</span><span class="n">xs</span><span class="p">,</span> <span class="n">newx</span><span class="p">])</span>
    <span class="n">fs</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">concatenate</span><span class="p">([</span><span class="n">fs</span><span class="p">,</span> <span class="n">newf</span><span class="p">])</span>
    <span class="n">a</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">argsort</span><span class="p">(</span><span class="n">xs</span><span class="p">)</span>
    <span class="n">xs</span> <span class="o">=</span> <span class="n">xs</span><span class="p">[</span><span class="n">a</span><span class="p">]</span>
    <span class="n">fs</span> <span class="o">=</span> <span class="n">fs</span><span class="p">[</span><span class="n">a</span><span class="p">]</span>
    <span class="c1"># Step four: Find zero crossings</span>
    <span class="n">zeros</span> <span class="o">=</span> <span class="nb">list</span><span class="p">(</span><span class="n">xs</span><span class="p">[</span><span class="n">fs</span> <span class="o">==</span> <span class="mf">0.0</span><span class="p">])</span>
    <span class="k">for</span> <span class="n">w</span> <span class="ow">in</span> <span class="n">np</span><span class="o">.</span><span class="n">where</span><span class="p">(</span><span class="n">fs</span><span class="p">[</span><span class="mi">1</span><span class="p">:]</span> <span class="o">*</span> <span class="n">fs</span><span class="p">[:</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span> <span class="o">&lt;</span> <span class="mi">0</span><span class="p">)[</span><span class="mi">0</span><span class="p">]:</span>
        <span class="n">zeros</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">brentq</span><span class="p">(</span><span class="n">f</span><span class="p">,</span> <span class="n">xs</span><span class="p">[</span><span class="n">w</span><span class="p">],</span> <span class="n">xs</span><span class="p">[</span><span class="n">w</span> <span class="o">+</span> <span class="mi">1</span><span class="p">]))</span>
    <span class="k">return</span> <span class="n">zeros</span></div>


<span class="c1"># Not quite as fast as specializing to shape = (3,), but more portable, and</span>
<span class="c1"># faster than np.linalg.norm().</span>
<span class="c1"># These compute the norm over the last axis and maintain the other leading axes.</span>
<div class="viewcode-block" id="normSq"><a class="viewcode-back" href="../../api/ssapy.utils.normSq.html#ssapy.utils.normSq">[docs]</a><span class="k">def</span><span class="w"> </span><span class="nf">normSq</span><span class="p">(</span><span class="n">arr</span><span class="p">):</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Compute the squared norm of an array over the last axis while preserving leading axes.</span>

<span class="sd">    This function calculates the squared norm of vectors along the last axis of the input array </span>
<span class="sd">    using Einstein summation notation (`np.einsum`). It is designed to be portable and efficient, </span>
<span class="sd">    offering better performance than `np.linalg.norm()` for this specific use case.</span>

<span class="sd">    Parameters:</span>
<span class="sd">    -----------</span>
<span class="sd">    arr : array-like</span>
<span class="sd">        Input array where the squared norm is computed along the last axis. </span>
<span class="sd">        The array can have any shape, with the last axis representing the vector components.</span>

<span class="sd">    Returns:</span>
<span class="sd">    --------</span>
<span class="sd">    norm_squared : array-like</span>
<span class="sd">        The squared norm of the input array computed along the last axis. </span>
<span class="sd">        The output shape matches the input shape, excluding the last axis.</span>

<span class="sd">    Notes:</span>
<span class="sd">    ------</span>
<span class="sd">    - This implementation is more portable and faster than using `np.linalg.norm()` </span>
<span class="sd">      for computing norms over the last axis, especially for large arrays.</span>
<span class="sd">    - It is slightly less specialized compared to methods optimized for fixed shapes </span>
<span class="sd">      (e.g., shape `(3,)`), but it generalizes well to arrays of arbitrary shape.</span>
<span class="sd">    - The computation uses `np.einsum(&quot;...i,...i&quot;, arr, arr)`, which efficiently performs </span>
<span class="sd">      the summation of squared components along the last axis.</span>

<span class="sd">    Example:</span>
<span class="sd">    --------</span>
<span class="sd">    &gt;&gt;&gt; import numpy as np</span>
<span class="sd">    &gt;&gt;&gt; arr = np.array([[1, 2, 3], [4, 5, 6]])</span>
<span class="sd">    &gt;&gt;&gt; normSq(arr)</span>
<span class="sd">    array([14, 77])</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="k">return</span> <span class="n">np</span><span class="o">.</span><span class="n">einsum</span><span class="p">(</span><span class="s2">&quot;...i,...i&quot;</span><span class="p">,</span> <span class="n">arr</span><span class="p">,</span> <span class="n">arr</span><span class="p">)</span></div>


<span class="c1"># Faster to not dispatch back to normSq</span>
<div class="viewcode-block" id="norm"><a class="viewcode-back" href="../../api/ssapy.utils.norm.html#ssapy.utils.norm">[docs]</a><span class="k">def</span><span class="w"> </span><span class="nf">norm</span><span class="p">(</span><span class="n">arr</span><span class="p">):</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Compute the Euclidean norm of an array over the last axis while preserving leading axes.</span>

<span class="sd">    Parameters:</span>
<span class="sd">    -----------</span>
<span class="sd">    arr : array-like</span>
<span class="sd">        Input array where the Euclidean norm is computed along the last axis. </span>
<span class="sd">        The array can have any shape, with the last axis representing the vector components.</span>

<span class="sd">    Returns:</span>
<span class="sd">    --------</span>
<span class="sd">    norm : array-like</span>
<span class="sd">        The Euclidean norm of the input array computed along the last axis. </span>
<span class="sd">        The output shape matches the input shape, excluding the last axis.</span>

<span class="sd">    Notes:</span>
<span class="sd">    ------</span>
<span class="sd">    - This implementation directly computes the norm using `np.sqrt` and `np.einsum`, </span>
<span class="sd">      avoiding the intermediate step of calling `normSq`. This improves performance.</span>
<span class="sd">    - The computation uses `np.einsum(&quot;...i,...i&quot;, arr, arr)` to efficiently sum the squared </span>
<span class="sd">      components along the last axis, followed by taking the square root.</span>
<span class="sd">    - Faster than using `np.linalg.norm()` for this specific use case and generalizes well </span>
<span class="sd">      to arrays of arbitrary shape.</span>

<span class="sd">    Example:</span>
<span class="sd">    --------</span>
<span class="sd">    &gt;&gt;&gt; import numpy as np</span>
<span class="sd">    &gt;&gt;&gt; arr = np.array([[1, 2, 3], [4, 5, 6]])</span>
<span class="sd">    &gt;&gt;&gt; norm(arr)</span>
<span class="sd">    array([3.74165739, 8.77496439])</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="k">return</span> <span class="n">np</span><span class="o">.</span><span class="n">sqrt</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">einsum</span><span class="p">(</span><span class="s2">&quot;...i,...i&quot;</span><span class="p">,</span> <span class="n">arr</span><span class="p">,</span> <span class="n">arr</span><span class="p">))</span></div>


<span class="c1"># Faster to not dispatch back to norm</span>
<div class="viewcode-block" id="normed"><a class="viewcode-back" href="../../api/ssapy.utils.normed.html#ssapy.utils.normed">[docs]</a><span class="k">def</span><span class="w"> </span><span class="nf">normed</span><span class="p">(</span><span class="n">arr</span><span class="p">):</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Normalize an array along the last axis to have unit length.</span>

<span class="sd">    This function computes the normalized version of the input array by dividing each vector </span>
<span class="sd">    along the last axis by its Euclidean norm. The normalization ensures that the resulting </span>
<span class="sd">    vectors have a magnitude of 1.</span>

<span class="sd">    Parameters:</span>
<span class="sd">    -----------</span>
<span class="sd">    arr : array-like</span>
<span class="sd">        Input array where normalization is applied along the last axis. </span>
<span class="sd">        The array can have any shape, with the last axis representing the vector components.</span>

<span class="sd">    Returns:</span>
<span class="sd">    --------</span>
<span class="sd">    normalized : array-like</span>
<span class="sd">        The normalized array with unit-length vectors along the last axis. </span>
<span class="sd">        The output shape matches the input shape.</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="k">return</span> <span class="n">arr</span> <span class="o">/</span> <span class="n">np</span><span class="o">.</span><span class="n">sqrt</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">einsum</span><span class="p">(</span><span class="s2">&quot;...i,...i&quot;</span><span class="p">,</span> <span class="n">arr</span><span class="p">,</span> <span class="n">arr</span><span class="p">))[</span><span class="o">...</span><span class="p">,</span> <span class="kc">None</span><span class="p">]</span></div>


<div class="viewcode-block" id="einsum_norm"><a class="viewcode-back" href="../../api/ssapy.utils.einsum_norm.html#ssapy.utils.einsum_norm">[docs]</a><span class="k">def</span><span class="w"> </span><span class="nf">einsum_norm</span><span class="p">(</span><span class="n">a</span><span class="p">,</span> <span class="n">indices</span><span class="o">=</span><span class="s1">&#39;ij,ji-&gt;i&#39;</span><span class="p">):</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Compute the norm of an array using Einstein summation notation with customizable indices.</span>

<span class="sd">    This function calculates the norm of an input array using `np.einsum` with user-defined </span>
<span class="sd">    summation indices. By default, it computes the Euclidean norm along the specified axes </span>
<span class="sd">    using the provided summation pattern. The result is the square root of the summation </span>
<span class="sd">    output.</span>

<span class="sd">    Parameters:</span>
<span class="sd">    -----------</span>
<span class="sd">    a : array-like</span>
<span class="sd">        Input array for which the norm is computed. The array can have any shape, and the </span>
<span class="sd">        summation pattern determines how the norm is calculated across its dimensions.</span>
<span class="sd">    indices : str, optional</span>
<span class="sd">        A string representing the Einstein summation pattern. The default value is </span>
<span class="sd">        `&#39;ij,ji-&gt;i&#39;`, which computes the norm along specific axes. Users can customize </span>
<span class="sd">        this pattern to suit their needs.</span>

<span class="sd">    Returns:</span>
<span class="sd">    --------</span>
<span class="sd">    norm : array-like</span>
<span class="sd">        The computed norm of the input array based on the specified summation pattern. </span>
<span class="sd">        The output shape depends on the summation indices provided.</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="k">return</span> <span class="n">np</span><span class="o">.</span><span class="n">sqrt</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">einsum</span><span class="p">(</span><span class="n">indices</span><span class="p">,</span> <span class="n">a</span><span class="p">,</span> <span class="n">a</span><span class="p">))</span></div>


<div class="viewcode-block" id="unitAngle3"><a class="viewcode-back" href="../../api/ssapy.utils.unitAngle3.html#ssapy.utils.unitAngle3">[docs]</a><span class="k">def</span><span class="w"> </span><span class="nf">unitAngle3</span><span class="p">(</span><span class="n">r1</span><span class="p">,</span> <span class="n">r2</span><span class="p">):</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;Robustly compute angle between unit vectors r1 and r2.</span>
<span class="sd">    Vectorized for multiple triplets.</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="n">r1</span><span class="p">,</span> <span class="n">r2</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">broadcast_arrays</span><span class="p">(</span><span class="n">r1</span><span class="p">,</span> <span class="n">r2</span><span class="p">)</span>
    <span class="n">dsq</span> <span class="o">=</span> <span class="n">normSq</span><span class="p">(</span><span class="n">r1</span> <span class="o">-</span> <span class="n">r2</span><span class="p">)</span>
    <span class="n">out</span> <span class="o">=</span> <span class="mi">2</span> <span class="o">*</span> <span class="n">np</span><span class="o">.</span><span class="n">arcsin</span><span class="p">(</span><span class="mf">0.5</span> <span class="o">*</span> <span class="n">np</span><span class="o">.</span><span class="n">sqrt</span><span class="p">(</span><span class="n">dsq</span><span class="p">))</span>
    <span class="c1"># Following will almost never be the case.  Exception is when r1, r2 are</span>
    <span class="c1"># nearly antipodal.</span>
    <span class="n">w</span> <span class="o">=</span> <span class="n">dsq</span> <span class="o">&lt;</span> <span class="mf">3.99</span>
    <span class="k">if</span> <span class="ow">not</span> <span class="n">np</span><span class="o">.</span><span class="n">all</span><span class="p">(</span><span class="n">w</span><span class="p">):</span>
        <span class="k">try</span><span class="p">:</span>
            <span class="n">out</span><span class="p">[</span><span class="o">~</span><span class="n">w</span><span class="p">]</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">pi</span> <span class="o">-</span> <span class="n">np</span><span class="o">.</span><span class="n">arcsin</span><span class="p">(</span><span class="n">norm</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">cross</span><span class="p">(</span><span class="n">r1</span><span class="p">[</span><span class="o">~</span><span class="n">w</span><span class="p">],</span> <span class="n">r2</span><span class="p">[</span><span class="o">~</span><span class="n">w</span><span class="p">])))</span>
        <span class="k">except</span> <span class="p">(</span><span class="ne">TypeError</span><span class="p">,</span> <span class="ne">IndexError</span><span class="p">):</span>
            <span class="n">out</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">pi</span> <span class="o">-</span> <span class="n">np</span><span class="o">.</span><span class="n">arcsin</span><span class="p">(</span><span class="n">norm</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">cross</span><span class="p">(</span><span class="n">r1</span><span class="p">,</span> <span class="n">r2</span><span class="p">)))</span>
    <span class="k">return</span> <span class="n">out</span></div>


<div class="viewcode-block" id="cluster_emcee_walkers"><a class="viewcode-back" href="../../api/ssapy.utils.cluster_emcee_walkers.html#ssapy.utils.cluster_emcee_walkers">[docs]</a><span class="k">def</span><span class="w"> </span><span class="nf">cluster_emcee_walkers</span><span class="p">(</span>
    <span class="n">chain</span><span class="p">,</span> <span class="n">lnprob</span><span class="p">,</span> <span class="n">lnprior</span><span class="p">,</span> <span class="n">thresh_multiplier</span><span class="o">=</span><span class="mi">1</span><span class="p">,</span> <span class="n">verbose</span><span class="o">=</span><span class="kc">False</span>
<span class="p">):</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Down-select emcee walkers to those with the largest posterior mean.</span>

<span class="sd">    Follows the algorithm of Hou, Goodman, Hogg et al. (2012), An affine-invariant</span>
<span class="sd">    sampler for exoplanet fitting and discovery in radial velocity data.</span>
<span class="sd">    The Astrophysical Journal, 745(2), 198.</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="kn">import</span><span class="w"> </span><span class="nn">emcee</span>
    <span class="kn">from</span><span class="w"> </span><span class="nn">distutils.version</span><span class="w"> </span><span class="kn">import</span> <span class="n">LooseVersion</span>
    <span class="k">if</span> <span class="n">LooseVersion</span><span class="p">(</span><span class="n">emcee</span><span class="o">.</span><span class="n">__version__</span><span class="p">)</span> <span class="o">&lt;</span> <span class="n">LooseVersion</span><span class="p">(</span><span class="s2">&quot;3.0&quot;</span><span class="p">):</span>
        <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s2">&quot;emcee version at least 3.0rc2 required&quot;</span><span class="p">)</span>
    <span class="k">if</span> <span class="n">verbose</span><span class="p">:</span>
        <span class="n">out</span> <span class="o">=</span> <span class="s2">&quot;Clustering emcee walkers with threshold multiplier </span><span class="si">{:3.2f}</span><span class="s2">&quot;</span>
        <span class="n">out</span> <span class="o">=</span> <span class="n">out</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="n">thresh_multiplier</span><span class="p">)</span>
        <span class="nb">print</span><span class="p">(</span><span class="n">out</span><span class="p">)</span>
    <span class="n">chain</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">(</span><span class="n">chain</span><span class="p">)</span>
    <span class="n">lnprob</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">(</span><span class="n">lnprob</span><span class="p">)</span>
    <span class="c1"># ## lnprob.shape == (Nsteps, Nwalkers) =&gt; lk.shape == (Nwalkers,)</span>
    <span class="n">lk</span> <span class="o">=</span> <span class="o">-</span><span class="n">np</span><span class="o">.</span><span class="n">mean</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">(</span><span class="n">lnprob</span><span class="p">),</span> <span class="n">axis</span><span class="o">=</span><span class="mi">0</span><span class="p">)</span>
    <span class="n">nwalkers</span> <span class="o">=</span> <span class="nb">len</span><span class="p">(</span><span class="n">lk</span><span class="p">)</span>
    <span class="n">ndx</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">argsort</span><span class="p">(</span><span class="n">lk</span><span class="p">)</span>
    <span class="n">lks</span> <span class="o">=</span> <span class="n">lk</span><span class="p">[</span><span class="n">ndx</span><span class="p">]</span>
    <span class="n">d</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">diff</span><span class="p">(</span><span class="n">lks</span><span class="p">)</span>
    <span class="n">thresh</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">cumsum</span><span class="p">(</span><span class="n">d</span><span class="p">)</span> <span class="o">/</span> <span class="n">np</span><span class="o">.</span><span class="n">arange</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span> <span class="n">nwalkers</span><span class="p">)</span>
    <span class="n">selection</span> <span class="o">=</span> <span class="n">d</span> <span class="o">&gt;</span> <span class="p">(</span><span class="n">thresh_multiplier</span> <span class="o">*</span> <span class="n">thresh</span><span class="p">)</span>
    <span class="k">if</span> <span class="n">np</span><span class="o">.</span><span class="n">any</span><span class="p">(</span><span class="n">selection</span><span class="p">):</span>
        <span class="n">nkeep</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">argmax</span><span class="p">(</span><span class="n">selection</span><span class="p">)</span>
    <span class="k">else</span><span class="p">:</span>
        <span class="n">nkeep</span> <span class="o">=</span> <span class="n">nwalkers</span>
    <span class="k">if</span> <span class="n">verbose</span><span class="p">:</span>
        <span class="nb">print</span><span class="p">(</span><span class="s2">&quot;chain, lnprob:&quot;</span><span class="p">,</span> <span class="n">chain</span><span class="o">.</span><span class="n">shape</span><span class="p">,</span> <span class="n">lnprob</span><span class="o">.</span><span class="n">shape</span><span class="p">)</span>
    <span class="n">chain</span> <span class="o">=</span> <span class="n">chain</span><span class="p">[:,</span> <span class="n">ndx</span><span class="p">[</span><span class="mi">0</span><span class="p">:</span><span class="n">nkeep</span><span class="p">],</span> <span class="p">:]</span>
    <span class="n">lnprob</span> <span class="o">=</span> <span class="n">lnprob</span><span class="p">[:,</span> <span class="n">ndx</span><span class="p">[</span><span class="mi">0</span><span class="p">:</span><span class="n">nkeep</span><span class="p">]]</span>
    <span class="n">lnprior</span> <span class="o">=</span> <span class="n">lnprior</span><span class="p">[:,</span> <span class="n">ndx</span><span class="p">[</span><span class="mi">0</span><span class="p">:</span><span class="n">nkeep</span><span class="p">]]</span>
    <span class="k">if</span> <span class="n">verbose</span><span class="p">:</span>
        <span class="nb">print</span><span class="p">(</span><span class="s2">&quot;New chain, lnprob:&quot;</span><span class="p">,</span> <span class="n">chain</span><span class="o">.</span><span class="n">shape</span><span class="p">,</span> <span class="n">lnprob</span><span class="o">.</span><span class="n">shape</span><span class="p">)</span>
    <span class="k">return</span> <span class="n">chain</span><span class="p">,</span> <span class="n">lnprob</span><span class="p">,</span> <span class="n">lnprior</span></div>


<div class="viewcode-block" id="subsample_high_lnprob"><a class="viewcode-back" href="../../api/ssapy.utils.subsample_high_lnprob.html#ssapy.utils.subsample_high_lnprob">[docs]</a><span class="k">def</span><span class="w"> </span><span class="nf">subsample_high_lnprob</span><span class="p">(</span><span class="n">chain</span><span class="p">,</span> <span class="n">lnprob</span><span class="p">,</span> <span class="n">lnprior</span><span class="p">,</span> <span class="n">nSample</span><span class="p">,</span> <span class="n">thresh</span><span class="o">=-</span><span class="mi">10</span><span class="p">):</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;Select MCMC samples with probabilities above some relative threshold</span>

<span class="sd">    Parameters</span>
<span class="sd">    ----------</span>
<span class="sd">    chain : array_like, (nWalker, nStep, 6)</span>
<span class="sd">        Input MCMC chain from EmceeSampler.sample()</span>
<span class="sd">    lnprob : array_like, (nWalker, nStep)</span>
<span class="sd">        Input MCMC lnprob from EmceeSampler.sample()</span>
<span class="sd">    lnprior : array_like, (nWalker, nStep)</span>
<span class="sd">        Input MCMC lnprior from EmceeSampler.sample()</span>
<span class="sd">    nSample : int</span>
<span class="sd">        Number of samples to return.  If fewer than nSample samples</span>
<span class="sd">        exceed threshold, then return the nSample most probable</span>
<span class="sd">        samples.</span>
<span class="sd">    thresh : float, optional</span>
<span class="sd">        Threshold w.r.t. max(lnprob) below which to exclude samples.</span>

<span class="sd">    Returns</span>
<span class="sd">    -------</span>
<span class="sd">    samples : array_like, (nSample, 6)</span>
<span class="sd">        Output samples</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="n">chain</span> <span class="o">=</span> <span class="n">chain</span><span class="o">.</span><span class="n">reshape</span><span class="p">(</span><span class="o">-</span><span class="mi">1</span><span class="p">,</span> <span class="mi">6</span><span class="p">)</span>
    <span class="n">lnprob</span> <span class="o">=</span> <span class="n">lnprob</span><span class="o">.</span><span class="n">reshape</span><span class="p">(</span><span class="o">-</span><span class="mi">1</span><span class="p">)</span>
    <span class="n">lnprior</span> <span class="o">=</span> <span class="n">lnprior</span><span class="o">.</span><span class="n">reshape</span><span class="p">(</span><span class="o">-</span><span class="mi">1</span><span class="p">)</span>
    <span class="n">asort</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">argsort</span><span class="p">(</span><span class="o">-</span><span class="n">lnprob</span><span class="p">)</span>
    <span class="n">lnprobmax</span> <span class="o">=</span> <span class="n">lnprob</span><span class="p">[</span><span class="n">asort</span><span class="p">[</span><span class="mi">0</span><span class="p">]]</span>
    <span class="n">goodLnProbThresh</span> <span class="o">=</span> <span class="n">lnprobmax</span> <span class="o">+</span> <span class="n">thresh</span>
    <span class="n">nGood</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">searchsorted</span><span class="p">(</span><span class="o">-</span><span class="n">lnprob</span><span class="p">,</span> <span class="o">-</span><span class="n">goodLnProbThresh</span><span class="p">,</span> <span class="n">sorter</span><span class="o">=</span><span class="n">asort</span><span class="p">)</span>
    <span class="n">nGood</span> <span class="o">=</span> <span class="nb">max</span><span class="p">(</span><span class="n">nGood</span><span class="p">,</span> <span class="n">nSample</span><span class="p">)</span>
    <span class="n">permutation</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">random</span><span class="o">.</span><span class="n">permutation</span><span class="p">(</span><span class="n">nGood</span><span class="p">)</span>
    <span class="n">s</span> <span class="o">=</span> <span class="n">asort</span><span class="p">[</span><span class="n">permutation</span><span class="p">[:</span><span class="n">nSample</span><span class="p">]]</span>
    <span class="k">return</span> <span class="n">chain</span><span class="p">[</span><span class="n">s</span><span class="p">],</span> <span class="n">lnprob</span><span class="p">[</span><span class="n">s</span><span class="p">],</span> <span class="n">lnprior</span><span class="p">[</span><span class="n">s</span><span class="p">]</span></div>


<div class="viewcode-block" id="resample"><a class="viewcode-back" href="../../api/ssapy.utils.resample.html#ssapy.utils.resample">[docs]</a><span class="k">def</span><span class="w"> </span><span class="nf">resample</span><span class="p">(</span><span class="n">particles</span><span class="p">,</span> <span class="n">ln_weights</span><span class="p">,</span> <span class="n">obs_times</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">pod</span><span class="o">=</span><span class="kc">False</span><span class="p">):</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Resample particles to achieve more uniform weights.</span>
<span class="sd">    This produces the same number of particles as are input (i.n. dimension</span>
<span class="sd">    matches &quot;particles&quot;)</span>
<span class="sd">    From &quot;Bayesian Multiple Target Tracking&quot; (2nd ed.) p. 100</span>

<span class="sd">    :param particles: 2D array of particles. Each row is an nD particles</span>
<span class="sd">    :type particles: numpy.ndarray</span>

<span class="sd">    :param ln_weights: 1D array of particle log-weights. Length should match</span>
<span class="sd">        number of particles</span>
<span class="sd">    :type ln_weights: numpy.ndarray</span>

<span class="sd">    :param obs_times: Time at which observation occured. This is only used if</span>
<span class="sd">        pod=True, defaults to None</span>
<span class="sd">    :type obs_times: [type], optional</span>

<span class="sd">    :param pod: Specify whether this is the special case of regularizing orbit</span>
<span class="sd">        parameters, defaults to False</span>
<span class="sd">    :type pod: bool, optional</span>

<span class="sd">    :return: Resampled particles and weights (same number as input)</span>
<span class="sd">    :rtype: (numpy.ndarray, numpy.ndarray)</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="kn">import</span><span class="w"> </span><span class="nn">bisect</span>
    <span class="n">num_particles</span> <span class="o">=</span> <span class="n">particles</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span>
    <span class="c1"># weights /= np.sum(weights)</span>
    <span class="n">weights</span> <span class="o">=</span> <span class="n">get_normed_weights</span><span class="p">(</span><span class="n">ln_weights</span><span class="p">)</span>

    <span class="c1"># 1.</span>
    <span class="n">cumul_weights</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">cumsum</span><span class="p">(</span><span class="n">weights</span><span class="p">)</span>

    <span class="c1"># 2.</span>
    <span class="c1"># This is cumulative weights for a new set of particles with equal weights</span>
    <span class="n">cumul_new_weights</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">arange</span><span class="p">(</span><span class="n">num_particles</span><span class="p">,</span> <span class="n">dtype</span><span class="o">=</span><span class="nb">float</span><span class="p">)</span> <span class="o">/</span> <span class="n">num_particles</span>
    <span class="c1"># The offset of the first value sets the sampling used to match the</span>
    <span class="c1"># cumulative weight ranges of the old particles to the new particles</span>
    <span class="n">new_weight_offset</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">random</span><span class="o">.</span><span class="n">uniform</span><span class="p">(</span><span class="n">high</span><span class="o">=</span><span class="mf">1.</span> <span class="o">/</span> <span class="n">num_particles</span><span class="p">)</span>
    <span class="n">cumul_new_weights</span> <span class="o">+=</span> <span class="n">new_weight_offset</span>

    <span class="c1"># 3.</span>
    <span class="c1"># For j=1:J, do the following</span>
    <span class="c1"># For m such that C_{j-1} &lt;= u_m &lt;= C_j, set xi^m = x^j</span>
    <span class="c1"># Select the new particle values based on the weights of the original</span>
    <span class="c1"># particles. Particles with large weight are repeated, while particles with</span>
    <span class="c1"># small weights may be eliminated.</span>
    <span class="n">new_particle_inds</span> <span class="o">=</span> <span class="p">[</span><span class="n">bisect</span><span class="o">.</span><span class="n">bisect_left</span><span class="p">(</span><span class="n">cumul_weights</span><span class="p">,</span> <span class="n">x</span><span class="p">)</span>
                         <span class="k">for</span> <span class="n">x</span> <span class="ow">in</span> <span class="n">cumul_new_weights</span><span class="p">]</span>
    <span class="n">resampled_states</span> <span class="o">=</span> <span class="n">particles</span><span class="p">[</span><span class="n">new_particle_inds</span><span class="p">,</span> <span class="p">]</span>

    <span class="c1"># 4. Perturb states (i.e., regularization)</span>
    <span class="k">if</span> <span class="n">pod</span><span class="p">:</span>
        <span class="c1"># Special case: regularization for preliminary orbit determination</span>
        <span class="c1"># For now, we&#39;re ignoring this and doing it the same way</span>
        <span class="n">reg_delta</span><span class="p">,</span> <span class="n">reg_weights</span> <span class="o">=</span> <span class="n">regularize_default</span><span class="p">(</span><span class="n">particles</span><span class="p">,</span> <span class="n">weights</span><span class="p">)</span>
        <span class="c1"># 5. Redefine weights to uniform distribution</span>
        <span class="n">new_particles</span> <span class="o">=</span> <span class="n">resampled_states</span>
        <span class="n">new_particles</span><span class="p">[:,</span> <span class="mi">0</span><span class="p">:</span><span class="mi">6</span><span class="p">]</span> <span class="o">=</span> <span class="n">resampled_states</span><span class="p">[:,</span> <span class="mi">0</span><span class="p">:</span><span class="mi">6</span><span class="p">]</span> <span class="o">+</span> <span class="n">reg_delta</span>
    <span class="k">else</span><span class="p">:</span>
        <span class="n">reg_delta</span><span class="p">,</span> <span class="n">reg_weights</span> <span class="o">=</span> <span class="n">regularize_default</span><span class="p">(</span><span class="n">particles</span><span class="p">,</span> <span class="n">weights</span><span class="p">)</span>
        <span class="c1"># 5. Redefine weights to uniform distribution</span>
        <span class="n">new_particles</span> <span class="o">=</span> <span class="n">resampled_states</span> <span class="o">+</span> <span class="n">reg_delta</span>

    <span class="k">return</span> <span class="n">new_particles</span><span class="p">,</span> <span class="n">reg_weights</span></div>


<div class="viewcode-block" id="get_normed_weights"><a class="viewcode-back" href="../../api/ssapy.utils.get_normed_weights.html#ssapy.utils.get_normed_weights">[docs]</a><span class="k">def</span><span class="w"> </span><span class="nf">get_normed_weights</span><span class="p">(</span><span class="n">ln_weights</span><span class="p">):</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Computes normalized weights from log-weights.</span>

<span class="sd">    Parameters:</span>
<span class="sd">        ln_weights (ndarray): Logarithmic weights.</span>

<span class="sd">    Returns:</span>
<span class="sd">        ndarray: Normalized weights summing to 1.</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="n">ln_wts_norm</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">logaddexp</span><span class="o">.</span><span class="n">reduce</span><span class="p">(</span><span class="n">ln_weights</span><span class="p">)</span>
    <span class="n">weights</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">exp</span><span class="p">(</span><span class="n">ln_weights</span> <span class="o">-</span> <span class="n">ln_wts_norm</span><span class="p">)</span>
    <span class="k">return</span> <span class="n">weights</span></div>


<div class="viewcode-block" id="regularize_default"><a class="viewcode-back" href="../../api/ssapy.utils.regularize_default.html#ssapy.utils.regularize_default">[docs]</a><span class="k">def</span><span class="w"> </span><span class="nf">regularize_default</span><span class="p">(</span><span class="n">particles</span><span class="p">,</span> <span class="n">weights</span><span class="p">,</span> <span class="n">num_particles_out</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">dimension</span><span class="o">=</span><span class="mi">6</span><span class="p">):</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Perform particle regularization. This generates a perturbation from the</span>
<span class="sd">    particles&#39; original values to prevent singularity issues.</span>
<span class="sd">    From &quot;Bayesian Multiple Target Tracking&quot; (2nd ed.) p. 101-102</span>

<span class="sd">    :param particles: Particles to reqularize. Each row is an nD particle</span>
<span class="sd">    :type particles: numpy.ndarray</span>

<span class="sd">    :param weights: 1D array of particle weight. Should be same length as number</span>
<span class="sd">         of particles.</span>
<span class="sd">    :type weights: numpy.ndarray</span>

<span class="sd">    :param num_particles_out: Number of particles to return, defaults to None.</span>
<span class="sd">        If not specified, will return the same number of particles as in the</span>
<span class="sd">        input particles.</span>
<span class="sd">    :type num_particles_out: int | None, optional</span>

<span class="sd">    :param dimension: Dimension of the parameter space for resampling. Assumes</span>
<span class="sd">        the first `dimension` columns of `particles` are the parameters to use.</span>
<span class="sd">        Any remaining columns are carried through without modification (e.g.,</span>
<span class="sd">        time columns). Default: 6</span>
<span class="sd">    :type dimension: int, optional</span>

<span class="sd">    :return: Deltas from original particles and their weights</span>
<span class="sd">    :rtype: (numpy.ndarray, numpy.ndarray)</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="n">num_particles_in</span><span class="p">,</span> <span class="n">dim_in</span> <span class="o">=</span> <span class="n">particles</span><span class="o">.</span><span class="n">shape</span>
    <span class="k">if</span> <span class="n">num_particles_out</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
        <span class="n">num_particles_out</span> <span class="o">=</span> <span class="n">num_particles_in</span>
    <span class="n">kernel_cov</span> <span class="o">=</span> <span class="n">get_kernel_cov</span><span class="p">(</span><span class="n">particles</span><span class="p">[:,</span> <span class="mi">0</span><span class="p">:</span><span class="n">dimension</span><span class="p">],</span> <span class="n">weights</span><span class="p">)</span>
    <span class="c1"># print(&quot;kernel_cov:&quot;, kernel_cov)</span>
    <span class="n">window_size</span> <span class="o">=</span> <span class="p">(</span><span class="mf">4.</span> <span class="o">/</span> <span class="p">(</span><span class="n">num_particles_in</span> <span class="o">*</span> <span class="p">(</span><span class="n">dimension</span> <span class="o">+</span> <span class="mi">1</span><span class="p">)))</span> <span class="o">**</span> <span class="p">(</span><span class="mf">1.</span> <span class="o">/</span> <span class="p">(</span><span class="n">dimension</span> <span class="o">+</span> <span class="mf">4.</span><span class="p">))</span>
    <span class="c1"># Use a smaller window size for multi-modal distributions</span>
    <span class="n">adj_windows_size</span> <span class="o">=</span> <span class="n">window_size</span> <span class="o">/</span> <span class="mf">2.</span>
    <span class="c1"># Generate deltas of new particles from a normal distribution with zero mean</span>
    <span class="c1"># and covariance according to the input particles</span>
    <span class="n">delta</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">random</span><span class="o">.</span><span class="n">multivariate_normal</span><span class="p">(</span><span class="n">mean</span><span class="o">=</span><span class="n">np</span><span class="o">.</span><span class="n">zeros</span><span class="p">(</span><span class="n">dimension</span><span class="p">),</span>
                                          <span class="n">cov</span><span class="o">=</span><span class="n">kernel_cov</span> <span class="o">*</span> <span class="p">(</span><span class="n">adj_windows_size</span><span class="o">**</span><span class="mi">2</span><span class="p">),</span>
                                          <span class="n">size</span><span class="o">=</span><span class="n">num_particles_out</span><span class="p">)</span>
    <span class="n">weights_out</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">ones</span><span class="p">(</span><span class="n">num_particles_out</span><span class="p">)</span> <span class="o">/</span> <span class="nb">float</span><span class="p">(</span><span class="n">num_particles_out</span><span class="p">)</span>
    <span class="k">return</span> <span class="n">delta</span><span class="p">,</span> <span class="n">weights_out</span></div>


<div class="viewcode-block" id="get_kernel_cov"><a class="viewcode-back" href="../../api/ssapy.utils.get_kernel_cov.html#ssapy.utils.get_kernel_cov">[docs]</a><span class="k">def</span><span class="w"> </span><span class="nf">get_kernel_cov</span><span class="p">(</span><span class="n">kernel_mat</span><span class="p">,</span> <span class="n">weights</span><span class="p">):</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Get the covariance matrix of kernel_mat. This a wrapper for numpy&#39;s cov</span>

<span class="sd">    :param kernel_mat: Data matrix</span>
<span class="sd">    :type kernel_mat: numpy.ndarray</span>

<span class="sd">    :param weights: 1D array of weights of the data</span>
<span class="sd">    :type weights: numpy.ndarray</span>

<span class="sd">    :return: numpy.ndarray</span>
<span class="sd">    :rtype: Covariance matrix</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="k">return</span> <span class="n">np</span><span class="o">.</span><span class="n">cov</span><span class="p">(</span><span class="n">kernel_mat</span><span class="o">.</span><span class="n">transpose</span><span class="p">(),</span> <span class="n">aweights</span><span class="o">=</span><span class="n">weights</span><span class="p">,</span> <span class="n">bias</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span></div>


<div class="viewcode-block" id="LRU_Cache"><a class="viewcode-back" href="../../api/ssapy.utils.LRU_Cache.html#ssapy.utils.LRU_Cache">[docs]</a><span class="k">class</span><span class="w"> </span><span class="nc">LRU_Cache</span><span class="p">:</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;Simplified Least Recently Used Cache.</span>

<span class="sd">    Mostly stolen from http://code.activestate.com/recipes/577970-simplified-lru-cache/,</span>
<span class="sd">    but added a method for dynamic resizing.  The least recently used cached item is</span>
<span class="sd">    overwritten on a cache miss.</span>

<span class="sd">    Parameters:</span>
<span class="sd">        user_function:  A python function to cache.</span>
<span class="sd">        maxsize:        Maximum number of inputs to cache.  [Default: 1024]</span>

<span class="sd">    Example::</span>

<span class="sd">        &gt;&gt;&gt; def slow_function(*args) # A slow-to-evaluate python function</span>
<span class="sd">        &gt;&gt;&gt;    ...</span>
<span class="sd">        &gt;&gt;&gt;</span>
<span class="sd">        &gt;&gt;&gt; v1 = slow_function(*k1)  # Calling function is slow</span>
<span class="sd">        &gt;&gt;&gt; v1 = slow_function(*k1)  # Calling again with same args is still slow</span>
<span class="sd">        &gt;&gt;&gt; cache = LRU_Cache(slow_function)</span>
<span class="sd">        &gt;&gt;&gt; v1 = cache(*k1)  # Returns slow_function(*k1), slowly the first time</span>
<span class="sd">        &gt;&gt;&gt; v1 = cache(*k1)  # Returns slow_function(*k1) again, but fast this time.</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="k">def</span><span class="w"> </span><span class="fm">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">user_function</span><span class="p">,</span> <span class="n">maxsize</span><span class="o">=</span><span class="mi">1024</span><span class="p">):</span>
        <span class="k">if</span> <span class="n">maxsize</span> <span class="o">&lt;</span> <span class="mi">0</span><span class="p">:</span>
            <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s2">&quot;Invalid maxsize&quot;</span><span class="p">,</span> <span class="n">maxsize</span><span class="p">)</span>

        <span class="c1"># Link layout:     [PREV, NEXT, KEY, RESULT]</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">root</span> <span class="o">=</span> <span class="n">root</span> <span class="o">=</span> <span class="p">[</span><span class="kc">None</span><span class="p">,</span> <span class="kc">None</span><span class="p">,</span> <span class="kc">None</span><span class="p">,</span> <span class="kc">None</span><span class="p">]</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">user_function</span> <span class="o">=</span> <span class="n">user_function</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">cache</span> <span class="o">=</span> <span class="n">cache</span> <span class="o">=</span> <span class="p">{}</span>

        <span class="n">last</span> <span class="o">=</span> <span class="n">root</span>
        <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">maxsize</span><span class="p">):</span>
            <span class="n">key</span> <span class="o">=</span> <span class="nb">object</span><span class="p">()</span>
            <span class="n">cache</span><span class="p">[</span><span class="n">key</span><span class="p">]</span> <span class="o">=</span> <span class="n">last</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span> <span class="o">=</span> <span class="n">last</span> <span class="o">=</span> <span class="p">[</span><span class="n">last</span><span class="p">,</span> <span class="n">root</span><span class="p">,</span> <span class="n">key</span><span class="p">,</span> <span class="kc">None</span><span class="p">]</span>
        <span class="n">root</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">=</span> <span class="n">last</span>

<div class="viewcode-block" id="LRU_Cache.__call__"><a class="viewcode-back" href="../../api/ssapy.utils.LRU_Cache.html#ssapy.utils.LRU_Cache.__call__">[docs]</a>    <span class="k">def</span><span class="w"> </span><span class="fm">__call__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="o">*</span><span class="n">key</span><span class="p">):</span>
        <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">cache</span><span class="p">)</span> <span class="o">==</span> <span class="mi">0</span><span class="p">:</span>  <span class="c1"># useful to allow zero when profiling...</span>
            <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">user_function</span><span class="p">(</span><span class="o">*</span><span class="n">key</span><span class="p">)</span>
        <span class="n">cache</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">cache</span>
        <span class="n">root</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">root</span>
        <span class="n">link</span> <span class="o">=</span> <span class="n">cache</span><span class="o">.</span><span class="n">get</span><span class="p">(</span><span class="n">key</span><span class="p">)</span>
        <span class="k">if</span> <span class="n">link</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
            <span class="c1"># Cache hit: move link to last position</span>
            <span class="c1"># print(&quot;hit&quot;)</span>
            <span class="n">link_prev</span><span class="p">,</span> <span class="n">link_next</span><span class="p">,</span> <span class="n">_</span><span class="p">,</span> <span class="n">result</span> <span class="o">=</span> <span class="n">link</span>
            <span class="n">link_prev</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span> <span class="o">=</span> <span class="n">link_next</span>
            <span class="n">link_next</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">=</span> <span class="n">link_prev</span>
            <span class="n">last</span> <span class="o">=</span> <span class="n">root</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span>
            <span class="n">last</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span> <span class="o">=</span> <span class="n">root</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">=</span> <span class="n">link</span>
            <span class="n">link</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">=</span> <span class="n">last</span>
            <span class="n">link</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span> <span class="o">=</span> <span class="n">root</span>
            <span class="k">return</span> <span class="n">result</span>
        <span class="c1"># Cache miss: evaluate and insert new key/value at root, then increment root</span>
        <span class="c1">#             so that just-evaluated value is in last position.</span>
        <span class="c1"># print(&quot;miss&quot;)</span>
        <span class="n">result</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">user_function</span><span class="p">(</span><span class="o">*</span><span class="n">key</span><span class="p">)</span>
        <span class="n">root</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">root</span>  <span class="c1"># re-establish root in case user_function modified it due to recursion</span>
        <span class="n">root</span><span class="p">[</span><span class="mi">2</span><span class="p">]</span> <span class="o">=</span> <span class="n">key</span>
        <span class="n">root</span><span class="p">[</span><span class="mi">3</span><span class="p">]</span> <span class="o">=</span> <span class="n">result</span>
        <span class="n">oldroot</span> <span class="o">=</span> <span class="n">root</span>
        <span class="n">root</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">root</span> <span class="o">=</span> <span class="n">root</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span>
        <span class="n">root</span><span class="p">[</span><span class="mi">2</span><span class="p">],</span> <span class="n">oldkey</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span> <span class="n">root</span><span class="p">[</span><span class="mi">2</span><span class="p">]</span>
        <span class="n">root</span><span class="p">[</span><span class="mi">3</span><span class="p">],</span> <span class="n">_</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span> <span class="n">root</span><span class="p">[</span><span class="mi">3</span><span class="p">]</span>
        <span class="k">del</span> <span class="n">cache</span><span class="p">[</span><span class="n">oldkey</span><span class="p">]</span>
        <span class="n">cache</span><span class="p">[</span><span class="n">key</span><span class="p">]</span> <span class="o">=</span> <span class="n">oldroot</span>
        <span class="k">return</span> <span class="n">result</span></div>

<div class="viewcode-block" id="LRU_Cache.resize"><a class="viewcode-back" href="../../api/ssapy.utils.LRU_Cache.html#ssapy.utils.LRU_Cache.resize">[docs]</a>    <span class="k">def</span><span class="w"> </span><span class="nf">resize</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">maxsize</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;Resize the cache.</span>

<span class="sd">        Increasing the size of the cache is non-destructive, i.e., previously cached inputs remain</span>
<span class="sd">        in the cache.  Decreasing the size of the cache will necessarily remove items from the</span>
<span class="sd">        cache if the cache is already filled.  Items are removed in least recently used order.</span>

<span class="sd">        Parameters:</span>
<span class="sd">            maxsize:    The new maximum number of inputs to cache.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">oldsize</span> <span class="o">=</span> <span class="nb">len</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">cache</span><span class="p">)</span>
        <span class="k">if</span> <span class="n">maxsize</span> <span class="o">==</span> <span class="n">oldsize</span><span class="p">:</span>
            <span class="k">return</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">root</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">root</span>
            <span class="n">cache</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">cache</span>
            <span class="k">if</span> <span class="n">maxsize</span> <span class="o">&lt;</span> <span class="mi">0</span><span class="p">:</span>
                <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s2">&quot;Invalid maxsize&quot;</span><span class="p">,</span> <span class="n">maxsize</span><span class="p">)</span>
            <span class="k">if</span> <span class="n">maxsize</span> <span class="o">&lt;</span> <span class="n">oldsize</span><span class="p">:</span>
                <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">oldsize</span> <span class="o">-</span> <span class="n">maxsize</span><span class="p">):</span>
                    <span class="c1"># Delete root.next</span>
                    <span class="n">current_next_link</span> <span class="o">=</span> <span class="n">root</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span>
                    <span class="n">new_next_link</span> <span class="o">=</span> <span class="n">root</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span> <span class="o">=</span> <span class="n">root</span><span class="p">[</span><span class="mi">1</span><span class="p">][</span><span class="mi">1</span><span class="p">]</span>
                    <span class="n">new_next_link</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">=</span> <span class="n">root</span>
                    <span class="k">del</span> <span class="n">cache</span><span class="p">[</span><span class="n">current_next_link</span><span class="p">[</span><span class="mi">2</span><span class="p">]]</span>
            <span class="k">else</span><span class="p">:</span>  <span class="c1"># maxsize &gt; oldsize:</span>
                <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">maxsize</span> <span class="o">-</span> <span class="n">oldsize</span><span class="p">):</span>
                    <span class="c1"># Insert between root and root.next</span>
                    <span class="n">key</span> <span class="o">=</span> <span class="nb">object</span><span class="p">()</span>
                    <span class="n">cache</span><span class="p">[</span><span class="n">key</span><span class="p">]</span> <span class="o">=</span> <span class="n">link</span> <span class="o">=</span> <span class="p">[</span><span class="n">root</span><span class="p">,</span> <span class="n">root</span><span class="p">[</span><span class="mi">1</span><span class="p">],</span> <span class="n">key</span><span class="p">,</span> <span class="kc">None</span><span class="p">]</span>
                    <span class="n">root</span><span class="p">[</span><span class="mi">1</span><span class="p">][</span><span class="mi">0</span><span class="p">]</span> <span class="o">=</span> <span class="n">link</span>
                    <span class="n">root</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span> <span class="o">=</span> <span class="n">link</span></div></div>


<div class="viewcode-block" id="catalog_to_apparent"><a class="viewcode-back" href="../../api/ssapy.utils.catalog_to_apparent.html#ssapy.utils.catalog_to_apparent">[docs]</a><span class="k">def</span><span class="w"> </span><span class="nf">catalog_to_apparent</span><span class="p">(</span>
    <span class="n">ra</span><span class="p">,</span> <span class="n">dec</span><span class="p">,</span> <span class="n">t</span><span class="p">,</span> <span class="n">observer</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">pmra</span><span class="o">=</span><span class="mi">0</span><span class="p">,</span> <span class="n">pmdec</span><span class="o">=</span><span class="mi">0</span><span class="p">,</span> <span class="n">parallax</span><span class="o">=</span><span class="mi">0</span><span class="p">,</span>
    <span class="n">skipAberration</span><span class="o">=</span><span class="kc">False</span>
<span class="p">):</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Convert ra/dec of stars from catalog positions (J2000/ICRS) to apparent</span>
<span class="sd">    positions, correcting for proper motion, parallax, annual and diurnal</span>
<span class="sd">    aberration.</span>

<span class="sd">    Parameters</span>
<span class="sd">    ----------</span>
<span class="sd">    ra : array_like</span>
<span class="sd">        J2000 right ascension in radians.</span>
<span class="sd">    dec : array_like</span>
<span class="sd">        J2000 declination in radians.</span>
<span class="sd">    t : float or astropy.time.Time</span>
<span class="sd">        If float, then should correspond to GPS seconds; i.e., seconds since</span>
<span class="sd">        1980-01-06 00:00:00 UTC</span>
<span class="sd">    observer : Observer, optional</span>
<span class="sd">        Observer to use for diurnal aberration correction.  If None, then no</span>
<span class="sd">        diurnal aberration correction is performed.</span>
<span class="sd">    pmra, pmdec : array_like, optional</span>
<span class="sd">        proper motion in right ascension / declination, in milliarcsec per year</span>
<span class="sd">    parallax : array_like, optional</span>
<span class="sd">        annual parallax in arcseconds</span>
<span class="sd">    skipAberration : bool, optional</span>
<span class="sd">        Don&#39;t apply aberration correction.  Mostly useful during testing...</span>

<span class="sd">    Returns</span>
<span class="sd">    -------</span>
<span class="sd">    ara, adec : array_like</span>
<span class="sd">        Apparent RA and dec in radians</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="kn">from</span><span class="w"> </span><span class="nn">astropy.coordinates</span><span class="w"> </span><span class="kn">import</span> <span class="n">get_body_barycentric_posvel</span>
    <span class="kn">from</span><span class="w"> </span><span class="nn">astropy.time</span><span class="w"> </span><span class="kn">import</span> <span class="n">Time</span>
    <span class="kn">import</span><span class="w"> </span><span class="nn">astropy.units</span><span class="w"> </span><span class="k">as</span><span class="w"> </span><span class="nn">u</span>

    <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">t</span><span class="p">,</span> <span class="n">Time</span><span class="p">):</span>
        <span class="n">tTime</span> <span class="o">=</span> <span class="n">t</span>
        <span class="n">t</span> <span class="o">=</span> <span class="n">t</span><span class="o">.</span><span class="n">gps</span>
    <span class="k">else</span><span class="p">:</span>
        <span class="n">tTime</span> <span class="o">=</span> <span class="n">Time</span><span class="p">(</span><span class="n">t</span><span class="p">,</span> <span class="nb">format</span><span class="o">=</span><span class="s1">&#39;gps&#39;</span><span class="p">)</span>

    <span class="c1"># Code below modeled after SOFA iauPmpx, iauAb routines, but a bit simpler</span>
    <span class="c1"># since SSA requirements are only ~arcsec or so.</span>
    <span class="c1"># aulty = (u.au / (299792458 * u.m / u.s)).to(u.year).value</span>
    <span class="c1"># SOFA is the Standards of Fundamental Astronomy.</span>
    <span class="n">obsPos</span><span class="p">,</span> <span class="n">obsVel</span> <span class="o">=</span> <span class="n">get_body_barycentric_posvel</span><span class="p">(</span><span class="s1">&#39;earth&#39;</span><span class="p">,</span> <span class="n">tTime</span><span class="p">)</span>
    <span class="n">pob</span> <span class="o">=</span> <span class="n">obsPos</span><span class="o">.</span><span class="n">xyz</span><span class="o">.</span><span class="n">to</span><span class="p">(</span><span class="n">u</span><span class="o">.</span><span class="n">AU</span><span class="p">)</span><span class="o">.</span><span class="n">value</span>
    <span class="n">vob</span> <span class="o">=</span> <span class="n">obsVel</span><span class="o">.</span><span class="n">xyz</span><span class="o">.</span><span class="n">to</span><span class="p">(</span><span class="n">u</span><span class="o">.</span><span class="n">m</span> <span class="o">/</span> <span class="n">u</span><span class="o">.</span><span class="n">s</span><span class="p">)</span><span class="o">.</span><span class="n">value</span>
    <span class="n">sr</span><span class="p">,</span> <span class="n">cr</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">sin</span><span class="p">(</span><span class="n">ra</span><span class="p">),</span> <span class="n">np</span><span class="o">.</span><span class="n">cos</span><span class="p">(</span><span class="n">ra</span><span class="p">)</span>
    <span class="n">sd</span><span class="p">,</span> <span class="n">cd</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">sin</span><span class="p">(</span><span class="n">dec</span><span class="p">),</span> <span class="n">np</span><span class="o">.</span><span class="n">cos</span><span class="p">(</span><span class="n">dec</span><span class="p">)</span>
    <span class="n">x</span> <span class="o">=</span> <span class="n">cr</span> <span class="o">*</span> <span class="n">cd</span>
    <span class="n">y</span> <span class="o">=</span> <span class="n">sr</span> <span class="o">*</span> <span class="n">cd</span>
    <span class="n">z</span> <span class="o">=</span> <span class="n">sd</span>
    <span class="n">p</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">([</span><span class="n">x</span><span class="p">,</span> <span class="n">y</span><span class="p">,</span> <span class="n">z</span><span class="p">])</span><span class="o">.</span><span class="n">T</span>
    <span class="n">dt</span> <span class="o">=</span> <span class="p">(</span><span class="n">t</span> <span class="o">-</span> <span class="n">Time</span><span class="p">(</span><span class="s2">&quot;J2000&quot;</span><span class="p">)</span><span class="o">.</span><span class="n">gps</span><span class="p">)</span> <span class="o">/</span> <span class="p">(</span><span class="mi">86400</span> <span class="o">*</span> <span class="mf">365.25</span><span class="p">)</span>
    <span class="n">pdrad</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">deg2rad</span><span class="p">(</span><span class="n">pmdec</span> <span class="o">/</span> <span class="p">(</span><span class="mi">1000</span> <span class="o">*</span> <span class="mi">3600</span><span class="p">))</span>
    <span class="n">prrad</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">deg2rad</span><span class="p">(</span><span class="n">pmra</span> <span class="o">/</span> <span class="p">(</span><span class="mi">1000</span> <span class="o">*</span> <span class="mi">3600</span><span class="p">))</span> <span class="o">/</span> <span class="n">cd</span>
    <span class="n">pxrad</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">deg2rad</span><span class="p">(</span><span class="n">parallax</span> <span class="o">/</span> <span class="mi">3600</span><span class="p">)</span>

    <span class="c1"># Proper motion and parallax</span>
    <span class="n">pdz</span> <span class="o">=</span> <span class="n">z</span> <span class="o">*</span> <span class="n">pdrad</span>
    <span class="n">pm</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">([</span>
        <span class="o">-</span><span class="n">prrad</span> <span class="o">*</span> <span class="n">y</span> <span class="o">-</span> <span class="n">pdz</span> <span class="o">*</span> <span class="n">cr</span><span class="p">,</span>
        <span class="n">prrad</span> <span class="o">*</span> <span class="n">x</span> <span class="o">-</span> <span class="n">pdz</span> <span class="o">*</span> <span class="n">sr</span><span class="p">,</span>
        <span class="n">pdrad</span> <span class="o">*</span> <span class="n">cd</span>
    <span class="p">])</span><span class="o">.</span><span class="n">T</span>
    <span class="n">p</span> <span class="o">+=</span> <span class="n">dt</span> <span class="o">*</span> <span class="n">pm</span> <span class="o">-</span> <span class="n">pxrad</span><span class="p">[</span><span class="o">...</span><span class="p">,</span> <span class="kc">None</span><span class="p">]</span> <span class="o">*</span> <span class="n">pob</span>
    <span class="n">p</span> <span class="o">=</span> <span class="n">normed</span><span class="p">(</span><span class="n">p</span><span class="p">)</span>

    <span class="c1"># Aberration</span>
    <span class="k">if</span> <span class="ow">not</span> <span class="n">skipAberration</span><span class="p">:</span>
        <span class="k">if</span> <span class="n">observer</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
            <span class="n">_</span><span class="p">,</span> <span class="n">dvob</span> <span class="o">=</span> <span class="n">observer</span><span class="o">.</span><span class="n">getRV</span><span class="p">(</span><span class="n">tTime</span><span class="p">)</span>
            <span class="n">vob</span> <span class="o">+=</span> <span class="n">dvob</span>
        <span class="n">p</span> <span class="o">+=</span> <span class="n">vob</span> <span class="o">/</span> <span class="mf">299792458.</span>
        <span class="n">p</span> <span class="o">=</span> <span class="n">normed</span><span class="p">(</span><span class="n">p</span><span class="p">)</span>

    <span class="n">ra</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">arctan2</span><span class="p">(</span><span class="n">p</span><span class="p">[:,</span> <span class="mi">1</span><span class="p">],</span> <span class="n">p</span><span class="p">[:,</span> <span class="mi">0</span><span class="p">])</span>
    <span class="n">dec</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">arcsin</span><span class="p">(</span><span class="n">p</span><span class="p">[:,</span> <span class="mi">2</span><span class="p">])</span>
    <span class="k">return</span> <span class="n">ra</span><span class="p">,</span> <span class="n">dec</span></div>


<div class="viewcode-block" id="rv_to_ntw"><a class="viewcode-back" href="../../api/ssapy.utils.rv_to_ntw.html#ssapy.utils.rv_to_ntw">[docs]</a><span class="k">def</span><span class="w"> </span><span class="nf">rv_to_ntw</span><span class="p">(</span><span class="n">r</span><span class="p">,</span> <span class="n">v</span><span class="p">,</span> <span class="n">rcoord</span><span class="p">):</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;Convert coordinates to NTW coordinates, using r, v to define NTW system.</span>

<span class="sd">    T gives the projection of (rcoord - r) along V  (tangent to track)</span>
<span class="sd">    W gives the projection of (rcoord - r) along (V cross r) (normal to plane)</span>
<span class="sd">    N gives the projection of (rcoord - r) along (V cross (V cross r))</span>
<span class="sd">        (in plane, perpendicular to T)</span>

<span class="sd">    Parameters</span>
<span class="sd">    ----------</span>
<span class="sd">    r : array_like (n, 3)</span>
<span class="sd">        central positions defining coordinate system</span>
<span class="sd">    v : array_like (n, 3)</span>
<span class="sd">        velocity defining coordinate system</span>
<span class="sd">    rcoord : array_like (n, 3)</span>
<span class="sd">        positions to transform to NTW coordinates</span>

<span class="sd">    Returns</span>
<span class="sd">    -------</span>
<span class="sd">    ntw : array_like (n, 3)</span>
<span class="sd">        n, t, w positions</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="k">def</span><span class="w"> </span><span class="nf">dot</span><span class="p">(</span><span class="n">x</span><span class="p">,</span> <span class="n">y</span><span class="p">):</span>
        <span class="k">return</span> <span class="n">np</span><span class="o">.</span><span class="n">einsum</span><span class="p">(</span><span class="s1">&#39;...i, ...i&#39;</span><span class="p">,</span> <span class="n">x</span><span class="p">,</span> <span class="n">y</span><span class="p">)</span>
    <span class="n">dr</span> <span class="o">=</span> <span class="n">rcoord</span> <span class="o">-</span> <span class="n">r</span>
    <span class="n">t</span> <span class="o">=</span> <span class="n">dot</span><span class="p">(</span><span class="n">normed</span><span class="p">(</span><span class="n">v</span><span class="p">),</span> <span class="n">dr</span><span class="p">)</span>
    <span class="n">w</span> <span class="o">=</span> <span class="n">dot</span><span class="p">(</span><span class="n">normed</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">cross</span><span class="p">(</span><span class="n">r</span><span class="p">,</span> <span class="n">v</span><span class="p">)),</span> <span class="n">dr</span><span class="p">)</span>
    <span class="n">n</span> <span class="o">=</span> <span class="n">dot</span><span class="p">(</span><span class="n">normed</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">cross</span><span class="p">(</span><span class="n">v</span><span class="p">,</span> <span class="n">np</span><span class="o">.</span><span class="n">cross</span><span class="p">(</span><span class="n">r</span><span class="p">,</span> <span class="n">v</span><span class="p">))),</span> <span class="n">dr</span><span class="p">)</span>
    <span class="k">return</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">([</span><span class="n">n</span><span class="p">,</span> <span class="n">t</span><span class="p">,</span> <span class="n">w</span><span class="p">])</span><span class="o">.</span><span class="n">T</span><span class="o">.</span><span class="n">copy</span><span class="p">()</span></div>


<div class="viewcode-block" id="ntw_to_r"><a class="viewcode-back" href="../../api/ssapy.utils.ntw_to_r.html#ssapy.utils.ntw_to_r">[docs]</a><span class="k">def</span><span class="w"> </span><span class="nf">ntw_to_r</span><span class="p">(</span><span class="n">r</span><span class="p">,</span> <span class="n">v</span><span class="p">,</span> <span class="n">ntw</span><span class="p">,</span> <span class="n">relative</span><span class="o">=</span><span class="kc">False</span><span class="p">):</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;Convert NTW coordinates to cartesian coordinates, using r, v to define</span>
<span class="sd">    NTW system.</span>

<span class="sd">    T gives the projection of (rcoord - r) along V  (tangent to track)</span>
<span class="sd">    W gives the projection of (rcoord - r) along (V cross r) (normal to plane)</span>
<span class="sd">    N gives the projection of (rcoord - r) along (V cross (V cross r))</span>
<span class="sd">        (in plane, perpendicular to T)</span>

<span class="sd">    Parameters</span>
<span class="sd">    ----------</span>
<span class="sd">    r : array_like (n, 3)</span>
<span class="sd">        central positions defining coordinate system</span>
<span class="sd">    v : array_like (n, 3)</span>
<span class="sd">        velocity defining coordinate system</span>
<span class="sd">    ntw : array_like (n, 3)</span>
<span class="sd">        ntw coordinates to transform to cartesian coordinates</span>
<span class="sd">    relative : bool</span>
<span class="sd">        if True, just rotate the NTW coordinates to Cartesian; do not offset</span>
<span class="sd">        the origin so that NTW = 0 -&gt; Cartesian r.</span>

<span class="sd">    Returns</span>
<span class="sd">    -------</span>
<span class="sd">    r : array_like (n, 3)</span>
<span class="sd">        cartesian x, y, z coordinates</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="n">tvec</span> <span class="o">=</span> <span class="n">normed</span><span class="p">(</span><span class="n">v</span><span class="p">)</span>
    <span class="n">wvec</span> <span class="o">=</span> <span class="n">normed</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">cross</span><span class="p">(</span><span class="n">r</span><span class="p">,</span> <span class="n">v</span><span class="p">))</span>
    <span class="n">nvec</span> <span class="o">=</span> <span class="n">normed</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">cross</span><span class="p">(</span><span class="n">tvec</span><span class="p">,</span> <span class="n">wvec</span><span class="p">))</span>
    <span class="n">mat</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">([</span><span class="n">nvec</span><span class="p">,</span> <span class="n">tvec</span><span class="p">,</span> <span class="n">wvec</span><span class="p">])</span>
    <span class="n">ret</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">dot</span><span class="p">(</span><span class="n">ntw</span><span class="p">,</span> <span class="n">mat</span><span class="p">)</span>
    <span class="k">if</span> <span class="ow">not</span> <span class="n">relative</span><span class="p">:</span>
        <span class="n">ret</span> <span class="o">+=</span> <span class="n">r</span>
    <span class="k">return</span> <span class="n">ret</span></div>


<div class="viewcode-block" id="lb_to_tp"><a class="viewcode-back" href="../../api/ssapy.utils.lb_to_tp.html#ssapy.utils.lb_to_tp">[docs]</a><span class="k">def</span><span class="w"> </span><span class="nf">lb_to_tp</span><span class="p">(</span><span class="n">lb</span><span class="p">,</span> <span class="n">b</span><span class="p">):</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;Convert lb-like coordinates to theta-phi like coordinates.</span>

<span class="sd">    Here &#39;theta-phi&#39; coordinates refers to the system where theta is the</span>
<span class="sd">    angle between zenith and the point in question, and phi is the</span>
<span class="sd">    corresponding azimuthal angle.</span>

<span class="sd">    This just sets theta = pi - b and renames lb -&gt; phi.  Everything is in</span>
<span class="sd">    radians.</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="k">return</span> <span class="n">np</span><span class="o">.</span><span class="n">pi</span> <span class="o">/</span> <span class="mi">2</span> <span class="o">-</span> <span class="n">b</span><span class="p">,</span> <span class="n">lb</span> <span class="o">%</span> <span class="p">(</span><span class="mi">2</span> <span class="o">*</span> <span class="n">np</span><span class="o">.</span><span class="n">pi</span><span class="p">)</span></div>


<div class="viewcode-block" id="tp_to_lb"><a class="viewcode-back" href="../../api/ssapy.utils.tp_to_lb.html#ssapy.utils.tp_to_lb">[docs]</a><span class="k">def</span><span class="w"> </span><span class="nf">tp_to_lb</span><span class="p">(</span><span class="n">t</span><span class="p">,</span> <span class="n">p</span><span class="p">):</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;Convert theta-phi-like coordinates to lb-like coordinates.</span>

<span class="sd">    Here &#39;theta-phi&#39; coordinates refers to the system where theta is the</span>
<span class="sd">    angle between zenith and the point in question, and phi is the</span>
<span class="sd">    corresponding azimuthal angle.</span>

<span class="sd">    This just sets b = pi - theta and renames phi -&gt; lb.  Everything is in</span>
<span class="sd">    radians.</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="k">return</span> <span class="n">p</span> <span class="o">%</span> <span class="p">(</span><span class="mi">2</span> <span class="o">*</span> <span class="n">np</span><span class="o">.</span><span class="n">pi</span><span class="p">),</span> <span class="n">np</span><span class="o">.</span><span class="n">pi</span> <span class="o">/</span> <span class="mi">2</span> <span class="o">-</span> <span class="n">t</span></div>


<div class="viewcode-block" id="tp_to_unit"><a class="viewcode-back" href="../../api/ssapy.utils.tp_to_unit.html#ssapy.utils.tp_to_unit">[docs]</a><span class="k">def</span><span class="w"> </span><span class="nf">tp_to_unit</span><span class="p">(</span><span class="n">t</span><span class="p">,</span> <span class="n">p</span><span class="p">):</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;Convert theta-phi-like coordinates to unit vectors.</span>

<span class="sd">    Here &#39;theta-phi&#39; coordinates refers to the system where theta is the</span>
<span class="sd">    angle between zenith and the point in question, and phi is the</span>
<span class="sd">    corresponding azimuthal angle.</span>

<span class="sd">    Everything is in radians.</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="n">z</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">cos</span><span class="p">(</span><span class="n">t</span><span class="p">)</span>
    <span class="n">x</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">cos</span><span class="p">(</span><span class="n">p</span><span class="p">)</span> <span class="o">*</span> <span class="n">np</span><span class="o">.</span><span class="n">sin</span><span class="p">(</span><span class="n">t</span><span class="p">)</span>
    <span class="n">y</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">sin</span><span class="p">(</span><span class="n">p</span><span class="p">)</span> <span class="o">*</span> <span class="n">np</span><span class="o">.</span><span class="n">sin</span><span class="p">(</span><span class="n">t</span><span class="p">)</span>
    <span class="k">return</span> <span class="n">np</span><span class="o">.</span><span class="n">concatenate</span><span class="p">([</span><span class="n">q</span><span class="p">[</span><span class="o">...</span><span class="p">,</span> <span class="n">np</span><span class="o">.</span><span class="n">newaxis</span><span class="p">]</span> <span class="k">for</span> <span class="n">q</span> <span class="ow">in</span> <span class="p">(</span><span class="n">x</span><span class="p">,</span> <span class="n">y</span><span class="p">,</span> <span class="n">z</span><span class="p">)],</span> <span class="n">axis</span><span class="o">=-</span><span class="mi">1</span><span class="p">)</span></div>


<div class="viewcode-block" id="lb_to_unit"><a class="viewcode-back" href="../../api/ssapy.utils.lb_to_unit.html#ssapy.utils.lb_to_unit">[docs]</a><span class="k">def</span><span class="w"> </span><span class="nf">lb_to_unit</span><span class="p">(</span><span class="n">r</span><span class="p">,</span> <span class="n">d</span><span class="p">):</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;Convert lb-like coordinates to unit vectors.</span>

<span class="sd">    Everything is in radians.</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="k">return</span> <span class="n">tp_to_unit</span><span class="p">(</span><span class="o">*</span><span class="n">lb_to_tp</span><span class="p">(</span><span class="n">r</span><span class="p">,</span> <span class="n">d</span><span class="p">))</span></div>


<div class="viewcode-block" id="unit_to_tp"><a class="viewcode-back" href="../../api/ssapy.utils.unit_to_tp.html#ssapy.utils.unit_to_tp">[docs]</a><span class="k">def</span><span class="w"> </span><span class="nf">unit_to_tp</span><span class="p">(</span><span class="n">unit</span><span class="p">):</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;Convert unit vectors to theta-phi-like coordinates.</span>

<span class="sd">    Here &#39;theta-phi&#39; coordinates refers to the system where theta is the</span>
<span class="sd">    angle between zenith and the point in question, and phi is the</span>
<span class="sd">    corresponding azimuthal angle.</span>

<span class="sd">    Everything is in radians.</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="n">norm</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">sqrt</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">sum</span><span class="p">(</span><span class="n">unit</span><span class="o">**</span><span class="mf">2.</span><span class="p">,</span> <span class="n">axis</span><span class="o">=-</span><span class="mi">1</span><span class="p">))</span>
    <span class="n">unit</span> <span class="o">=</span> <span class="n">unit</span> <span class="o">/</span> <span class="n">norm</span><span class="p">[</span><span class="o">...</span><span class="p">,</span> <span class="kc">None</span><span class="p">]</span>
    <span class="n">t</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">arccos</span><span class="p">(</span><span class="n">unit</span><span class="p">[</span><span class="o">...</span><span class="p">,</span> <span class="mi">2</span><span class="p">])</span>
    <span class="n">p</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">arctan2</span><span class="p">(</span><span class="n">unit</span><span class="p">[</span><span class="o">...</span><span class="p">,</span> <span class="mi">1</span><span class="p">],</span> <span class="n">unit</span><span class="p">[</span><span class="o">...</span><span class="p">,</span> <span class="mi">0</span><span class="p">])</span>
    <span class="k">return</span> <span class="n">t</span><span class="p">,</span> <span class="n">p</span> <span class="o">%</span> <span class="p">(</span><span class="mi">2</span> <span class="o">*</span> <span class="n">np</span><span class="o">.</span><span class="n">pi</span><span class="p">)</span></div>


<div class="viewcode-block" id="xyz_to_tp"><a class="viewcode-back" href="../../api/ssapy.utils.xyz_to_tp.html#ssapy.utils.xyz_to_tp">[docs]</a><span class="k">def</span><span class="w"> </span><span class="nf">xyz_to_tp</span><span class="p">(</span><span class="n">x</span><span class="p">,</span> <span class="n">y</span><span class="p">,</span> <span class="n">z</span><span class="p">):</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;Convert x, y, z vectors to theta-phi-like coordinates.</span>

<span class="sd">    Here &#39;theta-phi&#39; coordinates refers to the system where theta is the</span>
<span class="sd">    angle between zenith and the point in question, and phi is the</span>
<span class="sd">    corresponding azimuthal angle.</span>

<span class="sd">    Everything is in radians.</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="n">norm</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">sqrt</span><span class="p">(</span><span class="n">x</span><span class="o">**</span><span class="mi">2</span> <span class="o">+</span> <span class="n">y</span><span class="o">**</span><span class="mi">2</span> <span class="o">+</span> <span class="n">z</span><span class="o">**</span><span class="mi">2</span><span class="p">)</span>
    <span class="n">t</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">arccos</span><span class="p">(</span><span class="n">z</span> <span class="o">/</span> <span class="n">norm</span><span class="p">)</span>
    <span class="n">p</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">arctan2</span><span class="p">(</span><span class="n">y</span> <span class="o">/</span> <span class="n">norm</span><span class="p">,</span> <span class="n">x</span> <span class="o">/</span> <span class="n">norm</span><span class="p">)</span>
    <span class="k">return</span> <span class="n">t</span><span class="p">,</span> <span class="n">p</span> <span class="o">%</span> <span class="p">(</span><span class="mi">2</span> <span class="o">*</span> <span class="n">np</span><span class="o">.</span><span class="n">pi</span><span class="p">)</span></div>


<div class="viewcode-block" id="unit_to_lb"><a class="viewcode-back" href="../../api/ssapy.utils.unit_to_lb.html#ssapy.utils.unit_to_lb">[docs]</a><span class="k">def</span><span class="w"> </span><span class="nf">unit_to_lb</span><span class="p">(</span><span class="n">unit</span><span class="p">):</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;Convert unit vectors to lb-like coordinates.</span>

<span class="sd">    Everything is in radians.</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="k">return</span> <span class="n">tp_to_lb</span><span class="p">(</span><span class="o">*</span><span class="n">unit_to_tp</span><span class="p">(</span><span class="n">unit</span><span class="p">))</span></div>


<div class="viewcode-block" id="xyz_to_lb"><a class="viewcode-back" href="../../api/ssapy.utils.xyz_to_lb.html#ssapy.utils.xyz_to_lb">[docs]</a><span class="k">def</span><span class="w"> </span><span class="nf">xyz_to_lb</span><span class="p">(</span><span class="n">x</span><span class="p">,</span> <span class="n">y</span><span class="p">,</span> <span class="n">z</span><span class="p">):</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;Convert x, y, z vectors to lb-like coordinates.</span>

<span class="sd">    Everything is in radians.</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="k">return</span> <span class="n">tp_to_lb</span><span class="p">(</span><span class="o">*</span><span class="n">xyz_to_tp</span><span class="p">(</span><span class="n">x</span><span class="p">,</span> <span class="n">y</span><span class="p">,</span> <span class="n">z</span><span class="p">))</span></div>


<div class="viewcode-block" id="lb_to_tan"><a class="viewcode-back" href="../../api/ssapy.utils.lb_to_tan.html#ssapy.utils.lb_to_tan">[docs]</a><span class="k">def</span><span class="w"> </span><span class="nf">lb_to_tan</span><span class="p">(</span><span class="n">lb</span><span class="p">,</span> <span class="n">b</span><span class="p">,</span> <span class="n">mul</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">mub</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">lcen</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">bcen</span><span class="o">=</span><span class="kc">None</span><span class="p">):</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;Convert lb-like coordinates &amp; proper motions to orthographic tangent plane.</span>

<span class="sd">    All units are in radians.  If mul is None (default), transformed</span>
<span class="sd">    proper motions will not be returned.  The tangent plane is always chosen</span>
<span class="sd">    so that +Y is towards b = 90, and +X is towards +lb.</span>

<span class="sd">    Parameters</span>
<span class="sd">    ----------</span>
<span class="sd">    lb : array_like (n)</span>
<span class="sd">        right ascension of point</span>
<span class="sd">    b : array_like (n)</span>
<span class="sd">        declination of point</span>
<span class="sd">    mul : array_like (n)</span>
<span class="sd">        proper motion in ra of point (arbitrary units)</span>
<span class="sd">        rate of change in lb is mul / np.cos(b); i.e., length of proper motion</span>
<span class="sd">        vector on sphere is np.hypot(mul, mub)</span>
<span class="sd">    mub : array_like (n)</span>
<span class="sd">        proper motion in dec of point (arbitrary units)</span>
<span class="sd">    lcen : array_like (n)</span>
<span class="sd">        right ascension to use for center of tangent plane</span>
<span class="sd">        if None, use spherical mean of (lb, b)</span>
<span class="sd">    bcen : array_like (n)</span>
<span class="sd">        declination to use for center of tangent plane</span>

<span class="sd">    Returns</span>
<span class="sd">    -------</span>
<span class="sd">    if mul is None, (x, y) otherwise (x, y, vx, vy)</span>
<span class="sd">    x : array_like (n)</span>
<span class="sd">        x coordinate of tangent plane projection of lb, b</span>
<span class="sd">    y : array_like (n)</span>
<span class="sd">        y coordinate of tangent plane projection of lb, b</span>
<span class="sd">    vx : array_like (n)</span>
<span class="sd">        x coordinate of tangent plane projection of (mul, mub)</span>
<span class="sd">    vy : array_like (n)</span>
<span class="sd">        y coordinate of tangent plane projection of (mul, mub)</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="n">up</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">([</span><span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">1</span><span class="p">])</span>
    <span class="n">unit</span> <span class="o">=</span> <span class="n">lb_to_unit</span><span class="p">(</span><span class="n">lb</span><span class="p">,</span> <span class="n">b</span><span class="p">)</span>
    <span class="k">if</span> <span class="n">lcen</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
        <span class="n">lcen</span><span class="p">,</span> <span class="n">bcen</span> <span class="o">=</span> <span class="n">unit_to_lb</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">mean</span><span class="p">(</span><span class="n">unit</span><span class="p">,</span> <span class="n">axis</span><span class="o">=</span><span class="mi">0</span><span class="p">)</span><span class="o">.</span><span class="n">reshape</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span> <span class="o">-</span><span class="mi">1</span><span class="p">))</span>
    <span class="n">unitcen</span> <span class="o">=</span> <span class="n">lb_to_unit</span><span class="p">(</span><span class="n">lcen</span><span class="p">,</span> <span class="n">bcen</span><span class="p">)</span>
    <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">unitcen</span><span class="o">.</span><span class="n">shape</span><span class="p">)</span> <span class="o">==</span> <span class="mi">1</span><span class="p">:</span>
        <span class="n">unitcen</span> <span class="o">=</span> <span class="n">unitcen</span><span class="p">[</span><span class="kc">None</span><span class="p">,</span> <span class="p">:]</span>
    <span class="n">rahat</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">cross</span><span class="p">(</span><span class="n">up</span><span class="p">,</span> <span class="n">unitcen</span><span class="p">)</span>
    <span class="n">m</span> <span class="o">=</span> <span class="n">norm</span><span class="p">(</span><span class="n">rahat</span><span class="p">)</span> <span class="o">&lt;</span> <span class="mf">1e-10</span>
    <span class="n">rahat</span><span class="p">[</span><span class="n">m</span><span class="p">,</span> <span class="p">:]</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">([</span><span class="mi">1</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">])[</span><span class="kc">None</span><span class="p">,</span> <span class="p">:]</span>
    <span class="n">rahat</span> <span class="o">/=</span> <span class="n">np</span><span class="o">.</span><span class="n">sqrt</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">sum</span><span class="p">(</span><span class="n">rahat</span><span class="o">**</span><span class="mi">2</span><span class="p">,</span> <span class="n">axis</span><span class="o">=</span><span class="mi">1</span><span class="p">,</span> <span class="n">keepdims</span><span class="o">=</span><span class="kc">True</span><span class="p">))</span>
    <span class="n">dechat</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">cross</span><span class="p">(</span><span class="n">unitcen</span><span class="p">,</span> <span class="n">rahat</span><span class="p">)</span>
    <span class="n">dechat</span> <span class="o">/=</span> <span class="n">np</span><span class="o">.</span><span class="n">sqrt</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">sum</span><span class="p">(</span><span class="n">dechat</span><span class="o">**</span><span class="mi">2</span><span class="p">,</span> <span class="n">axis</span><span class="o">=</span><span class="mi">1</span><span class="p">,</span> <span class="n">keepdims</span><span class="o">=</span><span class="kc">True</span><span class="p">))</span>
    <span class="n">xx</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">sum</span><span class="p">(</span><span class="n">rahat</span> <span class="o">*</span> <span class="n">unit</span><span class="p">,</span> <span class="n">axis</span><span class="o">=</span><span class="mi">1</span><span class="p">)</span>
    <span class="n">yy</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">sum</span><span class="p">(</span><span class="n">dechat</span> <span class="o">*</span> <span class="n">unit</span><span class="p">,</span> <span class="n">axis</span><span class="o">=</span><span class="mi">1</span><span class="p">)</span>
    <span class="n">res</span> <span class="o">=</span> <span class="p">(</span><span class="n">xx</span><span class="p">,</span> <span class="n">yy</span><span class="p">)</span>
    <span class="k">if</span> <span class="n">mul</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
        <span class="n">rahat2</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">cross</span><span class="p">(</span><span class="n">up</span><span class="p">,</span> <span class="n">unit</span><span class="p">)</span>
        <span class="n">rahat2</span> <span class="o">/=</span> <span class="n">np</span><span class="o">.</span><span class="n">sqrt</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">sum</span><span class="p">(</span><span class="n">rahat2</span><span class="o">**</span><span class="mi">2</span><span class="p">,</span> <span class="n">axis</span><span class="o">=</span><span class="mi">1</span><span class="p">,</span> <span class="n">keepdims</span><span class="o">=</span><span class="kc">True</span><span class="p">))</span>
        <span class="n">dechat2</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">cross</span><span class="p">(</span><span class="n">unit</span><span class="p">,</span> <span class="n">rahat2</span><span class="p">)</span>
        <span class="n">dechat2</span> <span class="o">/=</span> <span class="n">np</span><span class="o">.</span><span class="n">sqrt</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">sum</span><span class="p">(</span><span class="n">dechat2</span><span class="o">**</span><span class="mi">2</span><span class="p">,</span> <span class="n">axis</span><span class="o">=</span><span class="mi">1</span><span class="p">,</span> <span class="n">keepdims</span><span class="o">=</span><span class="kc">True</span><span class="p">))</span>
        <span class="n">vv</span> <span class="o">=</span> <span class="n">mul</span><span class="p">[:,</span> <span class="kc">None</span><span class="p">]</span> <span class="o">*</span> <span class="n">rahat2</span> <span class="o">+</span> <span class="n">mub</span><span class="p">[:,</span> <span class="kc">None</span><span class="p">]</span> <span class="o">*</span> <span class="n">dechat2</span>
        <span class="n">vx</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">sum</span><span class="p">(</span><span class="n">rahat</span> <span class="o">*</span> <span class="n">vv</span><span class="p">,</span> <span class="n">axis</span><span class="o">=</span><span class="mi">1</span><span class="p">)</span>
        <span class="n">vy</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">sum</span><span class="p">(</span><span class="n">dechat</span> <span class="o">*</span> <span class="n">vv</span><span class="p">,</span> <span class="n">axis</span><span class="o">=</span><span class="mi">1</span><span class="p">)</span>
        <span class="n">rr</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">hypot</span><span class="p">(</span><span class="n">xx</span><span class="p">,</span> <span class="n">yy</span><span class="p">)</span>
        <span class="n">m</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">abs</span><span class="p">(</span><span class="n">rr</span><span class="p">)</span> <span class="o">&gt;</span> <span class="mf">1e-9</span>
        <span class="n">vr</span> <span class="o">=</span> <span class="p">(</span><span class="n">vx</span><span class="p">[</span><span class="n">m</span><span class="p">]</span> <span class="o">*</span> <span class="n">xx</span><span class="p">[</span><span class="n">m</span><span class="p">]</span> <span class="o">+</span> <span class="n">vy</span><span class="p">[</span><span class="n">m</span><span class="p">]</span> <span class="o">*</span> <span class="n">yy</span><span class="p">[</span><span class="n">m</span><span class="p">])</span> <span class="o">/</span> <span class="n">rr</span><span class="p">[</span><span class="n">m</span><span class="p">]</span>
        <span class="n">va</span> <span class="o">=</span> <span class="p">(</span><span class="n">vy</span><span class="p">[</span><span class="n">m</span><span class="p">]</span> <span class="o">*</span> <span class="n">xx</span><span class="p">[</span><span class="n">m</span><span class="p">]</span> <span class="o">-</span> <span class="n">vx</span><span class="p">[</span><span class="n">m</span><span class="p">]</span> <span class="o">*</span> <span class="n">yy</span><span class="p">[</span><span class="n">m</span><span class="p">])</span> <span class="o">/</span> <span class="n">rr</span><span class="p">[</span><span class="n">m</span><span class="p">]</span>
        <span class="n">vr</span> <span class="o">/=</span> <span class="n">np</span><span class="o">.</span><span class="n">sum</span><span class="p">(</span><span class="n">unitcen</span><span class="p">[</span><span class="n">m</span><span class="p">,</span> <span class="p">:]</span> <span class="o">*</span> <span class="n">unit</span><span class="p">[</span><span class="n">m</span><span class="p">,</span> <span class="p">:],</span> <span class="n">axis</span><span class="o">=</span><span class="mi">1</span><span class="p">)</span>
        <span class="n">vx</span><span class="p">[</span><span class="n">m</span><span class="p">]</span> <span class="o">=</span> <span class="n">vr</span> <span class="o">*</span> <span class="n">xx</span><span class="p">[</span><span class="n">m</span><span class="p">]</span> <span class="o">/</span> <span class="n">rr</span><span class="p">[</span><span class="n">m</span><span class="p">]</span> <span class="o">-</span> <span class="n">va</span> <span class="o">*</span> <span class="n">yy</span><span class="p">[</span><span class="n">m</span><span class="p">]</span> <span class="o">/</span> <span class="n">rr</span><span class="p">[</span><span class="n">m</span><span class="p">]</span>
        <span class="n">vy</span><span class="p">[</span><span class="n">m</span><span class="p">]</span> <span class="o">=</span> <span class="n">vr</span> <span class="o">*</span> <span class="n">yy</span><span class="p">[</span><span class="n">m</span><span class="p">]</span> <span class="o">/</span> <span class="n">rr</span><span class="p">[</span><span class="n">m</span><span class="p">]</span> <span class="o">+</span> <span class="n">va</span> <span class="o">*</span> <span class="n">xx</span><span class="p">[</span><span class="n">m</span><span class="p">]</span> <span class="o">/</span> <span class="n">rr</span><span class="p">[</span><span class="n">m</span><span class="p">]</span>
        <span class="n">res</span> <span class="o">=</span> <span class="n">res</span> <span class="o">+</span> <span class="p">(</span><span class="n">vx</span><span class="p">,</span> <span class="n">vy</span><span class="p">)</span>
    <span class="k">return</span> <span class="n">res</span></div>


<div class="viewcode-block" id="tan_to_lb"><a class="viewcode-back" href="../../api/ssapy.utils.tan_to_lb.html#ssapy.utils.tan_to_lb">[docs]</a><span class="k">def</span><span class="w"> </span><span class="nf">tan_to_lb</span><span class="p">(</span><span class="n">xx</span><span class="p">,</span> <span class="n">yy</span><span class="p">,</span> <span class="n">lcen</span><span class="p">,</span> <span class="n">bcen</span><span class="p">):</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;Convert orthographic tangent plane coordinates to lb coordinates.</span>

<span class="sd">    Parameters</span>
<span class="sd">    ----------</span>
<span class="sd">    xx : array_like (n)</span>
<span class="sd">        tangent plane x coordinate (radians)</span>
<span class="sd">    yy : array_like (n)</span>
<span class="sd">        targent plane y coordinate (radians</span>
<span class="sd">    lcen : float, array_like (n)</span>
<span class="sd">        right ascension of center of tangent plane</span>
<span class="sd">    bcen : float, array_linke (n)</span>
<span class="sd">        declination of center of tangent plane</span>

<span class="sd">    Returns</span>
<span class="sd">    -------</span>
<span class="sd">    lb : array_like (n)</span>
<span class="sd">        right ascension corresponding to xx, yy</span>
<span class="sd">    b : array_like (n)</span>
<span class="sd">        declination corresponding to xx, yy</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="n">unitcen</span> <span class="o">=</span> <span class="n">lb_to_unit</span><span class="p">(</span><span class="n">lcen</span><span class="p">,</span> <span class="n">bcen</span><span class="p">)</span>
    <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">unitcen</span><span class="o">.</span><span class="n">shape</span><span class="p">)</span> <span class="o">==</span> <span class="mi">1</span><span class="p">:</span>
        <span class="n">unitcen</span> <span class="o">=</span> <span class="n">unitcen</span><span class="p">[</span><span class="kc">None</span><span class="p">,</span> <span class="p">:]</span>
    <span class="n">up</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">([</span><span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">1</span><span class="p">])</span>
    <span class="n">rahat</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">cross</span><span class="p">(</span><span class="n">up</span><span class="p">,</span> <span class="n">unitcen</span><span class="p">)</span>
    <span class="n">m</span> <span class="o">=</span> <span class="n">norm</span><span class="p">(</span><span class="n">rahat</span><span class="p">)</span> <span class="o">&lt;</span> <span class="mf">1e-10</span>
    <span class="n">rahat</span><span class="p">[</span><span class="n">m</span><span class="p">,</span> <span class="p">:]</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">([</span><span class="mi">1</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">])[</span><span class="kc">None</span><span class="p">,</span> <span class="p">:]</span>
    <span class="n">rahat</span> <span class="o">/=</span> <span class="n">np</span><span class="o">.</span><span class="n">sqrt</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">sum</span><span class="p">(</span><span class="n">rahat</span><span class="o">**</span><span class="mi">2</span><span class="p">,</span> <span class="n">axis</span><span class="o">=</span><span class="mi">1</span><span class="p">,</span> <span class="n">keepdims</span><span class="o">=</span><span class="kc">True</span><span class="p">))</span>
    <span class="n">dechat</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">cross</span><span class="p">(</span><span class="n">unitcen</span><span class="p">,</span> <span class="n">rahat</span><span class="p">)</span>
    <span class="n">dechat</span> <span class="o">/=</span> <span class="n">np</span><span class="o">.</span><span class="n">sqrt</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">sum</span><span class="p">(</span><span class="n">dechat</span><span class="o">**</span><span class="mi">2</span><span class="p">,</span> <span class="n">axis</span><span class="o">=</span><span class="mi">1</span><span class="p">,</span> <span class="n">keepdims</span><span class="o">=</span><span class="kc">True</span><span class="p">))</span>
    <span class="n">xcoord</span> <span class="o">=</span> <span class="n">xx</span>
    <span class="n">ycoord</span> <span class="o">=</span> <span class="n">yy</span>
    <span class="n">zcoord</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">sqrt</span><span class="p">(</span><span class="mi">1</span> <span class="o">-</span> <span class="n">xcoord</span><span class="o">**</span><span class="mi">2</span> <span class="o">-</span> <span class="n">ycoord</span><span class="o">**</span><span class="mi">2</span><span class="p">)</span>
    <span class="n">unit</span> <span class="o">=</span> <span class="p">(</span><span class="n">xcoord</span><span class="o">.</span><span class="n">reshape</span><span class="p">(</span><span class="o">-</span><span class="mi">1</span><span class="p">,</span> <span class="mi">1</span><span class="p">)</span> <span class="o">*</span> <span class="n">rahat</span> <span class="o">+</span> <span class="n">ycoord</span><span class="o">.</span><span class="n">reshape</span><span class="p">(</span><span class="o">-</span><span class="mi">1</span><span class="p">,</span> <span class="mi">1</span><span class="p">)</span> <span class="o">*</span> <span class="n">dechat</span> <span class="o">+</span> <span class="n">zcoord</span><span class="o">.</span><span class="n">reshape</span><span class="p">(</span><span class="o">-</span><span class="mi">1</span><span class="p">,</span> <span class="mi">1</span><span class="p">)</span> <span class="o">*</span> <span class="n">unitcen</span><span class="p">)</span>
    <span class="k">return</span> <span class="n">unit_to_lb</span><span class="p">(</span><span class="n">unit</span><span class="p">)</span></div>


<div class="viewcode-block" id="sample_points"><a class="viewcode-back" href="../../api/ssapy.utils.sample_points.html#ssapy.utils.sample_points">[docs]</a><span class="k">def</span><span class="w"> </span><span class="nf">sample_points</span><span class="p">(</span><span class="n">x</span><span class="p">,</span> <span class="n">C</span><span class="p">,</span> <span class="n">npts</span><span class="p">,</span> <span class="n">sqrt</span><span class="o">=</span><span class="kc">False</span><span class="p">):</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;Sample points around x according to covariance matrix.</span>

<span class="sd">    Parameters</span>
<span class="sd">    ----------</span>
<span class="sd">    x : array_like (n)</span>
<span class="sd">        point to sample around</span>
<span class="sd">    C : array_like (n, n)</span>
<span class="sd">        covariance matrix corresponding to x</span>
<span class="sd">    npts : int</span>
<span class="sd">        number of points to sample</span>
<span class="sd">    sqrt : bool</span>
<span class="sd">        use sqrt(C) rather than an SVD.  The SVD is often more stable.</span>

<span class="sd">    Returns</span>
<span class="sd">    -------</span>
<span class="sd">    Gaussian samples around x corresponding to covariance matrix C</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="n">n</span> <span class="o">=</span> <span class="n">C</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span>
    <span class="n">xa</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">random</span><span class="o">.</span><span class="n">randn</span><span class="p">(</span><span class="n">npts</span><span class="p">,</span> <span class="n">n</span><span class="p">)</span>
    <span class="k">if</span> <span class="ow">not</span> <span class="n">sqrt</span><span class="p">:</span>
        <span class="n">sqrtdiag</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">sqrt</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">diag</span><span class="p">(</span><span class="n">C</span><span class="p">))</span>
        <span class="n">scalecovar</span> <span class="o">=</span> <span class="n">sqrtdiag</span><span class="p">[</span><span class="kc">None</span><span class="p">,</span> <span class="p">:]</span> <span class="o">*</span> <span class="n">sqrtdiag</span><span class="p">[:,</span> <span class="kc">None</span><span class="p">]</span>
        <span class="n">uu</span><span class="p">,</span> <span class="n">ss</span><span class="p">,</span> <span class="n">vvh</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">linalg</span><span class="o">.</span><span class="n">svd</span><span class="p">(</span><span class="n">C</span> <span class="o">/</span> <span class="n">scalecovar</span><span class="p">)</span>
        <span class="k">if</span> <span class="n">np</span><span class="o">.</span><span class="n">any</span><span class="p">(</span><span class="n">ss</span> <span class="o">&lt;</span> <span class="mi">0</span><span class="p">):</span>
            <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s1">&#39;negative eigenvalues in C!&#39;</span><span class="p">)</span>
        <span class="n">sqrtC</span> <span class="o">=</span> <span class="n">uu</span><span class="o">.</span><span class="n">dot</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">diag</span><span class="p">(</span><span class="n">ss</span><span class="o">**</span><span class="mf">0.5</span><span class="p">))</span><span class="o">.</span><span class="n">dot</span><span class="p">(</span><span class="n">vvh</span><span class="p">)</span>
    <span class="k">else</span><span class="p">:</span>
        <span class="n">sqrtC</span> <span class="o">=</span> <span class="n">C</span>
        <span class="n">sqrtdiag</span> <span class="o">=</span> <span class="mi">1</span>
    <span class="n">xa</span> <span class="o">=</span> <span class="n">sqrtC</span><span class="o">.</span><span class="n">dot</span><span class="p">(</span><span class="n">xa</span><span class="o">.</span><span class="n">T</span><span class="p">)</span><span class="o">.</span><span class="n">T</span>
    <span class="k">if</span> <span class="ow">not</span> <span class="n">sqrt</span><span class="p">:</span>
        <span class="n">xa</span> <span class="o">*=</span> <span class="n">sqrtdiag</span><span class="p">[</span><span class="kc">None</span><span class="p">,</span> <span class="p">:]</span>
    <span class="n">xa</span> <span class="o">+=</span> <span class="n">x</span><span class="p">[</span><span class="kc">None</span><span class="p">,</span> <span class="p">:]</span>
    <span class="k">return</span> <span class="n">xa</span></div>


<div class="viewcode-block" id="sigma_points"><a class="viewcode-back" href="../../api/ssapy.utils.sigma_points.html#ssapy.utils.sigma_points">[docs]</a><span class="k">def</span><span class="w"> </span><span class="nf">sigma_points</span><span class="p">(</span><span class="n">f</span><span class="p">,</span> <span class="n">x</span><span class="p">,</span> <span class="n">C</span><span class="p">,</span> <span class="n">scale</span><span class="o">=</span><span class="mi">1</span><span class="p">,</span> <span class="n">fixed_dimensions</span><span class="o">=</span><span class="kc">None</span><span class="p">):</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;Compute f(sigma points) for sigma points of C around x.</span>

<span class="sd">    There are many possible definitions of sigma points.  This one</span>
<span class="sd">    takes the singular value decomposition of C and uses</span>
<span class="sd">    the eigenvectors times sqrt(dimension)*scale*(+/-1) as the sigma points.</span>
<span class="sd">    It then evaluates the given function f at x plus those sigma points.</span>

<span class="sd">    Parameters</span>
<span class="sd">    ----------</span>
<span class="sd">    f : function</span>
<span class="sd">        the function to evaluate at the sigma points</span>
<span class="sd">    x : array_like (n)</span>
<span class="sd">        the central value to evaluate the function around</span>
<span class="sd">    C : array_like (n, n)</span>
<span class="sd">        the covariance matrix corresponding to x</span>
<span class="sd">    scale : float</span>
<span class="sd">        return scale-sigma points rather than n-sigma points.  e.g.,</span>
<span class="sd">        for 5 sigma, set scale = 5.</span>
<span class="sd">    fixed_dimensions : array_like, (n), bool</span>
<span class="sd">        boolean array specifying dimensions of x that are fixed</span>
<span class="sd">        and not specified in C</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="k">if</span> <span class="n">fixed_dimensions</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
        <span class="n">fixed</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">zeros</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">x</span><span class="p">),</span> <span class="n">dtype</span><span class="o">=</span><span class="s1">&#39;bool&#39;</span><span class="p">)</span>
    <span class="k">else</span><span class="p">:</span>
        <span class="n">fixed</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">(</span><span class="n">fixed_dimensions</span><span class="p">)</span><span class="o">.</span><span class="n">astype</span><span class="p">(</span><span class="s1">&#39;bool&#39;</span><span class="p">)</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">False</span>
    <span class="n">free</span> <span class="o">=</span> <span class="o">~</span><span class="n">fixed</span>
    <span class="c1"># sqrtC = linalg.sqrtm(C)</span>
    <span class="n">sqrtdiag</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">sqrt</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">diag</span><span class="p">(</span><span class="n">C</span><span class="p">))</span>
    <span class="n">scalecovar</span> <span class="o">=</span> <span class="n">sqrtdiag</span><span class="o">.</span><span class="n">reshape</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span> <span class="o">-</span><span class="mi">1</span><span class="p">)</span> <span class="o">*</span> <span class="n">sqrtdiag</span><span class="o">.</span><span class="n">reshape</span><span class="p">(</span><span class="o">-</span><span class="mi">1</span><span class="p">,</span> <span class="mi">1</span><span class="p">)</span>
    <span class="n">uu</span><span class="p">,</span> <span class="n">ss</span><span class="p">,</span> <span class="n">vvh</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">linalg</span><span class="o">.</span><span class="n">svd</span><span class="p">(</span><span class="n">C</span> <span class="o">/</span> <span class="n">scalecovar</span><span class="p">)</span>
    <span class="n">sqrtC</span> <span class="o">=</span> <span class="n">uu</span><span class="o">.</span><span class="n">dot</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">diag</span><span class="p">(</span><span class="n">ss</span><span class="o">**</span><span class="mf">0.5</span><span class="p">))</span><span class="o">.</span><span class="n">dot</span><span class="p">(</span><span class="n">vvh</span><span class="p">)</span>
    <span class="n">n</span> <span class="o">=</span> <span class="n">C</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span>
    <span class="n">xsigma</span> <span class="o">=</span> <span class="p">[</span><span class="n">x</span><span class="p">[</span><span class="n">free</span><span class="p">]]</span> <span class="o">+</span> <span class="p">[</span><span class="n">x</span><span class="p">[</span><span class="n">free</span><span class="p">]</span> <span class="o">+</span> <span class="n">np</span><span class="o">.</span><span class="n">sqrt</span><span class="p">(</span><span class="n">n</span><span class="p">)</span> <span class="o">*</span> <span class="n">sgn</span> <span class="o">*</span> <span class="n">scale</span> <span class="o">*</span> <span class="n">sqrtCvec</span> <span class="o">*</span> <span class="n">sqrtdiag</span>
                          <span class="k">for</span> <span class="n">sqrtCvec</span> <span class="ow">in</span> <span class="n">sqrtC</span> <span class="k">for</span> <span class="n">sgn</span> <span class="ow">in</span> <span class="p">[</span><span class="o">-</span><span class="mi">1</span><span class="p">,</span> <span class="mi">1</span><span class="p">]]</span>
    <span class="n">xsigma</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">(</span><span class="n">xsigma</span><span class="p">)</span>
    <span class="n">xsigmaall</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">zeros</span><span class="p">((</span><span class="n">xsigma</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span> <span class="n">xsigma</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span> <span class="o">+</span> <span class="n">np</span><span class="o">.</span><span class="n">sum</span><span class="p">(</span><span class="n">fixed</span><span class="p">)),</span>
                         <span class="n">dtype</span><span class="o">=</span><span class="n">xsigma</span><span class="o">.</span><span class="n">dtype</span><span class="p">)</span>
    <span class="n">xsigmaall</span><span class="p">[:,</span> <span class="n">free</span><span class="p">]</span> <span class="o">=</span> <span class="n">xsigma</span>
    <span class="n">xsigmaall</span><span class="p">[:,</span> <span class="n">fixed</span><span class="p">]</span> <span class="o">=</span> <span class="n">x</span><span class="p">[</span><span class="kc">None</span><span class="p">,</span> <span class="n">fixed</span><span class="p">]</span>
    <span class="k">if</span> <span class="n">f</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
        <span class="n">fsigma</span> <span class="o">=</span> <span class="n">f</span><span class="p">(</span><span class="n">xsigmaall</span><span class="p">)</span>
    <span class="k">else</span><span class="p">:</span>
        <span class="n">fsigma</span> <span class="o">=</span> <span class="n">xsigmaall</span>
    <span class="k">return</span> <span class="n">fsigma</span></div>


<div class="viewcode-block" id="unscented_transform_mean_covar"><a class="viewcode-back" href="../../api/ssapy.utils.unscented_transform_mean_covar.html#ssapy.utils.unscented_transform_mean_covar">[docs]</a><span class="k">def</span><span class="w"> </span><span class="nf">unscented_transform_mean_covar</span><span class="p">(</span><span class="n">f</span><span class="p">,</span> <span class="n">x</span><span class="p">,</span> <span class="n">C</span><span class="p">,</span> <span class="n">scale</span><span class="o">=</span><span class="mi">1</span><span class="p">):</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;Compute mean and covariance matrix using unscented transform given a</span>
<span class="sd">    transformation f, a point x, and a covariance C.</span>

<span class="sd">    This uses the sigma point convention from sigma_points.  It assumes that</span>
<span class="sd">    f(sigma_points)[i] is f evaluated at the ith sigma point.  If f does</span>
<span class="sd">    not obey this convention, this function will produce undefined results.</span>

<span class="sd">    Parameters</span>
<span class="sd">    ----------</span>
<span class="sd">    f : function</span>
<span class="sd">        the function to evaluate at the sigma points.</span>
<span class="sd">    x : array_like (n)</span>
<span class="sd">        the central value to evaluate the function around</span>
<span class="sd">    C : array_like (n, n)</span>
<span class="sd">        the covariance matrix corresponding to x</span>
<span class="sd">    scale : float</span>
<span class="sd">        return scale-sigma points rather than n-sigma points.  e.g.,</span>
<span class="sd">        for 5 sigma, set scale = 5.</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="n">fsigma</span> <span class="o">=</span> <span class="n">sigma_points</span><span class="p">(</span><span class="n">f</span><span class="p">,</span> <span class="n">x</span><span class="p">,</span> <span class="n">C</span><span class="p">,</span> <span class="n">scale</span><span class="o">=</span><span class="n">scale</span><span class="p">)</span>
    <span class="n">mean</span> <span class="o">=</span> <span class="n">fsigma</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span>
    <span class="n">dmean</span> <span class="o">=</span> <span class="n">fsigma</span><span class="p">[</span><span class="mi">1</span><span class="p">:,</span> <span class="o">...</span><span class="p">]</span> <span class="o">-</span> <span class="n">mean</span><span class="p">[:,</span> <span class="o">...</span><span class="p">]</span>
    <span class="n">covar</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">cov</span><span class="p">(</span><span class="n">dmean</span><span class="p">,</span> <span class="n">ddof</span><span class="o">=</span><span class="mi">0</span><span class="p">)</span>
    <span class="k">return</span> <span class="n">mean</span><span class="p">,</span> <span class="n">covar</span></div>


<span class="k">def</span><span class="w"> </span><span class="nf">_gpsToTT</span><span class="p">(</span><span class="n">t</span><span class="p">):</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Convert GPS time to Terrestrial Time (TT).</span>

<span class="sd">    Parameters:</span>
<span class="sd">    ----------</span>
<span class="sd">    t : Time or float</span>
<span class="sd">        If `t` is an instance of `astropy.time.Time`, it is assumed to represent GPS time in the form of an Astropy Time object.</span>
<span class="sd">        If `t` is a float, it is assumed to be GPS time in seconds.</span>

<span class="sd">    Returns:</span>
<span class="sd">    -------</span>
<span class="sd">    float</span>
<span class="sd">        The equivalent time in Terrestrial Time (TT) expressed in days since the GPS epoch (January 6, 1980).</span>

<span class="sd">    Notes:</span>
<span class="sd">    -----</span>
<span class="sd">    The conversion involves adding a constant offset of 51.184 seconds to the GPS time,</span>
<span class="sd">    then converting the result into days by dividing by 86400 (the number of seconds in a day).</span>
<span class="sd">    The epoch for GPS is represented as a Modified Julian Date (MJD) of 44244.0.</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">t</span><span class="p">,</span> <span class="n">Time</span><span class="p">):</span>
        <span class="n">t</span> <span class="o">=</span> <span class="n">t</span><span class="o">.</span><span class="n">gps</span>
    <span class="k">return</span> <span class="mf">44244.0</span> <span class="o">+</span> <span class="p">(</span><span class="n">t</span> <span class="o">+</span> <span class="mf">51.184</span><span class="p">)</span> <span class="o">/</span> <span class="mi">86400</span>


<div class="viewcode-block" id="sunPos"><a class="viewcode-back" href="../../api/ssapy.utils.sunPos.html#ssapy.utils.sunPos">[docs]</a><span class="k">def</span><span class="w"> </span><span class="nf">sunPos</span><span class="p">(</span><span class="n">t</span><span class="p">,</span> <span class="n">fast</span><span class="o">=</span><span class="kc">True</span><span class="p">):</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;Compute GCRF position of the sun.</span>

<span class="sd">    Parameters</span>
<span class="sd">    ----------</span>
<span class="sd">    t : float or astropy.time.Time</span>
<span class="sd">        If float or array of float, then should correspond to GPS seconds; i.e.,</span>
<span class="sd">        seconds since 1980-01-06 00:00:00 UTC</span>
<span class="sd">    fast : bool</span>
<span class="sd">        Use fast approximation?</span>

<span class="sd">    Returns</span>
<span class="sd">    -------</span>
<span class="sd">    r : array_like (n)</span>
<span class="sd">        position in meters</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">t</span><span class="p">,</span> <span class="n">Time</span><span class="p">):</span>
        <span class="n">t</span> <span class="o">=</span> <span class="n">t</span><span class="o">.</span><span class="n">gps</span>
    <span class="k">if</span> <span class="n">fast</span><span class="p">:</span>
        <span class="c1"># MG section 3.3.2</span>
        <span class="n">T</span> <span class="o">=</span> <span class="p">(</span><span class="n">_gpsToTT</span><span class="p">(</span><span class="n">t</span><span class="p">)</span> <span class="o">-</span> <span class="mf">51544.5</span><span class="p">)</span> <span class="o">/</span> <span class="mf">36525.0</span>
        <span class="n">M</span> <span class="o">=</span> <span class="mf">6.239998880168239</span> <span class="o">+</span> <span class="mf">628.3019326367721</span> <span class="o">*</span> <span class="n">T</span>
        <span class="n">lam</span> <span class="o">=</span> <span class="p">(</span><span class="mf">4.938234585592756</span> <span class="o">+</span> <span class="n">M</span> <span class="o">+</span> <span class="mf">0.03341335890206922</span> <span class="o">*</span> <span class="n">np</span><span class="o">.</span><span class="n">sin</span><span class="p">(</span><span class="n">M</span><span class="p">)</span> <span class="o">+</span> <span class="mf">0.00034906585039886593</span> <span class="o">*</span> <span class="n">np</span><span class="o">.</span><span class="n">sin</span><span class="p">(</span><span class="mi">2</span> <span class="o">*</span> <span class="n">M</span><span class="p">))</span>
        <span class="n">rs</span> <span class="o">=</span> <span class="p">(</span><span class="mf">149.619</span> <span class="o">-</span> <span class="mf">2.499</span> <span class="o">*</span> <span class="n">np</span><span class="o">.</span><span class="n">cos</span><span class="p">(</span><span class="n">M</span><span class="p">)</span> <span class="o">-</span> <span class="mf">0.021</span> <span class="o">*</span> <span class="n">np</span><span class="o">.</span><span class="n">cos</span><span class="p">(</span><span class="mi">2</span> <span class="o">*</span> <span class="n">M</span><span class="p">))</span> <span class="o">*</span> <span class="mf">1e9</span>
        <span class="n">obliquity</span> <span class="o">=</span> <span class="mf">0.40909280420293637</span>
        <span class="n">co</span><span class="p">,</span> <span class="n">so</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">cos</span><span class="p">(</span><span class="n">obliquity</span><span class="p">),</span> <span class="n">np</span><span class="o">.</span><span class="n">sin</span><span class="p">(</span><span class="n">obliquity</span><span class="p">)</span>
        <span class="n">cl</span><span class="p">,</span> <span class="n">sl</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">cos</span><span class="p">(</span><span class="n">lam</span><span class="p">),</span> <span class="n">np</span><span class="o">.</span><span class="n">sin</span><span class="p">(</span><span class="n">lam</span><span class="p">)</span>
        <span class="n">r</span> <span class="o">=</span> <span class="n">rs</span> <span class="o">*</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">([</span><span class="n">cl</span><span class="p">,</span> <span class="n">sl</span> <span class="o">*</span> <span class="n">co</span><span class="p">,</span> <span class="n">sl</span> <span class="o">*</span> <span class="n">so</span><span class="p">])</span>
    <span class="k">else</span><span class="p">:</span>
        <span class="n">pvh</span><span class="p">,</span> <span class="n">_</span> <span class="o">=</span> <span class="n">erfa</span><span class="o">.</span><span class="n">epv00</span><span class="p">(</span><span class="mf">2400000.5</span><span class="p">,</span> <span class="n">_gpsToTT</span><span class="p">(</span><span class="n">t</span><span class="p">))</span>
        <span class="n">r</span> <span class="o">=</span> <span class="n">pvh</span><span class="p">[</span><span class="s1">&#39;p&#39;</span><span class="p">]</span> <span class="o">*</span> <span class="o">-</span><span class="mi">149597870700</span>  <span class="c1"># AU -&gt; m</span>
    <span class="k">return</span> <span class="n">r</span></div>


<div class="viewcode-block" id="moonPos"><a class="viewcode-back" href="../../api/ssapy.utils.moonPos.html#ssapy.utils.moonPos">[docs]</a><span class="k">def</span><span class="w"> </span><span class="nf">moonPos</span><span class="p">(</span><span class="n">t</span><span class="p">):</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;Compute GCRF position of the moon.</span>

<span class="sd">    Parameters</span>
<span class="sd">    ----------</span>
<span class="sd">    t : float or astropy.time.Time</span>
<span class="sd">        If float or array of float, then should correspond to GPS seconds; i.e.,</span>
<span class="sd">        seconds since 1980-01-06 00:00:00 UTC</span>

<span class="sd">    Returns</span>
<span class="sd">    -------</span>
<span class="sd">    r : array_like (n)</span>
<span class="sd">        position in meters</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">t</span><span class="p">,</span> <span class="n">Time</span><span class="p">):</span>
        <span class="n">t</span> <span class="o">=</span> <span class="n">t</span><span class="o">.</span><span class="n">gps</span>
    <span class="c1"># MG section 3.3.2</span>
    <span class="n">T</span> <span class="o">=</span> <span class="p">(</span><span class="n">_gpsToTT</span><span class="p">(</span><span class="n">t</span><span class="p">)</span> <span class="o">-</span> <span class="mf">51544.5</span><span class="p">)</span> <span class="o">/</span> <span class="mf">36525.0</span>
    <span class="c1"># fundamental arguments (3.47)</span>
    <span class="n">L0</span> <span class="o">=</span> <span class="mf">3.810335976843669</span> <span class="o">+</span> <span class="mf">8399.684719711557</span> <span class="o">*</span> <span class="n">T</span>
    <span class="n">lb</span> <span class="o">=</span> <span class="mf">2.3555473221057053</span> <span class="o">+</span> <span class="mf">8328.69142518676</span> <span class="o">*</span> <span class="n">T</span>
    <span class="n">lp</span> <span class="o">=</span> <span class="mf">6.23999591310851</span> <span class="o">+</span> <span class="mf">628.3019403162209</span> <span class="o">*</span> <span class="n">T</span>
    <span class="n">D</span> <span class="o">=</span> <span class="mf">5.198467889454092</span> <span class="o">+</span> <span class="mf">7771.377143901714</span> <span class="o">*</span> <span class="n">T</span>
    <span class="n">F</span> <span class="o">=</span> <span class="mf">1.6279179861529427</span> <span class="o">+</span> <span class="mf">8433.46617912181</span> <span class="o">*</span> <span class="n">T</span>
    <span class="c1"># moon longitude (3.48)</span>
    <span class="n">dL</span> <span class="o">=</span> <span class="p">(</span><span class="mi">22640</span> <span class="o">*</span> <span class="n">np</span><span class="o">.</span><span class="n">sin</span><span class="p">(</span><span class="n">lb</span><span class="p">)</span> <span class="o">+</span> <span class="mi">769</span> <span class="o">*</span> <span class="n">np</span><span class="o">.</span><span class="n">sin</span><span class="p">(</span><span class="mi">2</span> <span class="o">*</span> <span class="n">lb</span><span class="p">)</span> <span class="o">-</span> <span class="mi">4586</span> <span class="o">*</span> <span class="n">np</span><span class="o">.</span><span class="n">sin</span><span class="p">(</span><span class="n">lb</span> <span class="o">-</span> <span class="mi">2</span> <span class="o">*</span> <span class="n">D</span><span class="p">)</span> <span class="o">+</span> <span class="mi">2370</span> <span class="o">*</span> <span class="n">np</span><span class="o">.</span><span class="n">sin</span><span class="p">(</span><span class="mi">2</span> <span class="o">*</span> <span class="n">D</span><span class="p">)</span> <span class="o">-</span> <span class="mi">668</span> <span class="o">*</span> <span class="n">np</span><span class="o">.</span><span class="n">sin</span><span class="p">(</span><span class="n">lp</span><span class="p">)</span> <span class="o">-</span> <span class="mi">412</span> <span class="o">*</span> <span class="n">np</span><span class="o">.</span><span class="n">sin</span><span class="p">(</span><span class="mi">2</span> <span class="o">*</span> <span class="n">F</span><span class="p">)</span> <span class="o">-</span> <span class="mi">212</span> <span class="o">*</span> <span class="n">np</span><span class="o">.</span><span class="n">sin</span><span class="p">(</span><span class="mi">2</span> <span class="o">*</span> <span class="n">lb</span> <span class="o">-</span> <span class="mi">2</span> <span class="o">*</span> <span class="n">D</span><span class="p">)</span> <span class="o">-</span> <span class="mi">206</span> <span class="o">*</span> <span class="n">np</span><span class="o">.</span><span class="n">sin</span><span class="p">(</span><span class="n">lb</span> <span class="o">+</span> <span class="n">lp</span> <span class="o">-</span> <span class="mi">2</span> <span class="o">*</span> <span class="n">D</span><span class="p">)</span> <span class="o">+</span> <span class="mi">192</span> <span class="o">*</span> <span class="n">np</span><span class="o">.</span><span class="n">sin</span><span class="p">(</span><span class="n">lb</span> <span class="o">+</span> <span class="mi">2</span> <span class="o">*</span> <span class="n">D</span><span class="p">)</span> <span class="o">-</span> <span class="mi">165</span> <span class="o">*</span> <span class="n">np</span><span class="o">.</span><span class="n">sin</span><span class="p">(</span><span class="n">lp</span> <span class="o">-</span> <span class="mi">2</span> <span class="o">*</span> <span class="n">D</span><span class="p">)</span> <span class="o">+</span> <span class="mi">148</span> <span class="o">*</span> <span class="n">np</span><span class="o">.</span><span class="n">sin</span><span class="p">(</span><span class="n">lb</span> <span class="o">-</span> <span class="n">lp</span><span class="p">)</span> <span class="o">-</span> <span class="mi">125</span> <span class="o">*</span> <span class="n">np</span><span class="o">.</span><span class="n">sin</span><span class="p">(</span><span class="n">D</span><span class="p">)</span> <span class="o">-</span> <span class="mi">110</span> <span class="o">*</span> <span class="n">np</span><span class="o">.</span><span class="n">sin</span><span class="p">(</span><span class="n">lb</span> <span class="o">+</span> <span class="n">lp</span><span class="p">)</span> <span class="o">-</span> <span class="mi">55</span> <span class="o">*</span> <span class="n">np</span><span class="o">.</span><span class="n">sin</span><span class="p">(</span><span class="mi">2</span> <span class="o">*</span> <span class="n">F</span> <span class="o">-</span> <span class="mi">2</span> <span class="o">*</span> <span class="n">D</span><span class="p">))</span>

    <span class="n">L</span> <span class="o">=</span> <span class="n">L0</span> <span class="o">+</span> <span class="n">np</span><span class="o">.</span><span class="n">deg2rad</span><span class="p">(</span><span class="n">dL</span> <span class="o">/</span> <span class="mi">3600</span><span class="p">)</span>
    <span class="c1"># moon latitude (3.49)</span>
    <span class="n">beta</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">deg2rad</span><span class="p">((</span>
        <span class="mi">18520</span> <span class="o">*</span> <span class="n">np</span><span class="o">.</span><span class="n">sin</span><span class="p">(</span><span class="n">F</span> <span class="o">+</span> <span class="n">L</span> <span class="o">-</span> <span class="n">L0</span> <span class="o">+</span> <span class="n">np</span><span class="o">.</span><span class="n">deg2rad</span><span class="p">((</span><span class="mi">412</span> <span class="o">*</span> <span class="n">np</span><span class="o">.</span><span class="n">sin</span><span class="p">(</span><span class="mi">2</span> <span class="o">*</span> <span class="n">F</span><span class="p">)</span> <span class="o">+</span> <span class="mi">541</span> <span class="o">*</span> <span class="n">np</span><span class="o">.</span><span class="n">sin</span><span class="p">(</span><span class="n">lp</span><span class="p">))</span> <span class="o">/</span> <span class="mi">3600</span><span class="p">))</span> <span class="o">-</span> <span class="mi">526</span> <span class="o">*</span> <span class="n">np</span><span class="o">.</span><span class="n">sin</span><span class="p">(</span><span class="n">F</span> <span class="o">-</span> <span class="mi">2</span> <span class="o">*</span> <span class="n">D</span><span class="p">)</span> <span class="o">+</span> <span class="mi">44</span> <span class="o">*</span> <span class="n">np</span><span class="o">.</span><span class="n">sin</span><span class="p">(</span><span class="n">lb</span> <span class="o">+</span> <span class="n">F</span> <span class="o">-</span> <span class="mi">2</span> <span class="o">*</span> <span class="n">D</span><span class="p">)</span> <span class="o">-</span> <span class="mi">31</span> <span class="o">*</span> <span class="n">np</span><span class="o">.</span><span class="n">sin</span><span class="p">(</span><span class="o">-</span><span class="n">lb</span> <span class="o">+</span> <span class="n">F</span> <span class="o">-</span> <span class="mi">2</span> <span class="o">*</span> <span class="n">D</span><span class="p">)</span> <span class="o">-</span> <span class="mi">25</span> <span class="o">*</span> <span class="n">np</span><span class="o">.</span><span class="n">sin</span><span class="p">(</span><span class="o">-</span><span class="mi">2</span> <span class="o">*</span> <span class="n">lb</span> <span class="o">+</span> <span class="n">F</span><span class="p">)</span> <span class="o">-</span> <span class="mi">23</span> <span class="o">*</span> <span class="n">np</span><span class="o">.</span><span class="n">sin</span><span class="p">(</span><span class="n">lp</span> <span class="o">+</span> <span class="n">F</span> <span class="o">-</span> <span class="mi">2</span> <span class="o">*</span> <span class="n">D</span><span class="p">)</span> <span class="o">+</span> <span class="mi">21</span> <span class="o">*</span> <span class="n">np</span><span class="o">.</span><span class="n">sin</span><span class="p">(</span><span class="o">-</span><span class="n">lb</span> <span class="o">+</span> <span class="n">F</span><span class="p">)</span> <span class="o">+</span> <span class="mi">11</span> <span class="o">*</span> <span class="n">np</span><span class="o">.</span><span class="n">sin</span><span class="p">(</span><span class="o">-</span><span class="n">lp</span> <span class="o">+</span> <span class="n">F</span> <span class="o">-</span> <span class="mi">2</span> <span class="o">*</span> <span class="n">D</span><span class="p">)</span>
    <span class="p">)</span> <span class="o">/</span> <span class="mi">3600</span><span class="p">)</span>
    <span class="c1"># moon distance (3.50)</span>
    <span class="n">r</span> <span class="o">=</span> <span class="p">(</span>
        <span class="mi">385000</span> <span class="o">-</span> <span class="mi">20905</span> <span class="o">*</span> <span class="n">np</span><span class="o">.</span><span class="n">cos</span><span class="p">(</span><span class="n">lb</span><span class="p">)</span> <span class="o">-</span> <span class="mi">3699</span> <span class="o">*</span> <span class="n">np</span><span class="o">.</span><span class="n">cos</span><span class="p">(</span><span class="mi">2</span> <span class="o">*</span> <span class="n">D</span> <span class="o">-</span> <span class="n">lb</span><span class="p">)</span> <span class="o">-</span> <span class="mi">2956</span> <span class="o">*</span> <span class="n">np</span><span class="o">.</span><span class="n">cos</span><span class="p">(</span><span class="mi">2</span> <span class="o">*</span> <span class="n">D</span><span class="p">)</span> <span class="o">-</span> <span class="mi">570</span> <span class="o">*</span> <span class="n">np</span><span class="o">.</span><span class="n">cos</span><span class="p">(</span><span class="mi">2</span> <span class="o">*</span> <span class="n">lb</span><span class="p">)</span> <span class="o">+</span> <span class="mi">246</span> <span class="o">*</span> <span class="n">np</span><span class="o">.</span><span class="n">cos</span><span class="p">(</span><span class="mi">2</span> <span class="o">*</span> <span class="n">lb</span> <span class="o">-</span> <span class="mi">2</span> <span class="o">*</span> <span class="n">D</span><span class="p">)</span> <span class="o">-</span> <span class="mi">205</span> <span class="o">*</span> <span class="n">np</span><span class="o">.</span><span class="n">cos</span><span class="p">(</span><span class="n">lp</span> <span class="o">-</span> <span class="mi">2</span> <span class="o">*</span> <span class="n">D</span><span class="p">)</span> <span class="o">-</span> <span class="mi">171</span> <span class="o">*</span> <span class="n">np</span><span class="o">.</span><span class="n">cos</span><span class="p">(</span><span class="n">lb</span> <span class="o">+</span> <span class="mi">2</span> <span class="o">*</span> <span class="n">D</span><span class="p">)</span> <span class="o">-</span> <span class="mi">152</span> <span class="o">*</span> <span class="n">np</span><span class="o">.</span><span class="n">cos</span><span class="p">(</span><span class="n">lb</span> <span class="o">+</span> <span class="n">lp</span> <span class="o">-</span> <span class="mi">2</span> <span class="o">*</span> <span class="n">D</span><span class="p">)</span>
    <span class="p">)</span> <span class="o">*</span> <span class="mf">1e3</span>
    <span class="n">r_ecliptic</span> <span class="o">=</span> <span class="n">r</span> <span class="o">*</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">([</span>
        <span class="n">np</span><span class="o">.</span><span class="n">cos</span><span class="p">(</span><span class="n">L</span><span class="p">)</span> <span class="o">*</span> <span class="n">np</span><span class="o">.</span><span class="n">cos</span><span class="p">(</span><span class="n">beta</span><span class="p">),</span>
        <span class="n">np</span><span class="o">.</span><span class="n">sin</span><span class="p">(</span><span class="n">L</span><span class="p">)</span> <span class="o">*</span> <span class="n">np</span><span class="o">.</span><span class="n">cos</span><span class="p">(</span><span class="n">beta</span><span class="p">),</span>
        <span class="n">np</span><span class="o">.</span><span class="n">sin</span><span class="p">(</span><span class="n">beta</span><span class="p">)</span>
    <span class="p">])</span>
    <span class="n">obliquity</span> <span class="o">=</span> <span class="mf">0.40909280420293637</span>
    <span class="n">co</span><span class="p">,</span> <span class="n">so</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">cos</span><span class="p">(</span><span class="n">obliquity</span><span class="p">),</span> <span class="n">np</span><span class="o">.</span><span class="n">sin</span><span class="p">(</span><span class="n">obliquity</span><span class="p">)</span>
    <span class="n">rot</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">([[</span><span class="mi">1</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">],</span> <span class="p">[</span><span class="mi">0</span><span class="p">,</span> <span class="n">co</span><span class="p">,</span> <span class="n">so</span><span class="p">],</span> <span class="p">[</span><span class="mi">0</span><span class="p">,</span> <span class="o">-</span><span class="n">so</span><span class="p">,</span> <span class="n">co</span><span class="p">]])</span>
    <span class="k">return</span> <span class="n">rot</span><span class="o">.</span><span class="n">T</span> <span class="o">@</span> <span class="n">r_ecliptic</span></div>


<div class="viewcode-block" id="iers_interp"><a class="viewcode-back" href="../../api/ssapy.utils.iers_interp.html#ssapy.utils.iers_interp">[docs]</a><span class="k">def</span><span class="w"> </span><span class="nf">iers_interp</span><span class="p">(</span><span class="n">t</span><span class="p">):</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;Interpolate IERS values</span>

<span class="sd">    Parameters</span>
<span class="sd">    ----------</span>
<span class="sd">    t : float or astropy.time.Time</span>
<span class="sd">        If float or array of float, then should correspond to GPS seconds; i.e.,</span>
<span class="sd">        seconds since 1980-01-06 00:00:00 UTC</span>

<span class="sd">    Returns</span>
<span class="sd">    -------</span>
<span class="sd">    dut1: array_like (n)</span>
<span class="sd">        Time difference UT1 - TT in days.</span>
<span class="sd">    pmx, pmy : array_like (n)</span>
<span class="sd">        Polar motion values in radians.</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="kn">from</span><span class="w"> </span><span class="nn">astropy.utils</span><span class="w"> </span><span class="kn">import</span> <span class="n">iers</span>
    <span class="kn">from</span><span class="w"> </span><span class="nn">scipy.interpolate</span><span class="w"> </span><span class="kn">import</span> <span class="n">interp1d</span>
    <span class="kn">from</span><span class="w"> </span><span class="nn">astropy</span><span class="w"> </span><span class="kn">import</span> <span class="n">units</span> <span class="k">as</span> <span class="n">u</span>
    <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">t</span><span class="p">,</span> <span class="n">Time</span><span class="p">):</span>
        <span class="n">t</span> <span class="o">=</span> <span class="n">t</span><span class="o">.</span><span class="n">gps</span>
    <span class="k">if</span> <span class="ow">not</span> <span class="nb">hasattr</span><span class="p">(</span><span class="n">iers_interp</span><span class="p">,</span> <span class="s1">&#39;_interp&#39;</span><span class="p">):</span>
        <span class="n">table</span> <span class="o">=</span> <span class="n">iers</span><span class="o">.</span><span class="n">earth_orientation_table</span><span class="o">.</span><span class="n">get</span><span class="p">()</span>
        <span class="n">ts</span> <span class="o">=</span> <span class="n">Time</span><span class="p">(</span><span class="n">table</span><span class="p">[</span><span class="s1">&#39;MJD&#39;</span><span class="p">],</span> <span class="nb">format</span><span class="o">=</span><span class="s1">&#39;mjd&#39;</span><span class="p">,</span> <span class="n">scale</span><span class="o">=</span><span class="s1">&#39;utc&#39;</span><span class="p">)</span>
        <span class="n">tgps</span> <span class="o">=</span> <span class="n">ts</span><span class="o">.</span><span class="n">gps</span>
        <span class="n">dut1tt</span> <span class="o">=</span> <span class="n">ts</span><span class="o">.</span><span class="n">ut1</span><span class="o">.</span><span class="n">mjd</span> <span class="o">-</span> <span class="n">ts</span><span class="o">.</span><span class="n">tt</span><span class="o">.</span><span class="n">mjd</span>
        <span class="n">pmx</span> <span class="o">=</span> <span class="n">table</span><span class="p">[</span><span class="s1">&#39;PM_x&#39;</span><span class="p">]</span><span class="o">.</span><span class="n">to</span><span class="p">(</span><span class="n">u</span><span class="o">.</span><span class="n">rad</span><span class="p">)</span><span class="o">.</span><span class="n">value</span>
        <span class="n">pmy</span> <span class="o">=</span> <span class="n">table</span><span class="p">[</span><span class="s1">&#39;PM_y&#39;</span><span class="p">]</span><span class="o">.</span><span class="n">to</span><span class="p">(</span><span class="n">u</span><span class="o">.</span><span class="n">rad</span><span class="p">)</span><span class="o">.</span><span class="n">value</span>
        <span class="n">iers_interp</span><span class="o">.</span><span class="n">_interp</span> <span class="o">=</span> <span class="n">interp1d</span><span class="p">(</span>
            <span class="n">tgps</span><span class="p">,</span>
            <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">([</span><span class="n">dut1tt</span><span class="p">,</span> <span class="n">pmx</span><span class="p">,</span> <span class="n">pmy</span><span class="p">]),</span>
            <span class="n">bounds_error</span><span class="o">=</span><span class="kc">False</span><span class="p">,</span>
            <span class="n">fill_value</span><span class="o">=</span><span class="p">(</span>
                <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">([</span><span class="n">dut1tt</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span> <span class="n">pmx</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span> <span class="n">pmy</span><span class="p">[</span><span class="mi">0</span><span class="p">]]),</span>
                <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">([</span><span class="n">dut1tt</span><span class="p">[</span><span class="o">-</span><span class="mi">1</span><span class="p">],</span> <span class="n">pmx</span><span class="p">[</span><span class="o">-</span><span class="mi">1</span><span class="p">],</span> <span class="n">pmy</span><span class="p">[</span><span class="o">-</span><span class="mi">1</span><span class="p">]])</span>
            <span class="p">)</span>
        <span class="p">)</span>
    <span class="k">return</span> <span class="n">iers_interp</span><span class="o">.</span><span class="n">_interp</span><span class="p">(</span><span class="n">t</span><span class="p">)</span></div>


<div class="viewcode-block" id="gcrf_to_teme"><a class="viewcode-back" href="../../api/ssapy.utils.gcrf_to_teme.html#ssapy.utils.gcrf_to_teme">[docs]</a><span class="k">def</span><span class="w"> </span><span class="nf">gcrf_to_teme</span><span class="p">(</span><span class="n">t</span><span class="p">):</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot; Return the rotation matrix that converts GCRS cartesian coordinates</span>
<span class="sd">    to TEME cartesian coordinates.</span>

<span class="sd">    Parameters</span>
<span class="sd">    ----------</span>
<span class="sd">    t : float or astropy.time.Time</span>
<span class="sd">        If float or array of float, then should correspond to GPS seconds; i.e.,</span>
<span class="sd">        seconds since 1980-01-06 00:00:00 UTC</span>

<span class="sd">    Returns</span>
<span class="sd">    -------</span>
<span class="sd">    rot : array (3,3)</span>
<span class="sd">        Rotation matrix to apply to GCRS to yield TEME.</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">t</span><span class="p">,</span> <span class="n">Time</span><span class="p">):</span>
        <span class="n">t</span> <span class="o">=</span> <span class="n">t</span><span class="o">.</span><span class="n">gps</span>
    <span class="n">d_ut1_tt_mjd</span><span class="p">,</span> <span class="n">_</span><span class="p">,</span> <span class="n">_</span> <span class="o">=</span> <span class="n">iers_interp</span><span class="p">(</span><span class="n">t</span><span class="p">)</span>
    <span class="n">mjd_tt</span> <span class="o">=</span> <span class="n">_gpsToTT</span><span class="p">(</span><span class="n">t</span><span class="p">)</span>
    <span class="n">ut1</span> <span class="o">=</span> <span class="n">mjd_tt</span> <span class="o">+</span> <span class="n">d_ut1_tt_mjd</span>
    <span class="n">gst</span> <span class="o">=</span> <span class="n">erfa</span><span class="o">.</span><span class="n">gmst82</span><span class="p">(</span><span class="mf">2400000.5</span><span class="p">,</span> <span class="n">ut1</span><span class="p">)</span>
    <span class="n">era</span> <span class="o">=</span> <span class="n">erfa</span><span class="o">.</span><span class="n">era00</span><span class="p">(</span><span class="mf">2400000.5</span><span class="p">,</span> <span class="n">ut1</span><span class="p">)</span>
    <span class="n">c2i</span> <span class="o">=</span> <span class="n">erfa</span><span class="o">.</span><span class="n">c2i00b</span><span class="p">(</span><span class="mf">2400000.5</span><span class="p">,</span> <span class="n">mjd_tt</span><span class="p">)</span>
    <span class="k">return</span> <span class="n">erfa</span><span class="o">.</span><span class="n">rxr</span><span class="p">(</span><span class="n">erfa</span><span class="o">.</span><span class="n">rv2m</span><span class="p">([</span><span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="n">era</span> <span class="o">-</span> <span class="n">gst</span><span class="p">]),</span> <span class="n">c2i</span><span class="p">)</span></div>


<div class="viewcode-block" id="teme_to_gcrf"><a class="viewcode-back" href="../../api/ssapy.utils.teme_to_gcrf.html#ssapy.utils.teme_to_gcrf">[docs]</a><span class="k">def</span><span class="w"> </span><span class="nf">teme_to_gcrf</span><span class="p">(</span><span class="n">t</span><span class="p">):</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot; Return the rotation matrix that converts TEME cartesian coordinates</span>
<span class="sd">    to GCRS cartesian coordinates.</span>

<span class="sd">    Parameters</span>
<span class="sd">    ----------</span>
<span class="sd">    t : float or astropy.time.Time</span>
<span class="sd">        If float or array of float, then should correspond to GPS seconds; i.e.,</span>
<span class="sd">        seconds since 1980-01-06 00:00:00 UTC</span>

<span class="sd">    Returns</span>
<span class="sd">    -------</span>
<span class="sd">    rot : array (3,3)</span>
<span class="sd">        Rotation matrix to apply to TEME to yield GCRS.</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="k">return</span> <span class="n">erfa</span><span class="o">.</span><span class="n">tr</span><span class="p">(</span><span class="n">gcrf_to_teme</span><span class="p">(</span><span class="n">t</span><span class="p">))</span></div>



<span class="c1"># VECTOR FUNCTIONS FOR COORDINATE MATH</span>
<div class="viewcode-block" id="unit_vector"><a class="viewcode-back" href="../../api/ssapy.utils.unit_vector.html#ssapy.utils.unit_vector">[docs]</a><span class="k">def</span><span class="w"> </span><span class="nf">unit_vector</span><span class="p">(</span><span class="n">vector</span><span class="p">):</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot; Returns the unit vector of the vector.&quot;&quot;&quot;</span>
    <span class="k">return</span> <span class="n">vector</span> <span class="o">/</span> <span class="n">np</span><span class="o">.</span><span class="n">linalg</span><span class="o">.</span><span class="n">norm</span><span class="p">(</span><span class="n">vector</span><span class="p">)</span></div>


<div class="viewcode-block" id="get_angle"><a class="viewcode-back" href="../../api/ssapy.utils.get_angle.html#ssapy.utils.get_angle">[docs]</a><span class="k">def</span><span class="w"> </span><span class="nf">get_angle</span><span class="p">(</span><span class="n">a</span><span class="p">,</span> <span class="n">b</span><span class="p">,</span> <span class="n">c</span><span class="p">):</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Calculate the angle between two vectors where b is the vertex of the angle.</span>

<span class="sd">    This function computes the angle between vectors `ba` and `bc`, where `b` is the vertex and `a` and `c` are the endpoints of the angle.</span>

<span class="sd">    Parameters:</span>
<span class="sd">    ----------</span>
<span class="sd">    a : (n, 3) numpy.ndarray</span>
<span class="sd">        Array of coordinates representing the first vector.</span>
<span class="sd">    b : (n, 3) numpy.ndarray</span>
<span class="sd">        Array of coordinates representing the vertex of the angle.</span>
<span class="sd">    c : (n, 3) numpy.ndarray</span>
<span class="sd">        Array of coordinates representing the second vector.</span>

<span class="sd">    Returns:</span>
<span class="sd">    -------</span>
<span class="sd">    numpy.ndarray</span>
<span class="sd">        Array of angles (in radians) between the vectors `ba` and `bc`.</span>

<span class="sd">    Notes:</span>
<span class="sd">    ------</span>
<span class="sd">    - The function handles multiple vectors by using broadcasting.</span>
<span class="sd">    - The angle is calculated using the dot product formula and the arccosine function.</span>

<span class="sd">    Example:</span>
<span class="sd">    --------</span>
<span class="sd">    &gt;&gt;&gt; a = np.array([[1, 0, 0]])</span>
<span class="sd">    &gt;&gt;&gt; b = np.array([[0, 0, 0]])</span>
<span class="sd">    &gt;&gt;&gt; c = np.array([[0, 1, 0]])</span>
<span class="sd">    &gt;&gt;&gt; get_angle(a, b, c)</span>
<span class="sd">    array([1.57079633])</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="n">a</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">atleast_2d</span><span class="p">(</span><span class="n">a</span><span class="p">)</span>
    <span class="n">b</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">atleast_2d</span><span class="p">(</span><span class="n">b</span><span class="p">)</span>
    <span class="n">c</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">atleast_2d</span><span class="p">(</span><span class="n">c</span><span class="p">)</span>
    <span class="n">ba</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">subtract</span><span class="p">(</span><span class="n">a</span><span class="p">,</span> <span class="n">b</span><span class="p">)</span>
    <span class="n">bc</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">subtract</span><span class="p">(</span><span class="n">c</span><span class="p">,</span> <span class="n">b</span><span class="p">)</span>
    <span class="n">cosine_angle</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">sum</span><span class="p">(</span><span class="n">ba</span> <span class="o">*</span> <span class="n">bc</span><span class="p">,</span> <span class="n">axis</span><span class="o">=-</span><span class="mi">1</span><span class="p">)</span> <span class="o">/</span> <span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">linalg</span><span class="o">.</span><span class="n">norm</span><span class="p">(</span><span class="n">ba</span><span class="p">,</span> <span class="n">axis</span><span class="o">=-</span><span class="mi">1</span><span class="p">)</span> <span class="o">*</span> <span class="n">np</span><span class="o">.</span><span class="n">linalg</span><span class="o">.</span><span class="n">norm</span><span class="p">(</span><span class="n">bc</span><span class="p">,</span> <span class="n">axis</span><span class="o">=-</span><span class="mi">1</span><span class="p">))</span>
    <span class="k">return</span> <span class="n">np</span><span class="o">.</span><span class="n">arccos</span><span class="p">(</span><span class="n">cosine_angle</span><span class="p">)</span></div>


<div class="viewcode-block" id="angle_between_vectors"><a class="viewcode-back" href="../../api/ssapy.utils.angle_between_vectors.html#ssapy.utils.angle_between_vectors">[docs]</a><span class="k">def</span><span class="w"> </span><span class="nf">angle_between_vectors</span><span class="p">(</span><span class="n">vector1</span><span class="p">,</span> <span class="n">vector2</span><span class="p">):</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Calculates the angle (in radians) between two vectors.</span>

<span class="sd">    Parameters:</span>
<span class="sd">    -----------</span>
<span class="sd">        vector1 (ndarray): First vector.</span>
<span class="sd">        vector2 (ndarray): Second vector.</span>

<span class="sd">    Returns:</span>
<span class="sd">    --------</span>
<span class="sd">        float: Angle between the vectors in radians.</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="k">return</span> <span class="n">np</span><span class="o">.</span><span class="n">arccos</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">clip</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">dot</span><span class="p">(</span><span class="n">vector1</span><span class="p">,</span> <span class="n">vector2</span><span class="p">)</span> <span class="o">/</span> <span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">linalg</span><span class="o">.</span><span class="n">norm</span><span class="p">(</span><span class="n">vector1</span><span class="p">)</span> <span class="o">*</span> <span class="n">np</span><span class="o">.</span><span class="n">linalg</span><span class="o">.</span><span class="n">norm</span><span class="p">(</span><span class="n">vector2</span><span class="p">)),</span> <span class="o">-</span><span class="mf">1.0</span><span class="p">,</span> <span class="mf">1.0</span><span class="p">))</span></div>


<div class="viewcode-block" id="rotation_matrix_from_vectors"><a class="viewcode-back" href="../../api/ssapy.utils.rotation_matrix_from_vectors.html#ssapy.utils.rotation_matrix_from_vectors">[docs]</a><span class="k">def</span><span class="w"> </span><span class="nf">rotation_matrix_from_vectors</span><span class="p">(</span><span class="n">vec1</span><span class="p">,</span> <span class="n">vec2</span><span class="p">):</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot; Find the rotation matrix that aligns vec1 to vec2</span>
<span class="sd">    :param vec1: A 3d &quot;source&quot; vector</span>
<span class="sd">    :param vec2: A 3d &quot;destination&quot; vector</span>
<span class="sd">    :return mat: A transform matrix (3x3) which when applied to vec1, aligns it with vec2.</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="n">a</span><span class="p">,</span> <span class="n">b</span> <span class="o">=</span> <span class="p">(</span><span class="n">vec1</span> <span class="o">/</span> <span class="n">np</span><span class="o">.</span><span class="n">linalg</span><span class="o">.</span><span class="n">norm</span><span class="p">(</span><span class="n">vec1</span><span class="p">))</span><span class="o">.</span><span class="n">reshape</span><span class="p">(</span><span class="mi">3</span><span class="p">),</span> <span class="p">(</span><span class="n">vec2</span> <span class="o">/</span> <span class="n">np</span><span class="o">.</span><span class="n">linalg</span><span class="o">.</span><span class="n">norm</span><span class="p">(</span><span class="n">vec2</span><span class="p">))</span><span class="o">.</span><span class="n">reshape</span><span class="p">(</span><span class="mi">3</span><span class="p">)</span>
    <span class="n">v</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">cross</span><span class="p">(</span><span class="n">a</span><span class="p">,</span> <span class="n">b</span><span class="p">)</span>
    <span class="n">c</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">dot</span><span class="p">(</span><span class="n">a</span><span class="p">,</span> <span class="n">b</span><span class="p">)</span>
    <span class="n">s</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">linalg</span><span class="o">.</span><span class="n">norm</span><span class="p">(</span><span class="n">v</span><span class="p">)</span>
    <span class="n">kmat</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">([[</span><span class="mi">0</span><span class="p">,</span> <span class="o">-</span><span class="n">v</span><span class="p">[</span><span class="mi">2</span><span class="p">],</span> <span class="n">v</span><span class="p">[</span><span class="mi">1</span><span class="p">]],</span> <span class="p">[</span><span class="n">v</span><span class="p">[</span><span class="mi">2</span><span class="p">],</span> <span class="mi">0</span><span class="p">,</span> <span class="o">-</span><span class="n">v</span><span class="p">[</span><span class="mi">0</span><span class="p">]],</span> <span class="p">[</span><span class="o">-</span><span class="n">v</span><span class="p">[</span><span class="mi">1</span><span class="p">],</span> <span class="n">v</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span> <span class="mi">0</span><span class="p">]])</span>
    <span class="n">rotation_matrix</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">eye</span><span class="p">(</span><span class="mi">3</span><span class="p">)</span> <span class="o">+</span> <span class="n">kmat</span> <span class="o">+</span> <span class="n">kmat</span><span class="o">.</span><span class="n">dot</span><span class="p">(</span><span class="n">kmat</span><span class="p">)</span> <span class="o">*</span> <span class="p">((</span><span class="mi">1</span> <span class="o">-</span> <span class="n">c</span><span class="p">)</span> <span class="o">/</span> <span class="p">(</span><span class="n">s</span><span class="o">**</span><span class="mi">2</span><span class="p">))</span>
    <span class="k">return</span> <span class="n">rotation_matrix</span></div>


<div class="viewcode-block" id="rotate_vector"><a class="viewcode-back" href="../../api/ssapy.utils.rotate_vector.html#ssapy.utils.rotate_vector">[docs]</a><span class="k">def</span><span class="w"> </span><span class="nf">rotate_vector</span><span class="p">(</span><span class="n">v_unit</span><span class="p">,</span> <span class="n">theta</span><span class="p">,</span> <span class="n">phi</span><span class="p">,</span> <span class="n">plot_path</span><span class="o">=</span><span class="kc">False</span><span class="p">,</span> <span class="n">save_idx</span><span class="o">=</span><span class="kc">False</span><span class="p">):</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Rotates a unit vector by specified angles and optionally plots the rotation path.</span>

<span class="sd">    Parameters:</span>
<span class="sd">    -----------</span>
<span class="sd">        v_unit (ndarray): Input unit vector to be rotated.</span>
<span class="sd">        theta (float): Rotation angle (in degrees) around a perpendicular axis.</span>
<span class="sd">        phi (float): Rotation angle (in degrees) around the input vector.</span>
<span class="sd">        plot_path (str, optional): Path to save the rotation plot. Defaults to False (no plot).</span>
<span class="sd">        save_idx (int, optional): Index for saving the plot file. Defaults to False.</span>

<span class="sd">    Returns:</span>
<span class="sd">    --------</span>
<span class="sd">        ndarray: Rotated unit vector.</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="n">v_unit</span> <span class="o">=</span> <span class="n">v_unit</span> <span class="o">/</span> <span class="n">np</span><span class="o">.</span><span class="n">linalg</span><span class="o">.</span><span class="n">norm</span><span class="p">(</span><span class="n">v_unit</span><span class="p">,</span> <span class="n">axis</span><span class="o">=-</span><span class="mi">1</span><span class="p">)</span>
    <span class="k">if</span> <span class="n">np</span><span class="o">.</span><span class="n">all</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">abs</span><span class="p">(</span><span class="n">v_unit</span><span class="p">)</span> <span class="o">!=</span> <span class="n">np</span><span class="o">.</span><span class="n">max</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">abs</span><span class="p">(</span><span class="n">v_unit</span><span class="p">))):</span>
        <span class="n">perp_vector</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">cross</span><span class="p">(</span><span class="n">v_unit</span><span class="p">,</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">([</span><span class="mi">1</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">]))</span>
    <span class="k">else</span><span class="p">:</span>
        <span class="n">perp_vector</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">cross</span><span class="p">(</span><span class="n">v_unit</span><span class="p">,</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">([</span><span class="mi">0</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="mi">0</span><span class="p">]))</span>
    <span class="n">perp_vector</span> <span class="o">/=</span> <span class="n">np</span><span class="o">.</span><span class="n">linalg</span><span class="o">.</span><span class="n">norm</span><span class="p">(</span><span class="n">perp_vector</span><span class="p">)</span>

    <span class="n">theta</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">radians</span><span class="p">(</span><span class="n">theta</span><span class="p">)</span>
    <span class="n">phi</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">radians</span><span class="p">(</span><span class="n">phi</span><span class="p">)</span>
    <span class="n">cos_theta</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">cos</span><span class="p">(</span><span class="n">theta</span><span class="p">)</span>
    <span class="n">sin_theta</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">sin</span><span class="p">(</span><span class="n">theta</span><span class="p">)</span>
    <span class="n">cos_phi</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">cos</span><span class="p">(</span><span class="n">phi</span><span class="p">)</span>
    <span class="n">sin_phi</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">sin</span><span class="p">(</span><span class="n">phi</span><span class="p">)</span>

    <span class="n">R1</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">([</span>
        <span class="p">[</span><span class="n">cos_theta</span> <span class="o">+</span> <span class="p">(</span><span class="mi">1</span> <span class="o">-</span> <span class="n">cos_theta</span><span class="p">)</span> <span class="o">*</span> <span class="n">perp_vector</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span><span class="o">**</span><span class="mi">2</span><span class="p">,</span> 
         <span class="p">(</span><span class="mi">1</span> <span class="o">-</span> <span class="n">cos_theta</span><span class="p">)</span> <span class="o">*</span> <span class="n">perp_vector</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">*</span> <span class="n">perp_vector</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span> <span class="o">-</span> <span class="n">sin_theta</span> <span class="o">*</span> <span class="n">perp_vector</span><span class="p">[</span><span class="mi">2</span><span class="p">],</span> 
         <span class="p">(</span><span class="mi">1</span> <span class="o">-</span> <span class="n">cos_theta</span><span class="p">)</span> <span class="o">*</span> <span class="n">perp_vector</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">*</span> <span class="n">perp_vector</span><span class="p">[</span><span class="mi">2</span><span class="p">]</span> <span class="o">+</span> <span class="n">sin_theta</span> <span class="o">*</span> <span class="n">perp_vector</span><span class="p">[</span><span class="mi">1</span><span class="p">]],</span>
        <span class="p">[(</span><span class="mi">1</span> <span class="o">-</span> <span class="n">cos_theta</span><span class="p">)</span> <span class="o">*</span> <span class="n">perp_vector</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span> <span class="o">*</span> <span class="n">perp_vector</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">+</span> <span class="n">sin_theta</span> <span class="o">*</span> <span class="n">perp_vector</span><span class="p">[</span><span class="mi">2</span><span class="p">],</span> 
         <span class="n">cos_theta</span> <span class="o">+</span> <span class="p">(</span><span class="mi">1</span> <span class="o">-</span> <span class="n">cos_theta</span><span class="p">)</span> <span class="o">*</span> <span class="n">perp_vector</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span><span class="o">**</span><span class="mi">2</span><span class="p">,</span> 
         <span class="p">(</span><span class="mi">1</span> <span class="o">-</span> <span class="n">cos_theta</span><span class="p">)</span> <span class="o">*</span> <span class="n">perp_vector</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span> <span class="o">*</span> <span class="n">perp_vector</span><span class="p">[</span><span class="mi">2</span><span class="p">]</span> <span class="o">-</span> <span class="n">sin_theta</span> <span class="o">*</span> <span class="n">perp_vector</span><span class="p">[</span><span class="mi">0</span><span class="p">]],</span>
        <span class="p">[(</span><span class="mi">1</span> <span class="o">-</span> <span class="n">cos_theta</span><span class="p">)</span> <span class="o">*</span> <span class="n">perp_vector</span><span class="p">[</span><span class="mi">2</span><span class="p">]</span> <span class="o">*</span> <span class="n">perp_vector</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">-</span> <span class="n">sin_theta</span> <span class="o">*</span> <span class="n">perp_vector</span><span class="p">[</span><span class="mi">1</span><span class="p">],</span> 
         <span class="p">(</span><span class="mi">1</span> <span class="o">-</span> <span class="n">cos_theta</span><span class="p">)</span> <span class="o">*</span> <span class="n">perp_vector</span><span class="p">[</span><span class="mi">2</span><span class="p">]</span> <span class="o">*</span> <span class="n">perp_vector</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span> <span class="o">+</span> <span class="n">sin_theta</span> <span class="o">*</span> <span class="n">perp_vector</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span> 
         <span class="n">cos_theta</span> <span class="o">+</span> <span class="p">(</span><span class="mi">1</span> <span class="o">-</span> <span class="n">cos_theta</span><span class="p">)</span> <span class="o">*</span> <span class="n">perp_vector</span><span class="p">[</span><span class="mi">2</span><span class="p">]</span><span class="o">**</span><span class="mi">2</span><span class="p">]</span>
    <span class="p">])</span>

    <span class="c1"># Apply the rotation matrix to v_unit to get the rotated unit vector</span>
    <span class="n">v1</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">dot</span><span class="p">(</span><span class="n">R1</span><span class="p">,</span> <span class="n">v_unit</span><span class="p">)</span>

    <span class="c1"># Rotation matrix for rotation about v_unit</span>
    <span class="n">R2</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">([[</span><span class="n">cos_phi</span> <span class="o">+</span> <span class="p">(</span><span class="mi">1</span> <span class="o">-</span> <span class="n">cos_phi</span><span class="p">)</span> <span class="o">*</span> <span class="n">v_unit</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span><span class="o">**</span><span class="mi">2</span><span class="p">,</span>
                    <span class="p">(</span><span class="mi">1</span> <span class="o">-</span> <span class="n">cos_phi</span><span class="p">)</span> <span class="o">*</span> <span class="n">v_unit</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">*</span> <span class="n">v_unit</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span> <span class="o">-</span> <span class="n">sin_phi</span> <span class="o">*</span> <span class="n">v_unit</span><span class="p">[</span><span class="mi">2</span><span class="p">],</span>
                    <span class="p">(</span><span class="mi">1</span> <span class="o">-</span> <span class="n">cos_phi</span><span class="p">)</span> <span class="o">*</span> <span class="n">v_unit</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">*</span> <span class="n">v_unit</span><span class="p">[</span><span class="mi">2</span><span class="p">]</span> <span class="o">+</span> <span class="n">sin_phi</span> <span class="o">*</span> <span class="n">v_unit</span><span class="p">[</span><span class="mi">1</span><span class="p">]],</span>
                   <span class="p">[(</span><span class="mi">1</span> <span class="o">-</span> <span class="n">cos_phi</span><span class="p">)</span> <span class="o">*</span> <span class="n">v_unit</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span> <span class="o">*</span> <span class="n">v_unit</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">+</span> <span class="n">sin_phi</span> <span class="o">*</span> <span class="n">v_unit</span><span class="p">[</span><span class="mi">2</span><span class="p">],</span>
                    <span class="n">cos_phi</span> <span class="o">+</span> <span class="p">(</span><span class="mi">1</span> <span class="o">-</span> <span class="n">cos_phi</span><span class="p">)</span> <span class="o">*</span> <span class="n">v_unit</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span><span class="o">**</span><span class="mi">2</span><span class="p">,</span>
                    <span class="p">(</span><span class="mi">1</span> <span class="o">-</span> <span class="n">cos_phi</span><span class="p">)</span> <span class="o">*</span> <span class="n">v_unit</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span> <span class="o">*</span> <span class="n">v_unit</span><span class="p">[</span><span class="mi">2</span><span class="p">]</span> <span class="o">-</span> <span class="n">sin_phi</span> <span class="o">*</span> <span class="n">v_unit</span><span class="p">[</span><span class="mi">0</span><span class="p">]],</span>
                   <span class="p">[(</span><span class="mi">1</span> <span class="o">-</span> <span class="n">cos_phi</span><span class="p">)</span> <span class="o">*</span> <span class="n">v_unit</span><span class="p">[</span><span class="mi">2</span><span class="p">]</span> <span class="o">*</span> <span class="n">v_unit</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">-</span> <span class="n">sin_phi</span> <span class="o">*</span> <span class="n">v_unit</span><span class="p">[</span><span class="mi">1</span><span class="p">],</span>
                    <span class="p">(</span><span class="mi">1</span> <span class="o">-</span> <span class="n">cos_phi</span><span class="p">)</span> <span class="o">*</span> <span class="n">v_unit</span><span class="p">[</span><span class="mi">2</span><span class="p">]</span> <span class="o">*</span> <span class="n">v_unit</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span> <span class="o">+</span> <span class="n">sin_phi</span> <span class="o">*</span> <span class="n">v_unit</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span>
                    <span class="n">cos_phi</span> <span class="o">+</span> <span class="p">(</span><span class="mi">1</span> <span class="o">-</span> <span class="n">cos_phi</span><span class="p">)</span> <span class="o">*</span> <span class="n">v_unit</span><span class="p">[</span><span class="mi">2</span><span class="p">]</span><span class="o">**</span><span class="mi">2</span><span class="p">]])</span>

    <span class="n">v2</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">dot</span><span class="p">(</span><span class="n">R2</span><span class="p">,</span> <span class="n">v1</span><span class="p">)</span>

    <span class="k">if</span> <span class="n">plot_path</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">False</span><span class="p">:</span>
        <span class="kn">import</span><span class="w"> </span><span class="nn">matplotlib.pyplot</span><span class="w"> </span><span class="k">as</span><span class="w"> </span><span class="nn">plt</span>
        <span class="n">plt</span><span class="o">.</span><span class="n">rcParams</span><span class="o">.</span><span class="n">update</span><span class="p">({</span><span class="s1">&#39;font.size&#39;</span><span class="p">:</span> <span class="mi">9</span><span class="p">,</span> <span class="s1">&#39;figure.facecolor&#39;</span><span class="p">:</span> <span class="s1">&#39;black&#39;</span><span class="p">})</span>
        <span class="n">fig</span> <span class="o">=</span> <span class="n">plt</span><span class="o">.</span><span class="n">figure</span><span class="p">()</span>
        <span class="n">ax</span> <span class="o">=</span> <span class="n">fig</span><span class="o">.</span><span class="n">add_subplot</span><span class="p">(</span><span class="mi">111</span><span class="p">,</span> <span class="n">projection</span><span class="o">=</span><span class="s1">&#39;3d&#39;</span><span class="p">)</span>
        <span class="n">ax</span><span class="o">.</span><span class="n">quiver</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="n">v_unit</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span> <span class="n">v_unit</span><span class="p">[</span><span class="mi">1</span><span class="p">],</span> <span class="n">v_unit</span><span class="p">[</span><span class="mi">2</span><span class="p">],</span> <span class="n">color</span><span class="o">=</span><span class="s1">&#39;b&#39;</span><span class="p">)</span>
        <span class="n">ax</span><span class="o">.</span><span class="n">quiver</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="n">v1</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span> <span class="n">v1</span><span class="p">[</span><span class="mi">1</span><span class="p">],</span> <span class="n">v1</span><span class="p">[</span><span class="mi">2</span><span class="p">],</span> <span class="n">color</span><span class="o">=</span><span class="s1">&#39;g&#39;</span><span class="p">)</span>
        <span class="n">ax</span><span class="o">.</span><span class="n">quiver</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="n">v2</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span> <span class="n">v2</span><span class="p">[</span><span class="mi">1</span><span class="p">],</span> <span class="n">v2</span><span class="p">[</span><span class="mi">2</span><span class="p">],</span> <span class="n">color</span><span class="o">=</span><span class="s1">&#39;r&#39;</span><span class="p">)</span>
        <span class="n">ax</span><span class="o">.</span><span class="n">set_xlabel</span><span class="p">(</span><span class="s1">&#39;X&#39;</span><span class="p">,</span> <span class="n">color</span><span class="o">=</span><span class="s1">&#39;white&#39;</span><span class="p">)</span>
        <span class="n">ax</span><span class="o">.</span><span class="n">set_ylabel</span><span class="p">(</span><span class="s1">&#39;Y&#39;</span><span class="p">,</span> <span class="n">color</span><span class="o">=</span><span class="s1">&#39;white&#39;</span><span class="p">)</span>
        <span class="n">ax</span><span class="o">.</span><span class="n">set_zlabel</span><span class="p">(</span><span class="s1">&#39;Z&#39;</span><span class="p">,</span> <span class="n">color</span><span class="o">=</span><span class="s1">&#39;white&#39;</span><span class="p">)</span>
        <span class="n">ax</span><span class="o">.</span><span class="n">set_facecolor</span><span class="p">(</span><span class="s1">&#39;black&#39;</span><span class="p">)</span>  <span class="c1"># Set plot background color to black</span>
        <span class="n">ax</span><span class="o">.</span><span class="n">tick_params</span><span class="p">(</span><span class="n">axis</span><span class="o">=</span><span class="s1">&#39;x&#39;</span><span class="p">,</span> <span class="n">colors</span><span class="o">=</span><span class="s1">&#39;white&#39;</span><span class="p">)</span>  <span class="c1"># Set x-axis tick color to white</span>
        <span class="n">ax</span><span class="o">.</span><span class="n">tick_params</span><span class="p">(</span><span class="n">axis</span><span class="o">=</span><span class="s1">&#39;y&#39;</span><span class="p">,</span> <span class="n">colors</span><span class="o">=</span><span class="s1">&#39;white&#39;</span><span class="p">)</span>  <span class="c1"># Set y-axis tick color to white</span>
        <span class="n">ax</span><span class="o">.</span><span class="n">tick_params</span><span class="p">(</span><span class="n">axis</span><span class="o">=</span><span class="s1">&#39;z&#39;</span><span class="p">,</span> <span class="n">colors</span><span class="o">=</span><span class="s1">&#39;white&#39;</span><span class="p">)</span>  <span class="c1"># Set z-axis tick color to white</span>
        <span class="n">ax</span><span class="o">.</span><span class="n">set_title</span><span class="p">(</span><span class="s1">&#39;Vector Plot&#39;</span><span class="p">,</span> <span class="n">color</span><span class="o">=</span><span class="s1">&#39;white&#39;</span><span class="p">)</span>
        <span class="n">ax</span><span class="o">.</span><span class="n">set_xlim</span><span class="p">(</span><span class="o">-</span><span class="mi">1</span><span class="p">,</span> <span class="mi">1</span><span class="p">)</span>
        <span class="n">ax</span><span class="o">.</span><span class="n">set_ylim</span><span class="p">(</span><span class="o">-</span><span class="mi">1</span><span class="p">,</span> <span class="mi">1</span><span class="p">)</span>
        <span class="n">ax</span><span class="o">.</span><span class="n">set_zlim</span><span class="p">(</span><span class="o">-</span><span class="mi">1</span><span class="p">,</span> <span class="mi">1</span><span class="p">)</span>
        <span class="n">plt</span><span class="o">.</span><span class="n">grid</span><span class="p">(</span><span class="kc">True</span><span class="p">)</span>
        <span class="k">if</span> <span class="n">save_idx</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">False</span><span class="p">:</span>
            <span class="kn">from</span><span class="w"> </span><span class="nn">.plotUtils</span><span class="w"> </span><span class="kn">import</span> <span class="n">save_plot</span>
            <span class="n">ax</span><span class="o">.</span><span class="n">set_title</span><span class="p">(</span><span class="sa">f</span><span class="s1">&#39;Vector Plot</span><span class="se">\n</span><span class="s1">theta: </span><span class="si">{</span><span class="n">np</span><span class="o">.</span><span class="n">degrees</span><span class="p">(</span><span class="n">theta</span><span class="p">)</span><span class="si">:</span><span class="s1">.0f</span><span class="si">}</span><span class="s1">, phi: </span><span class="si">{</span><span class="n">np</span><span class="o">.</span><span class="n">degrees</span><span class="p">(</span><span class="n">phi</span><span class="p">)</span><span class="si">:</span><span class="s1">.0f</span><span class="si">}</span><span class="s1">&#39;</span><span class="p">,</span> <span class="n">color</span><span class="o">=</span><span class="s1">&#39;white&#39;</span><span class="p">)</span>
            <span class="n">save_plot</span><span class="p">(</span><span class="n">fig</span><span class="p">,</span> <span class="sa">f</span><span class="s2">&quot;</span><span class="si">{</span><span class="n">plot_path</span><span class="si">}{</span><span class="n">save_idx</span><span class="si">}</span><span class="s2">.png&quot;</span><span class="p">)</span>
    <span class="k">return</span> <span class="n">v2</span> <span class="o">/</span> <span class="n">np</span><span class="o">.</span><span class="n">linalg</span><span class="o">.</span><span class="n">norm</span><span class="p">(</span><span class="n">v2</span><span class="p">,</span> <span class="n">axis</span><span class="o">=-</span><span class="mi">1</span><span class="p">)</span></div>


<div class="viewcode-block" id="rotate_points_3d"><a class="viewcode-back" href="../../api/ssapy.utils.rotate_points_3d.html#ssapy.utils.rotate_points_3d">[docs]</a><span class="k">def</span><span class="w"> </span><span class="nf">rotate_points_3d</span><span class="p">(</span><span class="n">points</span><span class="p">,</span> <span class="n">axis</span><span class="o">=</span><span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">([</span><span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">1</span><span class="p">]),</span> <span class="n">theta</span><span class="o">=-</span><span class="n">np</span><span class="o">.</span><span class="n">pi</span> <span class="o">/</span> <span class="mi">2</span><span class="p">):</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Rotate a set of 3D points about a 3D axis by an angle theta in radians.</span>

<span class="sd">    Args:</span>
<span class="sd">        points (np.ndarray): The set of 3D points to rotate, as an Nx3 array.</span>
<span class="sd">        axis (np.ndarray): The 3D axis to rotate about, as a length-3 array. Default is the z-axis.</span>
<span class="sd">        theta (float): The angle to rotate by, in radians. Default is pi/2.</span>

<span class="sd">    Returns:</span>
<span class="sd">        np.ndarray: The rotated set of 3D points, as an Nx3 array.</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="c1"># Normalize the axis to be a unit vector</span>
    <span class="n">axis</span> <span class="o">=</span> <span class="n">axis</span> <span class="o">/</span> <span class="n">np</span><span class="o">.</span><span class="n">linalg</span><span class="o">.</span><span class="n">norm</span><span class="p">(</span><span class="n">axis</span><span class="p">)</span>

    <span class="c1"># Compute the quaternion representing the rotation</span>
    <span class="n">qw</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">cos</span><span class="p">(</span><span class="n">theta</span> <span class="o">/</span> <span class="mi">2</span><span class="p">)</span>
    <span class="n">qx</span><span class="p">,</span> <span class="n">qy</span><span class="p">,</span> <span class="n">qz</span> <span class="o">=</span> <span class="n">axis</span> <span class="o">*</span> <span class="n">np</span><span class="o">.</span><span class="n">sin</span><span class="p">(</span><span class="n">theta</span> <span class="o">/</span> <span class="mi">2</span><span class="p">)</span>

    <span class="c1"># Construct the rotation matrix from the quaternion</span>
    <span class="n">R</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">([</span>
        <span class="p">[</span><span class="mi">1</span> <span class="o">-</span> <span class="mi">2</span> <span class="o">*</span> <span class="n">qy</span><span class="o">**</span><span class="mi">2</span> <span class="o">-</span> <span class="mi">2</span> <span class="o">*</span> <span class="n">qz</span><span class="o">**</span><span class="mi">2</span><span class="p">,</span> <span class="mi">2</span> <span class="o">*</span> <span class="n">qx</span> <span class="o">*</span> <span class="n">qy</span> <span class="o">-</span> <span class="mi">2</span> <span class="o">*</span> <span class="n">qz</span> <span class="o">*</span> <span class="n">qw</span><span class="p">,</span> <span class="mi">2</span> <span class="o">*</span> <span class="n">qx</span> <span class="o">*</span> <span class="n">qz</span> <span class="o">+</span> <span class="mi">2</span> <span class="o">*</span> <span class="n">qy</span> <span class="o">*</span> <span class="n">qw</span><span class="p">],</span>
        <span class="p">[</span><span class="mi">2</span> <span class="o">*</span> <span class="n">qx</span> <span class="o">*</span> <span class="n">qy</span> <span class="o">+</span> <span class="mi">2</span> <span class="o">*</span> <span class="n">qz</span> <span class="o">*</span> <span class="n">qw</span><span class="p">,</span> <span class="mi">1</span> <span class="o">-</span> <span class="mi">2</span> <span class="o">*</span> <span class="n">qx</span><span class="o">**</span><span class="mi">2</span> <span class="o">-</span> <span class="mi">2</span> <span class="o">*</span> <span class="n">qz</span><span class="o">**</span><span class="mi">2</span><span class="p">,</span> <span class="mi">2</span> <span class="o">*</span> <span class="n">qy</span> <span class="o">*</span> <span class="n">qz</span> <span class="o">-</span> <span class="mi">2</span> <span class="o">*</span> <span class="n">qx</span> <span class="o">*</span> <span class="n">qw</span><span class="p">],</span>
        <span class="p">[</span><span class="mi">2</span> <span class="o">*</span> <span class="n">qx</span> <span class="o">*</span> <span class="n">qz</span> <span class="o">-</span> <span class="mi">2</span> <span class="o">*</span> <span class="n">qy</span> <span class="o">*</span> <span class="n">qw</span><span class="p">,</span> <span class="mi">2</span> <span class="o">*</span> <span class="n">qy</span> <span class="o">*</span> <span class="n">qz</span> <span class="o">+</span> <span class="mi">2</span> <span class="o">*</span> <span class="n">qx</span> <span class="o">*</span> <span class="n">qw</span><span class="p">,</span> <span class="mi">1</span> <span class="o">-</span> <span class="mi">2</span> <span class="o">*</span> <span class="n">qx</span><span class="o">**</span><span class="mi">2</span> <span class="o">-</span> <span class="mi">2</span> <span class="o">*</span> <span class="n">qy</span><span class="o">**</span><span class="mi">2</span><span class="p">]</span>
    <span class="p">])</span>

    <span class="c1"># Apply the rotation matrix to the set of points</span>
    <span class="n">rotated_points</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">dot</span><span class="p">(</span><span class="n">R</span><span class="p">,</span> <span class="n">points</span><span class="o">.</span><span class="n">T</span><span class="p">)</span><span class="o">.</span><span class="n">T</span>

    <span class="k">return</span> <span class="n">rotated_points</span></div>


<div class="viewcode-block" id="perpendicular_vectors"><a class="viewcode-back" href="../../api/ssapy.utils.perpendicular_vectors.html#ssapy.utils.perpendicular_vectors">[docs]</a><span class="k">def</span><span class="w"> </span><span class="nf">perpendicular_vectors</span><span class="p">(</span><span class="n">v</span><span class="p">):</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;Returns two vectors that are perpendicular to v and each other.&quot;&quot;&quot;</span>
    <span class="c1"># Check if v is the zero vector</span>
    <span class="k">if</span> <span class="n">np</span><span class="o">.</span><span class="n">allclose</span><span class="p">(</span><span class="n">v</span><span class="p">,</span> <span class="n">np</span><span class="o">.</span><span class="n">zeros_like</span><span class="p">(</span><span class="n">v</span><span class="p">)):</span>
        <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s2">&quot;Input vector cannot be the zero vector.&quot;</span><span class="p">)</span>

    <span class="c1"># Choose an arbitrary non-zero vector w that is not parallel to v</span>
    <span class="n">w</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">([</span><span class="mf">1.</span><span class="p">,</span> <span class="mf">0.</span><span class="p">,</span> <span class="mf">0.</span><span class="p">])</span>
    <span class="k">if</span> <span class="n">np</span><span class="o">.</span><span class="n">allclose</span><span class="p">(</span><span class="n">v</span><span class="p">,</span> <span class="n">w</span><span class="p">)</span> <span class="ow">or</span> <span class="n">np</span><span class="o">.</span><span class="n">allclose</span><span class="p">(</span><span class="n">v</span><span class="p">,</span> <span class="o">-</span><span class="n">w</span><span class="p">):</span>
        <span class="n">w</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">([</span><span class="mf">0.</span><span class="p">,</span> <span class="mf">1.</span><span class="p">,</span> <span class="mf">0.</span><span class="p">])</span>
    <span class="n">u</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">cross</span><span class="p">(</span><span class="n">v</span><span class="p">,</span> <span class="n">w</span><span class="p">)</span>
    <span class="k">if</span> <span class="n">np</span><span class="o">.</span><span class="n">allclose</span><span class="p">(</span><span class="n">u</span><span class="p">,</span> <span class="n">np</span><span class="o">.</span><span class="n">zeros_like</span><span class="p">(</span><span class="n">u</span><span class="p">)):</span>
        <span class="n">w</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">([</span><span class="mf">0.</span><span class="p">,</span> <span class="mf">0.</span><span class="p">,</span> <span class="mf">1.</span><span class="p">])</span>
        <span class="n">u</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">cross</span><span class="p">(</span><span class="n">v</span><span class="p">,</span> <span class="n">w</span><span class="p">)</span>
    <span class="n">w</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">cross</span><span class="p">(</span><span class="n">v</span><span class="p">,</span> <span class="n">u</span><span class="p">)</span>

    <span class="k">return</span> <span class="n">u</span><span class="p">,</span> <span class="n">w</span></div>


<div class="viewcode-block" id="points_on_circle"><a class="viewcode-back" href="../../api/ssapy.utils.points_on_circle.html#ssapy.utils.points_on_circle">[docs]</a><span class="k">def</span><span class="w"> </span><span class="nf">points_on_circle</span><span class="p">(</span><span class="n">r</span><span class="p">,</span> <span class="n">v</span><span class="p">,</span> <span class="n">rad</span><span class="p">,</span> <span class="n">num_points</span><span class="o">=</span><span class="mi">4</span><span class="p">):</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Generate points on a circle in 3D space.</span>

<span class="sd">    The circle is defined by its center `r`, radius `rad`, and a normal vector `v`.</span>
<span class="sd">    The function computes `num_points` evenly spaced points on the circle.</span>

<span class="sd">    Parameters:</span>
<span class="sd">    -----------</span>
<span class="sd">        r (numpy.ndarray): A 3D vector representing the center of the circle.</span>
<span class="sd">        v (numpy.ndarray): A 3D vector representing the normal to the circle&#39;s plane.</span>
<span class="sd">        rad (float): The radius of the circle.</span>
<span class="sd">        num_points (int, optional): The number of points to generate on the circle. </span>
<span class="sd">                                    Defaults to 4.</span>

<span class="sd">    Returns:</span>
<span class="sd">    --------</span>
<span class="sd">        numpy.ndarray: An array of shape (num_points, 3), where each row represents </span>
<span class="sd">                       the coordinates of a point on the circle.</span>

<span class="sd">    Raises:</span>
<span class="sd">    -------</span>
<span class="sd">        ValueError: If the normal vector `v` is the zero vector.</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="c1"># Convert inputs to numpy arrays</span>
    <span class="n">r</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">(</span><span class="n">r</span><span class="p">)</span>
    <span class="n">v</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">(</span><span class="n">v</span><span class="p">)</span>

    <span class="c1"># Find the perpendicular vectors to the given vector v</span>
    <span class="k">if</span> <span class="n">np</span><span class="o">.</span><span class="n">all</span><span class="p">(</span><span class="n">v</span><span class="p">[:</span><span class="mi">2</span><span class="p">]</span> <span class="o">==</span> <span class="mi">0</span><span class="p">):</span>
        <span class="k">if</span> <span class="n">np</span><span class="o">.</span><span class="n">all</span><span class="p">(</span><span class="n">v</span><span class="p">[</span><span class="mi">2</span><span class="p">]</span> <span class="o">==</span> <span class="mi">0</span><span class="p">):</span>
            <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s2">&quot;The given vector v must not be the zero vector.&quot;</span><span class="p">)</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">u</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">([</span><span class="mi">1</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">])</span>
    <span class="k">else</span><span class="p">:</span>
        <span class="n">u</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">([</span><span class="o">-</span><span class="n">v</span><span class="p">[</span><span class="mi">1</span><span class="p">],</span> <span class="n">v</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span> <span class="mi">0</span><span class="p">])</span>
    <span class="n">u</span> <span class="o">=</span> <span class="n">u</span> <span class="o">/</span> <span class="n">np</span><span class="o">.</span><span class="n">linalg</span><span class="o">.</span><span class="n">norm</span><span class="p">(</span><span class="n">u</span><span class="p">)</span>
    <span class="n">w</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">cross</span><span class="p">(</span><span class="n">u</span><span class="p">,</span> <span class="n">v</span><span class="p">)</span>
    <span class="n">w_norm</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">linalg</span><span class="o">.</span><span class="n">norm</span><span class="p">(</span><span class="n">w</span><span class="p">)</span>
    <span class="k">if</span> <span class="n">w_norm</span> <span class="o">&lt;</span> <span class="mf">1e-15</span><span class="p">:</span>
        <span class="c1"># v is parallel to z-axis</span>
        <span class="n">w</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">([</span><span class="mi">0</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="mi">0</span><span class="p">])</span>
    <span class="k">else</span><span class="p">:</span>
        <span class="n">w</span> <span class="o">=</span> <span class="n">w</span> <span class="o">/</span> <span class="n">w_norm</span>
    <span class="c1"># Generate a sequence of angles for equally spaced points</span>
    <span class="n">angles</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">linspace</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="mi">2</span> <span class="o">*</span> <span class="n">np</span><span class="o">.</span><span class="n">pi</span><span class="p">,</span> <span class="n">num_points</span><span class="p">,</span> <span class="n">endpoint</span><span class="o">=</span><span class="kc">False</span><span class="p">)</span>

    <span class="c1"># Compute the x, y, z coordinates of each point on the circle</span>
    <span class="n">x</span> <span class="o">=</span> <span class="n">rad</span> <span class="o">*</span> <span class="n">np</span><span class="o">.</span><span class="n">cos</span><span class="p">(</span><span class="n">angles</span><span class="p">)</span> <span class="o">*</span> <span class="n">u</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">+</span> <span class="n">rad</span> <span class="o">*</span> <span class="n">np</span><span class="o">.</span><span class="n">sin</span><span class="p">(</span><span class="n">angles</span><span class="p">)</span> <span class="o">*</span> <span class="n">w</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span>
    <span class="n">y</span> <span class="o">=</span> <span class="n">rad</span> <span class="o">*</span> <span class="n">np</span><span class="o">.</span><span class="n">cos</span><span class="p">(</span><span class="n">angles</span><span class="p">)</span> <span class="o">*</span> <span class="n">u</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span> <span class="o">+</span> <span class="n">rad</span> <span class="o">*</span> <span class="n">np</span><span class="o">.</span><span class="n">sin</span><span class="p">(</span><span class="n">angles</span><span class="p">)</span> <span class="o">*</span> <span class="n">w</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span>
    <span class="n">z</span> <span class="o">=</span> <span class="n">rad</span> <span class="o">*</span> <span class="n">np</span><span class="o">.</span><span class="n">cos</span><span class="p">(</span><span class="n">angles</span><span class="p">)</span> <span class="o">*</span> <span class="n">u</span><span class="p">[</span><span class="mi">2</span><span class="p">]</span> <span class="o">+</span> <span class="n">rad</span> <span class="o">*</span> <span class="n">np</span><span class="o">.</span><span class="n">sin</span><span class="p">(</span><span class="n">angles</span><span class="p">)</span> <span class="o">*</span> <span class="n">w</span><span class="p">[</span><span class="mi">2</span><span class="p">]</span>

    <span class="c1"># Apply rotation about z-axis by 90 degrees</span>
    <span class="n">rot_matrix</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">([[</span><span class="mi">0</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="mi">0</span><span class="p">],</span> <span class="p">[</span><span class="o">-</span><span class="mi">1</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">],</span> <span class="p">[</span><span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">1</span><span class="p">]])</span>
    <span class="n">rotated_points</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">dot</span><span class="p">(</span><span class="n">rot_matrix</span><span class="p">,</span> <span class="n">np</span><span class="o">.</span><span class="n">column_stack</span><span class="p">((</span><span class="n">x</span><span class="p">,</span> <span class="n">y</span><span class="p">,</span> <span class="n">z</span><span class="p">))</span><span class="o">.</span><span class="n">T</span><span class="p">)</span><span class="o">.</span><span class="n">T</span>

    <span class="c1"># Translate the rotated points to the center point r</span>
    <span class="n">points_rotated</span> <span class="o">=</span> <span class="n">rotated_points</span> <span class="o">+</span> <span class="n">r</span><span class="o">.</span><span class="n">reshape</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span> <span class="mi">3</span><span class="p">)</span>

    <span class="k">return</span> <span class="n">points_rotated</span></div>


<div class="viewcode-block" id="dms_to_rad"><a class="viewcode-back" href="../../api/ssapy.utils.dms_to_rad.html#ssapy.utils.dms_to_rad">[docs]</a><span class="k">def</span><span class="w"> </span><span class="nf">dms_to_rad</span><span class="p">(</span><span class="n">coords</span><span class="p">):</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Convert coordinates from degrees, minutes, and seconds (DMS) format to radians.</span>

<span class="sd">    Parameters:</span>
<span class="sd">    -----------</span>
<span class="sd">        coords (str, list, or tuple): </span>
<span class="sd">            - A single DMS coordinate as a string (e.g., &quot;12d34m56s&quot;).</span>
<span class="sd">            - A list or tuple of DMS coordinates as strings.</span>

<span class="sd">    Returns:</span>
<span class="sd">    --------</span>
<span class="sd">        float or list: </span>
<span class="sd">            - If a single coordinate is provided, returns its value in radians.</span>
<span class="sd">            - If multiple coordinates are provided (list or tuple), returns a list </span>
<span class="sd">              of values in radians.</span>

<span class="sd">    Example:</span>
<span class="sd">    --------</span>
<span class="sd">        dms_to_rad(&quot;12d34m56s&quot;) -&gt; 0.219725</span>
<span class="sd">        dms_to_rad([&quot;12d34m56s&quot;, &quot;45d67m89s&quot;]) -&gt; [0.219725, 0.798488]</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="kn">from</span><span class="w"> </span><span class="nn">astropy.coordinates</span><span class="w"> </span><span class="kn">import</span> <span class="n">Angle</span>
    <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">coords</span><span class="p">,</span> <span class="p">(</span><span class="nb">list</span><span class="p">,</span> <span class="nb">tuple</span><span class="p">)):</span>
        <span class="k">return</span> <span class="p">[</span><span class="n">Angle</span><span class="p">(</span><span class="n">coord</span><span class="p">)</span><span class="o">.</span><span class="n">radian</span> <span class="k">for</span> <span class="n">coord</span> <span class="ow">in</span> <span class="n">coords</span><span class="p">]</span>
    <span class="k">else</span><span class="p">:</span>
        <span class="k">return</span> <span class="n">Angle</span><span class="p">(</span><span class="n">coords</span><span class="p">)</span><span class="o">.</span><span class="n">radian</span>
    <span class="k">return</span></div>


<div class="viewcode-block" id="dms_to_deg"><a class="viewcode-back" href="../../api/ssapy.utils.dms_to_deg.html#ssapy.utils.dms_to_deg">[docs]</a><span class="k">def</span><span class="w"> </span><span class="nf">dms_to_deg</span><span class="p">(</span><span class="n">coords</span><span class="p">):</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Convert coordinates from degrees, minutes, and seconds (DMS) format to decimal degrees.</span>

<span class="sd">    Parameters:</span>
<span class="sd">    -----------</span>
<span class="sd">        coords (str, list, or tuple): </span>
<span class="sd">            - A single DMS coordinate as a string (e.g., &quot;12d34m56s&quot;).</span>
<span class="sd">            - A list or tuple of DMS coordinates as strings.</span>

<span class="sd">    Returns:</span>
<span class="sd">    --------</span>
<span class="sd">        float or list: </span>
<span class="sd">            - If a single coordinate is provided, returns its value in decimal degrees.</span>
<span class="sd">            - If multiple coordinates are provided (list or tuple), returns a list </span>
<span class="sd">              of values in decimal degrees.</span>

<span class="sd">    Example:</span>
<span class="sd">    --------</span>
<span class="sd">        dms_to_deg(&quot;12d34m56s&quot;) -&gt; 12.582222</span>
<span class="sd">        dms_to_deg([&quot;12d34m56s&quot;, &quot;45d67m89s&quot;]) -&gt; [12.582222, 46.135806]</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="kn">from</span><span class="w"> </span><span class="nn">astropy.coordinates</span><span class="w"> </span><span class="kn">import</span> <span class="n">Angle</span>
    <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">coords</span><span class="p">,</span> <span class="p">(</span><span class="nb">list</span><span class="p">,</span> <span class="nb">tuple</span><span class="p">)):</span>
        <span class="k">return</span> <span class="p">[</span><span class="n">Angle</span><span class="p">(</span><span class="n">coord</span><span class="p">)</span><span class="o">.</span><span class="n">deg</span> <span class="k">for</span> <span class="n">coord</span> <span class="ow">in</span> <span class="n">coords</span><span class="p">]</span>
    <span class="k">else</span><span class="p">:</span>
        <span class="k">return</span> <span class="n">Angle</span><span class="p">(</span><span class="n">coords</span><span class="p">)</span><span class="o">.</span><span class="n">deg</span>
    <span class="k">return</span></div>


<div class="viewcode-block" id="rad0to2pi"><a class="viewcode-back" href="../../api/ssapy.utils.rad0to2pi.html#ssapy.utils.rad0to2pi">[docs]</a><span class="k">def</span><span class="w"> </span><span class="nf">rad0to2pi</span><span class="p">(</span><span class="n">angles</span><span class="p">):</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Normalize angles in radians to the range [0, 2π].</span>

<span class="sd">    Parameters:</span>
<span class="sd">    -----------</span>
<span class="sd">        angles (float or numpy array): </span>
<span class="sd">            - A single angle in radians or an array of angles in radians.</span>
<span class="sd">            - Negative angles will be adjusted to fall within the range [0, 2π].</span>

<span class="sd">    Returns:</span>
<span class="sd">    --------</span>
<span class="sd">        float or numpy array: </span>
<span class="sd">            - The normalized angle(s) in radians within the range [0, 2π].</span>

<span class="sd">    Example:</span>
<span class="sd">    --------</span>
<span class="sd">        rad0to2pi(-1.0) -&gt; 5.283185307179586</span>
<span class="sd">        rad0to2pi(np.array([-1.0, 3.0])) -&gt; array([5.28318531, 3.0])</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="k">return</span> <span class="p">(</span><span class="mi">2</span> <span class="o">*</span> <span class="n">np</span><span class="o">.</span><span class="n">pi</span> <span class="o">+</span> <span class="n">angles</span><span class="p">)</span> <span class="o">*</span> <span class="p">(</span><span class="n">angles</span> <span class="o">&lt;</span> <span class="mi">0</span><span class="p">)</span> <span class="o">+</span> <span class="n">angles</span> <span class="o">*</span> <span class="p">(</span><span class="n">angles</span> <span class="o">&gt;</span> <span class="mi">0</span><span class="p">)</span></div>


<div class="viewcode-block" id="deg0to360"><a class="viewcode-back" href="../../api/ssapy.utils.deg0to360.html#ssapy.utils.deg0to360">[docs]</a><span class="k">def</span><span class="w"> </span><span class="nf">deg0to360</span><span class="p">(</span><span class="n">array_</span><span class="p">):</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Normalize angles in degrees to the range [0, 360].</span>

<span class="sd">    Parameters:</span>
<span class="sd">    -----------</span>
<span class="sd">        array_ (int, float, or iterable): </span>
<span class="sd">            - A single angle in degrees (int or float).</span>
<span class="sd">            - An iterable (e.g., list, tuple, or numpy array) of angles in degrees.</span>

<span class="sd">    Returns:</span>
<span class="sd">    --------</span>
<span class="sd">        int, float, or list: </span>
<span class="sd">            - If a single angle is provided, returns the normalized angle in the range [0, 360].</span>
<span class="sd">            - If an iterable of angles is provided, returns a list of normalized angles in the range [0, 360].</span>

<span class="sd">    Example:</span>
<span class="sd">    --------</span>
<span class="sd">        deg0to360(370) -&gt; 10</span>
<span class="sd">        deg0to360([-10, 370, 720]) -&gt; [350, 10, 0]</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="k">try</span><span class="p">:</span>
        <span class="k">return</span> <span class="p">[</span><span class="n">i</span> <span class="o">%</span> <span class="mi">360</span> <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="n">array_</span><span class="p">]</span>
    <span class="k">except</span> <span class="ne">TypeError</span><span class="p">:</span>
        <span class="k">return</span> <span class="n">array_</span> <span class="o">%</span> <span class="mi">360</span></div>


<div class="viewcode-block" id="deg0to360array"><a class="viewcode-back" href="../../api/ssapy.utils.deg0to360array.html#ssapy.utils.deg0to360array">[docs]</a><span class="k">def</span><span class="w"> </span><span class="nf">deg0to360array</span><span class="p">(</span><span class="n">array_</span><span class="p">):</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Normalize an array of angles in degrees to the range [0, 360].</span>

<span class="sd">    Parameters:</span>
<span class="sd">    -----------</span>
<span class="sd">        array_ (iterable): </span>
<span class="sd">            - An iterable (e.g., list, tuple, or numpy array) of angles in degrees.</span>

<span class="sd">    Returns:</span>
<span class="sd">    --------</span>
<span class="sd">        list: </span>
<span class="sd">            - A list of normalized angles in the range [0, 360].</span>

<span class="sd">    Example:</span>
<span class="sd">    --------</span>
<span class="sd">        deg0to360array([-10, 370, 720]) -&gt; [350, 10, 0]</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="k">return</span> <span class="p">[</span><span class="n">i</span> <span class="o">%</span> <span class="mi">360</span> <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="n">array_</span><span class="p">]</span></div>


<div class="viewcode-block" id="deg90to90"><a class="viewcode-back" href="../../api/ssapy.utils.deg90to90.html#ssapy.utils.deg90to90">[docs]</a><span class="k">def</span><span class="w"> </span><span class="nf">deg90to90</span><span class="p">(</span><span class="n">val_in</span><span class="p">):</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Normalize angles to the range [-90, 90].</span>

<span class="sd">    This function adjusts angles such that they fall within the range [-90, 90]. </span>
<span class="sd">    It works for both single values and iterable inputs.</span>

<span class="sd">    Parameters:</span>
<span class="sd">    -----------</span>
<span class="sd">        val_in (int, float, or iterable): </span>
<span class="sd">            - A single angle (int or float).</span>
<span class="sd">            - An iterable (e.g., list, tuple, or numpy array) of angles.</span>

<span class="sd">    Returns:</span>
<span class="sd">    --------</span>
<span class="sd">        int, float, or list: </span>
<span class="sd">            - If a single angle is provided, returns the normalized angle in the range [-90, 90].</span>
<span class="sd">            - If an iterable of angles is provided, returns a list of normalized angles in the range [-90, 90].</span>

<span class="sd">    Example:</span>
<span class="sd">    --------</span>
<span class="sd">        deg90to90(100) -&gt; 10</span>
<span class="sd">        deg90to90([-100, 200, -270]) -&gt; [-10, -70, -90]</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="k">if</span> <span class="nb">hasattr</span><span class="p">(</span><span class="n">val_in</span><span class="p">,</span> <span class="s2">&quot;__len__&quot;</span><span class="p">):</span>
        <span class="n">val_out</span> <span class="o">=</span> <span class="p">[]</span>
        <span class="k">for</span> <span class="n">i</span><span class="p">,</span> <span class="n">v</span> <span class="ow">in</span> <span class="nb">enumerate</span><span class="p">(</span><span class="n">val_in</span><span class="p">):</span>
            <span class="k">while</span> <span class="n">v</span> <span class="o">&lt;</span> <span class="o">-</span><span class="mi">90</span><span class="p">:</span>
                <span class="n">v</span> <span class="o">+=</span> <span class="mi">90</span>
            <span class="k">while</span> <span class="n">v</span> <span class="o">&gt;</span> <span class="mi">90</span><span class="p">:</span>
                <span class="n">v</span> <span class="o">-=</span> <span class="mi">90</span>
            <span class="n">val_out</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">v</span><span class="p">)</span>
    <span class="k">else</span><span class="p">:</span>
        <span class="k">while</span> <span class="n">val_in</span> <span class="o">&lt;</span> <span class="o">-</span><span class="mi">90</span><span class="p">:</span>
            <span class="n">val_in</span> <span class="o">+=</span> <span class="mi">90</span>
        <span class="k">while</span> <span class="n">val_in</span> <span class="o">&gt;</span> <span class="mi">90</span><span class="p">:</span>
            <span class="n">val_in</span> <span class="o">-=</span> <span class="mi">90</span>
        <span class="n">val_out</span> <span class="o">=</span> <span class="n">val_in</span>
    <span class="k">return</span> <span class="n">val_out</span></div>


<div class="viewcode-block" id="deg90to90array"><a class="viewcode-back" href="../../api/ssapy.utils.deg90to90array.html#ssapy.utils.deg90to90array">[docs]</a><span class="k">def</span><span class="w"> </span><span class="nf">deg90to90array</span><span class="p">(</span><span class="n">array_</span><span class="p">):</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Normalize an array of angles to the range [0, 90].</span>

<span class="sd">    This function adjusts angles in an iterable such that they fall within the range [0, 90] using the modulo operation.</span>

<span class="sd">    Parameters:</span>
<span class="sd">    -----------</span>
<span class="sd">        array_ (iterable): </span>
<span class="sd">            - An iterable (e.g., list, tuple, or numpy array) of angles.</span>

<span class="sd">    Returns:</span>
<span class="sd">    --------</span>
<span class="sd">        list: </span>
<span class="sd">            - A list of normalized angles in the range [0, 90].</span>

<span class="sd">    Example:</span>
<span class="sd">    --------</span>
<span class="sd">        deg90to90array([95, 180, 270]) -&gt; [5, 0, 0]</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="k">return</span> <span class="p">[</span><span class="n">i</span> <span class="o">%</span> <span class="mi">90</span> <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="n">array_</span><span class="p">]</span></div>


<div class="viewcode-block" id="cart2sph_deg"><a class="viewcode-back" href="../../api/ssapy.utils.cart2sph_deg.html#ssapy.utils.cart2sph_deg">[docs]</a><span class="k">def</span><span class="w"> </span><span class="nf">cart2sph_deg</span><span class="p">(</span><span class="n">x</span><span class="p">,</span> <span class="n">y</span><span class="p">,</span> <span class="n">z</span><span class="p">):</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Convert Cartesian coordinates to spherical coordinates in degrees.</span>

<span class="sd">    This function converts Cartesian coordinates (x, y, z) to spherical coordinates:</span>
<span class="sd">    azimuth (az), elevation (el), and radius (r). The azimuth and elevation angles are returned in degrees.</span>

<span class="sd">    Parameters:</span>
<span class="sd">    -----------</span>
<span class="sd">        x (float or array-like): The x-coordinate(s).</span>
<span class="sd">        y (float or array-like): The y-coordinate(s).</span>
<span class="sd">        z (float or array-like): The z-coordinate(s).</span>

<span class="sd">    Returns:</span>
<span class="sd">    --------</span>
<span class="sd">        tuple: </span>
<span class="sd">            - az (float or array-like): Azimuth angle in degrees (angle in the x-y plane from the positive x-axis).</span>
<span class="sd">            - el (float or array-like): Elevation angle in degrees (angle from the x-y plane to the z-axis).</span>
<span class="sd">            - r (float or array-like): Radius (distance from the origin).</span>

<span class="sd">    Example:</span>
<span class="sd">    --------</span>
<span class="sd">        cart2sph_deg(1, 1, 1) -&gt; (45.0, 35.264389682754654, 1.7320508075688772)</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="n">hxy</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">hypot</span><span class="p">(</span><span class="n">x</span><span class="p">,</span> <span class="n">y</span><span class="p">)</span>
    <span class="n">r</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">hypot</span><span class="p">(</span><span class="n">hxy</span><span class="p">,</span> <span class="n">z</span><span class="p">)</span>
    <span class="n">el</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">arctan2</span><span class="p">(</span><span class="n">z</span><span class="p">,</span> <span class="n">hxy</span><span class="p">)</span> <span class="o">*</span> <span class="p">(</span><span class="mi">180</span> <span class="o">/</span> <span class="n">np</span><span class="o">.</span><span class="n">pi</span><span class="p">)</span>
    <span class="n">az</span> <span class="o">=</span> <span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">arctan2</span><span class="p">(</span><span class="n">y</span><span class="p">,</span> <span class="n">x</span><span class="p">))</span> <span class="o">*</span> <span class="p">(</span><span class="mi">180</span> <span class="o">/</span> <span class="n">np</span><span class="o">.</span><span class="n">pi</span><span class="p">)</span>
    <span class="k">return</span> <span class="n">az</span><span class="p">,</span> <span class="n">el</span><span class="p">,</span> <span class="n">r</span></div>


<div class="viewcode-block" id="cart_to_cyl"><a class="viewcode-back" href="../../api/ssapy.utils.cart_to_cyl.html#ssapy.utils.cart_to_cyl">[docs]</a><span class="k">def</span><span class="w"> </span><span class="nf">cart_to_cyl</span><span class="p">(</span><span class="n">x</span><span class="p">,</span> <span class="n">y</span><span class="p">,</span> <span class="n">z</span><span class="p">):</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Convert Cartesian coordinates to cylindrical coordinates.</span>

<span class="sd">    This function converts Cartesian coordinates (x, y, z) to cylindrical coordinates:</span>
<span class="sd">    radial distance (r), azimuthal angle (theta), and height (z).</span>

<span class="sd">    Parameters:</span>
<span class="sd">    -----------</span>
<span class="sd">        x (float or array-like): The x-coordinate(s).</span>
<span class="sd">        y (float or array-like): The y-coordinate(s).</span>
<span class="sd">        z (float or array-like): The z-coordinate(s).</span>

<span class="sd">    Returns:</span>
<span class="sd">    --------</span>
<span class="sd">        tuple:</span>
<span class="sd">            - r (float or array-like): Radial distance from the origin in the x-y plane.</span>
<span class="sd">            - theta (float or array-like): Azimuthal angle in radians (angle in the x-y plane from the positive x-axis).</span>
<span class="sd">            - z (float or array-like): Height along the z-axis (unchanged from input).</span>

<span class="sd">    Example:</span>
<span class="sd">    --------</span>
<span class="sd">        cart_to_cyl(1, 1, 1) -&gt; (1.4142135623730951, 0.7853981633974483, 1)</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="n">r</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">linalg</span><span class="o">.</span><span class="n">norm</span><span class="p">([</span><span class="n">x</span><span class="p">,</span> <span class="n">y</span><span class="p">])</span>
    <span class="n">theta</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">arctan2</span><span class="p">(</span><span class="n">y</span><span class="p">,</span> <span class="n">x</span><span class="p">)</span>
    <span class="k">return</span> <span class="n">r</span><span class="p">,</span> <span class="n">theta</span><span class="p">,</span> <span class="n">z</span></div>


<div class="viewcode-block" id="inert2rot"><a class="viewcode-back" href="../../api/ssapy.utils.inert2rot.html#ssapy.utils.inert2rot">[docs]</a><span class="k">def</span><span class="w"> </span><span class="nf">inert2rot</span><span class="p">(</span><span class="n">x</span><span class="p">,</span> <span class="n">y</span><span class="p">,</span> <span class="n">xe</span><span class="p">,</span> <span class="n">ye</span><span class="p">,</span> <span class="n">xs</span><span class="o">=</span><span class="mi">0</span><span class="p">,</span> <span class="n">ys</span><span class="o">=</span><span class="mi">0</span><span class="p">):</span>  <span class="c1"># Places Earth at (-1,0)</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Transform inertial coordinates to rotated coordinates relative to the Earth.</span>

<span class="sd">    This function calculates the rotated coordinates of a point (x, y) relative to the Earth,</span>
<span class="sd">    which is assumed to be located at a fixed position (-1, 0) in the rotated frame. The rotation</span>
<span class="sd">    is performed based on the relative position of the Earth (xe, ye) and an optional reference </span>
<span class="sd">    point (xs, ys).</span>

<span class="sd">    Parameters:</span>
<span class="sd">    -----------</span>
<span class="sd">        x (float): The x-coordinate of the point in the inertial frame.</span>
<span class="sd">        y (float): The y-coordinate of the point in the inertial frame.</span>
<span class="sd">        xe (float): The x-coordinate of the Earth in the inertial frame.</span>
<span class="sd">        ye (float): The y-coordinate of the Earth in the inertial frame.</span>
<span class="sd">        xs (float, optional): The x-coordinate of the reference point (default is 0).</span>
<span class="sd">        ys (float, optional): The y-coordinate of the reference point (default is 0).</span>

<span class="sd">    Returns:</span>
<span class="sd">    --------</span>
<span class="sd">        tuple:</span>
<span class="sd">            - xrot (float): The x-coordinate of the point in the rotated frame.</span>
<span class="sd">            - yrot (float): The y-coordinate of the point in the rotated frame.</span>

<span class="sd">    Example:</span>
<span class="sd">    --------</span>
<span class="sd">        inert2rot(2, 3, -1, 0) -&gt; (-3.0, -3.605551275463989)</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="n">earth_theta</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">arctan2</span><span class="p">(</span><span class="n">ye</span> <span class="o">-</span> <span class="n">ys</span><span class="p">,</span> <span class="n">xe</span> <span class="o">-</span> <span class="n">xs</span><span class="p">)</span>
    <span class="n">theta</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">arctan2</span><span class="p">(</span><span class="n">y</span> <span class="o">-</span> <span class="n">ys</span><span class="p">,</span> <span class="n">x</span> <span class="o">-</span> <span class="n">xs</span><span class="p">)</span>
    <span class="n">distance</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">sqrt</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">power</span><span class="p">((</span><span class="n">x</span> <span class="o">-</span> <span class="n">xs</span><span class="p">),</span> <span class="mi">2</span><span class="p">)</span> <span class="o">+</span> <span class="n">np</span><span class="o">.</span><span class="n">power</span><span class="p">((</span><span class="n">y</span> <span class="o">-</span> <span class="n">ys</span><span class="p">),</span> <span class="mi">2</span><span class="p">))</span>
    <span class="n">xrot</span> <span class="o">=</span> <span class="n">distance</span> <span class="o">*</span> <span class="n">np</span><span class="o">.</span><span class="n">cos</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">pi</span> <span class="o">+</span> <span class="p">(</span><span class="n">theta</span> <span class="o">-</span> <span class="n">earth_theta</span><span class="p">))</span>
    <span class="n">yrot</span> <span class="o">=</span> <span class="n">distance</span> <span class="o">*</span> <span class="n">np</span><span class="o">.</span><span class="n">sin</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">pi</span> <span class="o">+</span> <span class="p">(</span><span class="n">theta</span> <span class="o">-</span> <span class="n">earth_theta</span><span class="p">))</span>
    <span class="k">return</span> <span class="n">xrot</span><span class="p">,</span> <span class="n">yrot</span></div>


<div class="viewcode-block" id="sim_lonlatrad"><a class="viewcode-back" href="../../api/ssapy.utils.sim_lonlatrad.html#ssapy.utils.sim_lonlatrad">[docs]</a><span class="k">def</span><span class="w"> </span><span class="nf">sim_lonlatrad</span><span class="p">(</span><span class="n">x</span><span class="p">,</span> <span class="n">y</span><span class="p">,</span> <span class="n">z</span><span class="p">,</span> <span class="n">xe</span><span class="p">,</span> <span class="n">ye</span><span class="p">,</span> <span class="n">ze</span><span class="p">,</span> <span class="n">xs</span><span class="p">,</span> <span class="n">ys</span><span class="p">,</span> <span class="n">zs</span><span class="p">):</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Simulate longitude, latitude, and radius in a geocentric frame with the Sun at (0, 0).</span>

<span class="sd">    This function calculates the longitude, latitude, and radius of a point (x, y, z) relative </span>
<span class="sd">    to the Earth and the Sun. The input coordinates are first shifted to a geocentric frame </span>
<span class="sd">    (Earth at the origin), then converted to spherical coordinates (longitude, latitude, radius). </span>
<span class="sd">    The output is corrected so that the Sun is positioned at (0, 0) in the frame.</span>

<span class="sd">    Parameters:</span>
<span class="sd">    -----------</span>
<span class="sd">        x (float): The x-coordinate of the point in the inertial frame.</span>
<span class="sd">        y (float): The y-coordinate of the point in the inertial frame.</span>
<span class="sd">        z (float): The z-coordinate of the point in the inertial frame.</span>
<span class="sd">        xe (float): The x-coordinate of the Earth in the inertial frame.</span>
<span class="sd">        ye (float): The y-coordinate of the Earth in the inertial frame.</span>
<span class="sd">        ze (float): The z-coordinate of the Earth in the inertial frame.</span>
<span class="sd">        xs (float): The x-coordinate of the Sun in the inertial frame.</span>
<span class="sd">        ys (float): The y-coordinate of the Sun in the inertial frame.</span>
<span class="sd">        zs (float): The z-coordinate of the Sun in the inertial frame.</span>

<span class="sd">    Returns:</span>
<span class="sd">    --------</span>
<span class="sd">        tuple:</span>
<span class="sd">            - longitude (float): The corrected longitude of the point in degrees.</span>
<span class="sd">            - latitude (float): The corrected latitude of the point in degrees.</span>
<span class="sd">            - radius (float): The radial distance of the point from the Earth.</span>

<span class="sd">    Notes:</span>
<span class="sd">    ------</span>
<span class="sd">        - The function assumes the existence of `cart2sph_deg`, which converts Cartesian </span>
<span class="sd">          coordinates to spherical coordinates in degrees.</span>
<span class="sd">        - The function assumes the existence of `deg0to360`, which ensures longitude values </span>
<span class="sd">          are within the range [0, 360] degrees.</span>

<span class="sd">    Example:</span>
<span class="sd">    --------</span>
<span class="sd">        sim_lonlatrad(1, 2, 3, -1, 0, 0, 0, 0, 0) -&gt; (180.0, 45.0, 3.7416573867739413)</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="c1"># convert all to geo coordinates</span>
    <span class="n">x</span> <span class="o">=</span> <span class="n">x</span> <span class="o">-</span> <span class="n">xe</span>
    <span class="n">y</span> <span class="o">=</span> <span class="n">y</span> <span class="o">-</span> <span class="n">ye</span>
    <span class="n">z</span> <span class="o">=</span> <span class="n">z</span> <span class="o">-</span> <span class="n">ze</span>
    <span class="n">xs</span> <span class="o">=</span> <span class="n">xs</span> <span class="o">-</span> <span class="n">xe</span>
    <span class="n">ys</span> <span class="o">=</span> <span class="n">ys</span> <span class="o">-</span> <span class="n">ye</span>
    <span class="n">zs</span> <span class="o">=</span> <span class="n">zs</span> <span class="o">-</span> <span class="n">ze</span>
    <span class="c1"># convert x y z to lon lat radius</span>
    <span class="n">longitude</span><span class="p">,</span> <span class="n">latitude</span><span class="p">,</span> <span class="n">radius</span> <span class="o">=</span> <span class="n">cart2sph_deg</span><span class="p">(</span><span class="n">x</span><span class="p">,</span> <span class="n">y</span><span class="p">,</span> <span class="n">z</span><span class="p">)</span>
    <span class="n">slongitude</span><span class="p">,</span> <span class="n">slatitude</span><span class="p">,</span> <span class="n">sradius</span> <span class="o">=</span> <span class="n">cart2sph_deg</span><span class="p">(</span><span class="n">xs</span><span class="p">,</span> <span class="n">ys</span><span class="p">,</span> <span class="n">zs</span><span class="p">)</span>
    <span class="c1"># correct so that Sun is at (0,0)</span>
    <span class="n">longitude</span> <span class="o">=</span> <span class="n">deg0to360</span><span class="p">(</span><span class="n">slongitude</span> <span class="o">-</span> <span class="n">longitude</span><span class="p">)</span>
    <span class="n">latitude</span> <span class="o">=</span> <span class="n">latitude</span> <span class="o">-</span> <span class="n">slatitude</span>
    <span class="k">return</span> <span class="n">longitude</span><span class="p">,</span> <span class="n">latitude</span><span class="p">,</span> <span class="n">radius</span></div>


<div class="viewcode-block" id="sun_ra_dec"><a class="viewcode-back" href="../../api/ssapy.utils.sun_ra_dec.html#ssapy.utils.sun_ra_dec">[docs]</a><span class="k">def</span><span class="w"> </span><span class="nf">sun_ra_dec</span><span class="p">(</span><span class="n">time_</span><span class="p">):</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Calculate the Right Ascension (RA) and Declination (Dec) of the Sun at a given time.</span>

<span class="sd">    This function computes the Sun&#39;s position in the sky in terms of its Right Ascension (RA) </span>
<span class="sd">    and Declination (Dec) in radians, based on the provided time. It uses the `get_body` </span>
<span class="sd">    function from the `.body` module to retrieve the Sun&#39;s coordinates.</span>

<span class="sd">    Parameters:</span>
<span class="sd">    -----------</span>
<span class="sd">        time_ (float): The time in Modified Julian Date (MJD) format.</span>

<span class="sd">    Returns:</span>
<span class="sd">    --------</span>
<span class="sd">        tuple:</span>
<span class="sd">            - ra (float): The Sun&#39;s Right Ascension in radians.</span>
<span class="sd">            - dec (float): The Sun&#39;s Declination in radians.</span>

<span class="sd">    Notes:</span>
<span class="sd">    ------</span>
<span class="sd">        - The function assumes the existence of a `get_body` function in the `.body` module, </span>
<span class="sd">          which calculates the celestial coordinates of the Sun.</span>
<span class="sd">        - The `Time` class from `astropy.time` is used to handle the MJD time format.</span>

<span class="sd">    Example:</span>
<span class="sd">    --------</span>
<span class="sd">        sun_ra_dec(60000.0) -&gt; (3.141592653589793, -0.40909280422232897)</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="kn">from</span><span class="w"> </span><span class="nn">.body</span><span class="w"> </span><span class="kn">import</span> <span class="n">get_body</span>
    <span class="n">out</span> <span class="o">=</span> <span class="n">get_body</span><span class="p">(</span><span class="n">Time</span><span class="p">(</span><span class="n">time_</span><span class="p">,</span> <span class="nb">format</span><span class="o">=</span><span class="s1">&#39;mjd&#39;</span><span class="p">))</span>
    <span class="k">return</span> <span class="n">out</span><span class="o">.</span><span class="n">ra</span><span class="o">.</span><span class="n">to</span><span class="p">(</span><span class="s1">&#39;rad&#39;</span><span class="p">)</span><span class="o">.</span><span class="n">value</span><span class="p">,</span> <span class="n">out</span><span class="o">.</span><span class="n">dec</span><span class="o">.</span><span class="n">to</span><span class="p">(</span><span class="s1">&#39;rad&#39;</span><span class="p">)</span><span class="o">.</span><span class="n">value</span></div>


<div class="viewcode-block" id="ra_dec"><a class="viewcode-back" href="../../api/ssapy.utils.ra_dec.html#ssapy.utils.ra_dec">[docs]</a><span class="k">def</span><span class="w"> </span><span class="nf">ra_dec</span><span class="p">(</span><span class="n">r</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">v</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">x</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">y</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">z</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">vx</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">vy</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">vz</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">r_earth</span><span class="o">=</span><span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">([</span><span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">]),</span> <span class="n">v_earth</span><span class="o">=</span><span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">([</span><span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">]),</span> <span class="n">input_unit</span><span class="o">=</span><span class="s1">&#39;si&#39;</span><span class="p">):</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Calculate the Right Ascension (RA) and Declination (Dec) of an object relative to Earth&#39;s position.</span>

<span class="sd">    This function computes the RA and Dec of an object based on its position and velocity vectors. </span>
<span class="sd">    The Earth&#39;s position and velocity are subtracted from the input to determine the object&#39;s </span>
<span class="sd">    coordinates relative to Earth. The RA is returned in radians within the range [0, 2π], and </span>
<span class="sd">    the Dec is returned in radians.</span>

<span class="sd">    Parameters:</span>
<span class="sd">    -----------</span>
<span class="sd">        r (ndarray, optional): Position vector of the object in 3D space (shape: Nx3). Default is None.</span>
<span class="sd">        v (ndarray, optional): Velocity vector of the object in 3D space (shape: Nx3). Default is None.</span>
<span class="sd">        x (float, optional): X-coordinate of the object&#39;s position. Default is None.</span>
<span class="sd">        y (float, optional): Y-coordinate of the object&#39;s position. Default is None.</span>
<span class="sd">        z (float, optional): Z-coordinate of the object&#39;s position. Default is None.</span>
<span class="sd">        vx (float, optional): X-component of the object&#39;s velocity. Default is None.</span>
<span class="sd">        vy (float, optional): Y-component of the object&#39;s velocity. Default is None.</span>
<span class="sd">        vz (float, optional): Z-component of the object&#39;s velocity. Default is None.</span>
<span class="sd">        r_earth (ndarray, optional): Earth&#39;s position vector in 3D space (shape: 3). Default is [0, 0, 0].</span>
<span class="sd">        v_earth (ndarray, optional): Earth&#39;s velocity vector in 3D space (shape: 3). Default is [0, 0, 0].</span>
<span class="sd">        input_unit (str, optional): Unit of the input values (&#39;si&#39; for meters and seconds). Default is &#39;si&#39;.</span>

<span class="sd">    Returns:</span>
<span class="sd">    --------</span>
<span class="sd">        tuple:</span>
<span class="sd">            - ra (ndarray): Right Ascension of the object in radians (shape: N).</span>
<span class="sd">            - dec (ndarray): Declination of the object in radians (shape: N).</span>

<span class="sd">    Raises:</span>
<span class="sd">    -------</span>
<span class="sd">        ValueError: If neither `r` and `v` nor individual coordinates (`x`, `y`, `z`, `vx`, `vy`, `vz`) are provided.</span>

<span class="sd">    Notes:</span>
<span class="sd">    ------</span>
<span class="sd">        - If `r` and `v` are not provided, the function expects individual position (`x`, `y`, `z`) </span>
<span class="sd">          and velocity (`vx`, `vy`, `vz`) components to construct the vectors.</span>
<span class="sd">        - The function assumes the existence of `einsum_norm`, which calculates the norm of vectors </span>
<span class="sd">          using Einstein summation notation.</span>
<span class="sd">        - The function assumes the existence of `rad0to2pi`, which ensures RA values are within the range [0, 2π].</span>

<span class="sd">    Example:</span>
<span class="sd">    --------</span>
<span class="sd">        ra_dec(x=1.0, y=2.0, z=3.0, vx=0.1, vy=0.2, vz=0.3) -&gt; (array([1.10714872]), array([0.64052231]))</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="k">if</span> <span class="n">r</span> <span class="ow">is</span> <span class="kc">None</span> <span class="ow">or</span> <span class="n">v</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
        <span class="k">if</span> <span class="n">x</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span> <span class="ow">and</span> <span class="n">y</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span> <span class="ow">and</span> <span class="n">z</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span> <span class="ow">and</span> <span class="n">vx</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span> <span class="ow">and</span> <span class="n">vy</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span> <span class="ow">and</span> <span class="n">vz</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
            <span class="n">r</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">([</span><span class="n">x</span><span class="p">,</span> <span class="n">y</span><span class="p">,</span> <span class="n">z</span><span class="p">])</span>
            <span class="n">v</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">([</span><span class="n">vx</span><span class="p">,</span> <span class="n">vy</span><span class="p">,</span> <span class="n">vz</span><span class="p">])</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s2">&quot;Either provide r and v arrays or individual coordinates (x, y, z) and velocities (vx, vy, vz)&quot;</span><span class="p">)</span>

    <span class="c1"># Subtract Earth&#39;s position and velocity from the input arrays</span>
    <span class="n">r</span> <span class="o">=</span> <span class="n">r</span> <span class="o">-</span> <span class="n">r_earth</span>
    <span class="n">v</span> <span class="o">=</span> <span class="n">v</span> <span class="o">-</span> <span class="n">v_earth</span>

    <span class="n">d_earth_mag</span> <span class="o">=</span> <span class="n">einsum_norm</span><span class="p">(</span><span class="n">r</span><span class="p">,</span> <span class="s1">&#39;ij,ij-&gt;i&#39;</span><span class="p">)</span>
    <span class="n">ra</span> <span class="o">=</span> <span class="n">rad0to2pi</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">arctan2</span><span class="p">(</span><span class="n">r</span><span class="p">[:,</span> <span class="mi">1</span><span class="p">],</span> <span class="n">r</span><span class="p">[:,</span> <span class="mi">0</span><span class="p">]))</span>  <span class="c1"># in radians</span>
    <span class="n">dec</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">arcsin</span><span class="p">(</span><span class="n">r</span><span class="p">[:,</span> <span class="mi">2</span><span class="p">]</span> <span class="o">/</span> <span class="n">d_earth_mag</span><span class="p">)</span>
    <span class="k">return</span> <span class="n">ra</span><span class="p">,</span> <span class="n">dec</span></div>


<div class="viewcode-block" id="lonlat_distance"><a class="viewcode-back" href="../../api/ssapy.utils.lonlat_distance.html#ssapy.utils.lonlat_distance">[docs]</a><span class="k">def</span><span class="w"> </span><span class="nf">lonlat_distance</span><span class="p">(</span><span class="n">lat1</span><span class="p">,</span> <span class="n">lat2</span><span class="p">,</span> <span class="n">lon1</span><span class="p">,</span> <span class="n">lon2</span><span class="p">):</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;Calculate the great-circle distance between two points </span>
<span class="sd">    on Earth&#39;s surface using the Haversine formula.</span>

<span class="sd">    Parameters</span>
<span class="sd">    ----------</span>
<span class="sd">    lat1 : float</span>
<span class="sd">        Latitude of the first point in radians.</span>
<span class="sd">    lat2 : float</span>
<span class="sd">        Latitude of the second point in radians.</span>
<span class="sd">    lon1 : float</span>
<span class="sd">        Longitude of the first point in radians.</span>
<span class="sd">    lon2 : float</span>
<span class="sd">        Longitude of the second point in radians.</span>

<span class="sd">    Returns</span>
<span class="sd">    -------</span>
<span class="sd">    distance : float</span>
<span class="sd">        Distance between the two points in kilometers.</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="n">dlon</span> <span class="o">=</span> <span class="n">lon2</span> <span class="o">-</span> <span class="n">lon1</span>
    <span class="n">dlat</span> <span class="o">=</span> <span class="n">lat2</span> <span class="o">-</span> <span class="n">lat1</span>
    <span class="n">a</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">sin</span><span class="p">(</span><span class="n">dlat</span> <span class="o">/</span> <span class="mi">2</span><span class="p">)</span><span class="o">**</span><span class="mi">2</span> <span class="o">+</span> <span class="n">np</span><span class="o">.</span><span class="n">cos</span><span class="p">(</span><span class="n">lat1</span><span class="p">)</span> <span class="o">*</span> <span class="n">np</span><span class="o">.</span><span class="n">cos</span><span class="p">(</span><span class="n">lat2</span><span class="p">)</span> <span class="o">*</span> <span class="n">np</span><span class="o">.</span><span class="n">sin</span><span class="p">(</span><span class="n">dlon</span> <span class="o">/</span> <span class="mi">2</span><span class="p">)</span><span class="o">**</span><span class="mi">2</span>
    <span class="n">c</span> <span class="o">=</span> <span class="mi">2</span> <span class="o">*</span> <span class="n">np</span><span class="o">.</span><span class="n">arcsin</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">sqrt</span><span class="p">(</span><span class="n">a</span><span class="p">))</span>
    <span class="c1"># Calculate distance in kilometers, use 3956 for miles</span>
    <span class="n">distance</span> <span class="o">=</span> <span class="n">c</span> <span class="o">*</span> <span class="n">EARTH_RADIUS</span>
    <span class="k">return</span> <span class="n">distance</span></div>


<div class="viewcode-block" id="altitude_to_zenithangle"><a class="viewcode-back" href="../../api/ssapy.utils.altitude_to_zenithangle.html#ssapy.utils.altitude_to_zenithangle">[docs]</a><span class="k">def</span><span class="w"> </span><span class="nf">altitude_to_zenithangle</span><span class="p">(</span><span class="n">altitude</span><span class="p">,</span> <span class="n">deg</span><span class="o">=</span><span class="kc">True</span><span class="p">):</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Convert altitude angle to zenith angle.</span>

<span class="sd">    Example:</span>
<span class="sd">    --------</span>
<span class="sd">        altitude_to_zenithangle(45, deg=True) -&gt; 45</span>
<span class="sd">        altitude_to_zenithangle(np.pi / 4, deg=False) -&gt; np.pi / 4</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="k">if</span> <span class="n">deg</span><span class="p">:</span>
        <span class="n">out</span> <span class="o">=</span> <span class="mi">90</span> <span class="o">-</span> <span class="n">altitude</span>
    <span class="k">else</span><span class="p">:</span>
        <span class="n">out</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">pi</span> <span class="o">/</span> <span class="mi">2</span> <span class="o">-</span> <span class="n">altitude</span>
    <span class="k">return</span> <span class="n">out</span></div>


<div class="viewcode-block" id="zenithangle_to_altitude"><a class="viewcode-back" href="../../api/ssapy.utils.zenithangle_to_altitude.html#ssapy.utils.zenithangle_to_altitude">[docs]</a><span class="k">def</span><span class="w"> </span><span class="nf">zenithangle_to_altitude</span><span class="p">(</span><span class="n">zenith_angle</span><span class="p">,</span> <span class="n">deg</span><span class="o">=</span><span class="kc">True</span><span class="p">):</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Convert zenith angle to altitude angle.</span>

<span class="sd">    Parameters:</span>
<span class="sd">    -----------</span>
<span class="sd">        zenith_angle (float or ndarray): Zenith angle of the object (in degrees if `deg=True`, otherwise in radians).</span>
<span class="sd">        deg (bool, optional): If True, input and output are in degrees; if False, in radians. Default is True.</span>

<span class="sd">    Returns:</span>
<span class="sd">    --------</span>
<span class="sd">        float or ndarray: Altitude angle corresponding to the input zenith angle.</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="k">if</span> <span class="n">deg</span><span class="p">:</span>
        <span class="n">out</span> <span class="o">=</span> <span class="mi">90</span> <span class="o">-</span> <span class="n">zenith_angle</span>
    <span class="k">else</span><span class="p">:</span>
        <span class="n">out</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">pi</span> <span class="o">/</span> <span class="mi">2</span> <span class="o">-</span> <span class="n">zenith_angle</span>
    <span class="k">return</span> <span class="n">out</span></div>


<div class="viewcode-block" id="rightascension_to_hourangle"><a class="viewcode-back" href="../../api/ssapy.utils.rightascension_to_hourangle.html#ssapy.utils.rightascension_to_hourangle">[docs]</a><span class="k">def</span><span class="w"> </span><span class="nf">rightascension_to_hourangle</span><span class="p">(</span><span class="n">right_ascension</span><span class="p">,</span> <span class="n">local_time</span><span class="p">):</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Convert right ascension to hour angle.</span>

<span class="sd">    This function calculates the hour angle of a celestial object based on its right ascension </span>
<span class="sd">    and the local time. The hour angle represents the angular distance between the object&#39;s </span>
<span class="sd">    current position and the local meridian.</span>

<span class="sd">    Parameters:</span>
<span class="sd">    -----------</span>
<span class="sd">        right_ascension (float or str): The right ascension of the object. Can be provided as a </span>
<span class="sd">                                        decimal degree value or as a string in &quot;HH:MM:SS&quot; format.</span>
<span class="sd">        local_time (float or str): The local time. Can be provided as a decimal degree value or </span>
<span class="sd">                                   as a string in &quot;HH:MM:SS&quot; format.</span>

<span class="sd">    Returns:</span>
<span class="sd">    --------</span>
<span class="sd">        str: The hour angle in &quot;HH:MM:SS&quot; format.</span>

<span class="sd">    Notes:</span>
<span class="sd">    ------</span>
<span class="sd">        - If `right_ascension` or `local_time` is provided as a decimal degree, it is converted </span>
<span class="sd">          to the appropriate &quot;HH:MM:SS&quot; or &quot;DD:MM:SS&quot; format internally.</span>
<span class="sd">        - Handles cases where the right ascension exceeds the local time by adjusting the local </span>
<span class="sd">          time to account for the 24-hour cycle.</span>

<span class="sd">    Example:</span>
<span class="sd">    --------</span>
<span class="sd">        rightascension_to_hourangle(&quot;10:30:00&quot;, &quot;12:45:00&quot;) -&gt; &quot;02:15:00&quot;</span>
<span class="sd">        rightascension_to_hourangle(157.5, 191.25) -&gt; &quot;02:15:00&quot;</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="k">if</span> <span class="nb">type</span><span class="p">(</span><span class="n">right_ascension</span><span class="p">)</span> <span class="ow">is</span> <span class="ow">not</span> <span class="nb">str</span><span class="p">:</span>
        <span class="n">right_ascension</span> <span class="o">=</span> <span class="n">dd_to_hms</span><span class="p">(</span><span class="n">right_ascension</span><span class="p">)</span>
    <span class="k">if</span> <span class="nb">type</span><span class="p">(</span><span class="n">local_time</span><span class="p">)</span> <span class="ow">is</span> <span class="ow">not</span> <span class="nb">str</span><span class="p">:</span>
        <span class="n">local_time</span> <span class="o">=</span> <span class="n">dd_to_dms</span><span class="p">(</span><span class="n">local_time</span><span class="p">)</span>
    <span class="n">_ra</span> <span class="o">=</span> <span class="nb">float</span><span class="p">(</span><span class="n">right_ascension</span><span class="o">.</span><span class="n">split</span><span class="p">(</span><span class="s1">&#39;:&#39;</span><span class="p">)[</span><span class="mi">0</span><span class="p">])</span>
    <span class="n">_lt</span> <span class="o">=</span> <span class="nb">float</span><span class="p">(</span><span class="n">local_time</span><span class="o">.</span><span class="n">split</span><span class="p">(</span><span class="s1">&#39;:&#39;</span><span class="p">)[</span><span class="mi">0</span><span class="p">])</span>
    <span class="k">if</span> <span class="n">_ra</span> <span class="o">&gt;</span> <span class="n">_lt</span><span class="p">:</span>
        <span class="n">__ltm</span><span class="p">,</span> <span class="n">__lts</span> <span class="o">=</span> <span class="n">local_time</span><span class="o">.</span><span class="n">split</span><span class="p">(</span><span class="s1">&#39;:&#39;</span><span class="p">)[</span><span class="mi">1</span><span class="p">:]</span>
        <span class="n">local_time</span> <span class="o">=</span> <span class="sa">f</span><span class="s1">&#39;</span><span class="si">{</span><span class="mi">24</span><span class="w"> </span><span class="o">+</span><span class="w"> </span><span class="n">_lt</span><span class="si">}</span><span class="s1">:</span><span class="si">{</span><span class="n">__ltm</span><span class="si">}</span><span class="s1">:</span><span class="si">{</span><span class="n">__lts</span><span class="si">}</span><span class="s1">&#39;</span>

    <span class="k">return</span> <span class="n">dd_to_dms</span><span class="p">(</span><span class="n">hms_to_dd</span><span class="p">(</span><span class="n">local_time</span><span class="p">)</span> <span class="o">-</span> <span class="n">hms_to_dd</span><span class="p">(</span><span class="n">right_ascension</span><span class="p">))</span></div>


<div class="viewcode-block" id="equatorial_to_horizontal"><a class="viewcode-back" href="../../api/ssapy.utils.equatorial_to_horizontal.html#ssapy.utils.equatorial_to_horizontal">[docs]</a><span class="k">def</span><span class="w"> </span><span class="nf">equatorial_to_horizontal</span><span class="p">(</span><span class="n">observer_latitude</span><span class="p">,</span> <span class="n">declination</span><span class="p">,</span> <span class="n">right_ascension</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">hour_angle</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">local_time</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">hms</span><span class="o">=</span><span class="kc">False</span><span class="p">):</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Convert equatorial coordinates (declination and either right ascension or hour angle) </span>
<span class="sd">    to horizontal coordinates (azimuth and altitude) for a given observer&#39;s latitude.</span>

<span class="sd">    Parameters:</span>
<span class="sd">    -----------</span>
<span class="sd">    observer_latitude (float): Latitude of the observer in degrees.</span>
<span class="sd">    declination (float): Declination of the celestial object in degrees.</span>
<span class="sd">    right_ascension (float, optional): Right ascension of the celestial object in hours. </span>
<span class="sd">                                       If provided, `local_time` is required to calculate hour angle.</span>
<span class="sd">    hour_angle (float, optional): Hour angle of the celestial object in degrees or hours. </span>
<span class="sd">                                   If provided, it will be used directly for calculations.</span>
<span class="sd">    local_time (float, optional): Local time in hours, used to compute hour angle from right ascension.</span>
<span class="sd">    hms (bool, optional): If True, interprets hour angle or right ascension as hours-minutes-seconds (HMS) </span>
<span class="sd">                          and converts them to decimal degrees.</span>

<span class="sd">    Returns:</span>
<span class="sd">    --------</span>
<span class="sd">    tuple: A tuple containing:</span>
<span class="sd">        - azimuth (float): Azimuth angle in degrees, measured clockwise from north.</span>
<span class="sd">        - altitude (float): Altitude angle in degrees, measured above the horizon.</span>

<span class="sd">    Notes:</span>
<span class="sd">    ------</span>
<span class="sd">    - Either `right_ascension` or `hour_angle` must be provided for the calculation.</span>
<span class="sd">    - If both `right_ascension` and `hour_angle` are provided, `hour_angle` will take precedence.</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="k">if</span> <span class="n">right_ascension</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
        <span class="n">hour_angle</span> <span class="o">=</span> <span class="n">rightascension_to_hourangle</span><span class="p">(</span><span class="n">right_ascension</span><span class="p">,</span> <span class="n">local_time</span><span class="p">)</span>
        <span class="k">if</span> <span class="n">hms</span><span class="p">:</span>
            <span class="n">hour_angle</span> <span class="o">=</span> <span class="n">hms_to_dd</span><span class="p">(</span><span class="n">hour_angle</span><span class="p">)</span>
    <span class="k">elif</span> <span class="n">hour_angle</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
        <span class="k">if</span> <span class="n">hms</span><span class="p">:</span>
            <span class="n">hour_angle</span> <span class="o">=</span> <span class="n">hms_to_dd</span><span class="p">(</span><span class="n">hour_angle</span><span class="p">)</span>
    <span class="k">elif</span> <span class="n">right_ascension</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span> <span class="ow">and</span> <span class="n">hour_angle</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
        <span class="nb">print</span><span class="p">(</span><span class="s1">&#39;Both right_ascension and hour_angle parameters are provided.</span><span class="se">\n</span><span class="s1">Using hour_angle for calculations.&#39;</span><span class="p">)</span>
        <span class="k">if</span> <span class="n">hms</span><span class="p">:</span>
            <span class="n">hour_angle</span> <span class="o">=</span> <span class="n">hms_to_dd</span><span class="p">(</span><span class="n">hour_angle</span><span class="p">)</span>
    <span class="k">else</span><span class="p">:</span>
        <span class="nb">print</span><span class="p">(</span><span class="s1">&#39;Either right_ascension or hour_angle must be provided.&#39;</span><span class="p">)</span>

    <span class="n">observer_latitude</span><span class="p">,</span> <span class="n">hour_angle</span><span class="p">,</span> <span class="n">declination</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">radians</span><span class="p">([</span><span class="n">observer_latitude</span><span class="p">,</span> <span class="n">hour_angle</span><span class="p">,</span> <span class="n">declination</span><span class="p">])</span>

    <span class="n">zenith_angle</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">arccos</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">sin</span><span class="p">(</span><span class="n">observer_latitude</span><span class="p">)</span> <span class="o">*</span> <span class="n">np</span><span class="o">.</span><span class="n">sin</span><span class="p">(</span><span class="n">declination</span><span class="p">)</span> <span class="o">+</span> <span class="n">np</span><span class="o">.</span><span class="n">cos</span><span class="p">(</span><span class="n">observer_latitude</span><span class="p">)</span> <span class="o">*</span> <span class="n">np</span><span class="o">.</span><span class="n">cos</span><span class="p">(</span><span class="n">declination</span><span class="p">)</span> <span class="o">*</span> <span class="n">np</span><span class="o">.</span><span class="n">cos</span><span class="p">(</span><span class="n">hour_angle</span><span class="p">))</span>

    <span class="n">altitude</span> <span class="o">=</span> <span class="n">zenithangle_to_altitude</span><span class="p">(</span><span class="n">zenith_angle</span><span class="p">,</span> <span class="n">deg</span><span class="o">=</span><span class="kc">False</span><span class="p">)</span>

    <span class="n">_num</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">sin</span><span class="p">(</span><span class="n">declination</span><span class="p">)</span> <span class="o">-</span> <span class="n">np</span><span class="o">.</span><span class="n">sin</span><span class="p">(</span><span class="n">observer_latitude</span><span class="p">)</span> <span class="o">*</span> <span class="n">np</span><span class="o">.</span><span class="n">cos</span><span class="p">(</span><span class="n">zenith_angle</span><span class="p">)</span>
    <span class="n">_den</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">cos</span><span class="p">(</span><span class="n">observer_latitude</span><span class="p">)</span> <span class="o">*</span> <span class="n">np</span><span class="o">.</span><span class="n">sin</span><span class="p">(</span><span class="n">zenith_angle</span><span class="p">)</span>
    <span class="n">azimuth</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">arccos</span><span class="p">(</span><span class="n">_num</span> <span class="o">/</span> <span class="n">_den</span><span class="p">)</span>

    <span class="k">if</span> <span class="n">observer_latitude</span> <span class="o">&lt;</span> <span class="mi">0</span><span class="p">:</span>
        <span class="n">azimuth</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">pi</span> <span class="o">-</span> <span class="n">azimuth</span>
    <span class="n">altitude</span><span class="p">,</span> <span class="n">azimuth</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">degrees</span><span class="p">([</span><span class="n">altitude</span><span class="p">,</span> <span class="n">azimuth</span><span class="p">])</span>

    <span class="k">return</span> <span class="n">azimuth</span><span class="p">,</span> <span class="n">altitude</span></div>


<div class="viewcode-block" id="horizontal_to_equatorial"><a class="viewcode-back" href="../../api/ssapy.utils.horizontal_to_equatorial.html#ssapy.utils.horizontal_to_equatorial">[docs]</a><span class="k">def</span><span class="w"> </span><span class="nf">horizontal_to_equatorial</span><span class="p">(</span><span class="n">observer_latitude</span><span class="p">,</span> <span class="n">azimuth</span><span class="p">,</span> <span class="n">altitude</span><span class="p">):</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Convert horizontal coordinates (azimuth and altitude) to equatorial coordinates </span>
<span class="sd">    (hour angle and declination).</span>

<span class="sd">    This function calculates the hour angle and declination of a celestial object </span>
<span class="sd">    based on its horizontal coordinates and the observer&#39;s latitude.</span>

<span class="sd">    Parameters:</span>
<span class="sd">    -----------</span>
<span class="sd">        observer_latitude (float): Latitude of the observer in degrees.</span>
<span class="sd">        azimuth (float): Azimuth angle of the object in degrees (measured clockwise from north).</span>
<span class="sd">        altitude (float): Altitude angle of the object in degrees (above the horizon).</span>

<span class="sd">    Returns:</span>
<span class="sd">    --------</span>
<span class="sd">        tuple: A tuple containing:</span>
<span class="sd">            - hour_angle (float): Hour angle of the object in degrees.</span>
<span class="sd">            - declination (float): Declination of the object in degrees.</span>

<span class="sd">    Notes:</span>
<span class="sd">    ------</span>
<span class="sd">        - The function assumes the input angles are in degrees and internally converts them </span>
<span class="sd">          to radians for calculations.</span>
<span class="sd">        - Adjusts for southern hemisphere observations by flipping zenith angle signs.</span>
<span class="sd">        - The hour angle is calculated using trigonometric relationships, with corrections </span>
<span class="sd">          for specific latitude and declination conditions.</span>

<span class="sd">    Example:</span>
<span class="sd">    --------</span>
<span class="sd">        horizontal_to_equatorial(45.0, 120.0, 30.0) -&gt; (hour_angle, declination)</span>
<span class="sd">    &quot;&quot;&quot;</span>

    <span class="n">altitude</span><span class="p">,</span> <span class="n">azimuth</span><span class="p">,</span> <span class="n">latitude</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">radians</span><span class="p">([</span><span class="n">altitude</span><span class="p">,</span> <span class="n">azimuth</span><span class="p">,</span> <span class="n">observer_latitude</span><span class="p">])</span>
    <span class="n">zenith_angle</span> <span class="o">=</span> <span class="n">zenithangle_to_altitude</span><span class="p">(</span><span class="n">altitude</span><span class="p">)</span>

    <span class="n">zenith_angle</span> <span class="o">=</span> <span class="p">[</span><span class="o">-</span><span class="n">zenith_angle</span> <span class="k">if</span> <span class="n">latitude</span> <span class="o">&lt;</span> <span class="mi">0</span> <span class="k">else</span> <span class="n">zenith_angle</span><span class="p">][</span><span class="mi">0</span><span class="p">]</span>

    <span class="n">declination</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">sin</span><span class="p">(</span><span class="n">latitude</span><span class="p">)</span> <span class="o">*</span> <span class="n">np</span><span class="o">.</span><span class="n">cos</span><span class="p">(</span><span class="n">zenith_angle</span><span class="p">)</span>
    <span class="n">declination</span> <span class="o">=</span> <span class="n">declination</span> <span class="o">+</span> <span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">cos</span><span class="p">(</span><span class="n">latitude</span><span class="p">)</span> <span class="o">*</span> <span class="n">np</span><span class="o">.</span><span class="n">sin</span><span class="p">(</span><span class="n">zenith_angle</span><span class="p">)</span> <span class="o">*</span> <span class="n">np</span><span class="o">.</span><span class="n">cos</span><span class="p">(</span><span class="n">azimuth</span><span class="p">))</span>
    <span class="n">declination</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">arcsin</span><span class="p">(</span><span class="n">declination</span><span class="p">)</span>

    <span class="n">_num</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">cos</span><span class="p">(</span><span class="n">zenith_angle</span><span class="p">)</span> <span class="o">-</span> <span class="n">np</span><span class="o">.</span><span class="n">sin</span><span class="p">(</span><span class="n">latitude</span><span class="p">)</span> <span class="o">*</span> <span class="n">np</span><span class="o">.</span><span class="n">sin</span><span class="p">(</span><span class="n">declination</span><span class="p">)</span>
    <span class="n">_den</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">cos</span><span class="p">(</span><span class="n">latitude</span><span class="p">)</span> <span class="o">*</span> <span class="n">np</span><span class="o">.</span><span class="n">cos</span><span class="p">(</span><span class="n">declination</span><span class="p">)</span>
    <span class="n">hour_angle</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">arccos</span><span class="p">(</span><span class="n">_num</span> <span class="o">/</span> <span class="n">_den</span><span class="p">)</span>

    <span class="k">if</span> <span class="p">(</span><span class="n">latitude</span> <span class="o">&gt;</span> <span class="mi">0</span> <span class="o">&gt;</span> <span class="n">declination</span><span class="p">)</span> <span class="ow">or</span> <span class="p">(</span><span class="n">latitude</span> <span class="o">&lt;</span> <span class="mi">0</span> <span class="o">&lt;</span> <span class="n">declination</span><span class="p">):</span>
        <span class="n">hour_angle</span> <span class="o">=</span> <span class="mi">2</span> <span class="o">*</span> <span class="n">np</span><span class="o">.</span><span class="n">pi</span> <span class="o">-</span> <span class="n">hour_angle</span>

    <span class="n">declination</span><span class="p">,</span> <span class="n">hour_angle</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">degrees</span><span class="p">([</span><span class="n">declination</span><span class="p">,</span> <span class="n">hour_angle</span><span class="p">])</span>

    <span class="k">return</span> <span class="n">hour_angle</span><span class="p">,</span> <span class="n">declination</span></div>


<span class="n">_ecliptic</span> <span class="o">=</span> <span class="mf">0.409092601</span>  <span class="c1"># np.radians(23.43927944)</span>
<span class="n">cos_ec</span> <span class="o">=</span> <span class="mf">0.9174821430960974</span>
<span class="n">sin_ec</span> <span class="o">=</span> <span class="mf">0.3977769690414367</span>


<div class="viewcode-block" id="equatorial_xyz_to_ecliptic_xyz"><a class="viewcode-back" href="../../api/ssapy.utils.equatorial_xyz_to_ecliptic_xyz.html#ssapy.utils.equatorial_xyz_to_ecliptic_xyz">[docs]</a><span class="k">def</span><span class="w"> </span><span class="nf">equatorial_xyz_to_ecliptic_xyz</span><span class="p">(</span><span class="n">xq</span><span class="p">,</span> <span class="n">yq</span><span class="p">,</span> <span class="n">zq</span><span class="p">):</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Convert equatorial rectangular coordinates (X, Y, Z) to ecliptic rectangular coordinates.</span>

<span class="sd">    This function transforms the position of an object from the equatorial coordinate system </span>
<span class="sd">    to the ecliptic coordinate system using the obliquity of the ecliptic.</span>

<span class="sd">    Parameters:</span>
<span class="sd">    -----------</span>
<span class="sd">        xq (float): X-coordinate in the equatorial coordinate system.</span>
<span class="sd">        yq (float): Y-coordinate in the equatorial coordinate system.</span>
<span class="sd">        zq (float): Z-coordinate in the equatorial coordinate system.</span>

<span class="sd">    Returns:</span>
<span class="sd">    --------</span>
<span class="sd">        tuple: A tuple containing:</span>
<span class="sd">            - xc (float): X-coordinate in the ecliptic coordinate system (unchanged from equatorial X).</span>
<span class="sd">            - yc (float): Y-coordinate in the ecliptic coordinate system.</span>
<span class="sd">            - zc (float): Z-coordinate in the ecliptic coordinate system.</span>

<span class="sd">    Notes:</span>
<span class="sd">    ------</span>
<span class="sd">        - The transformation uses the obliquity of the ecliptic (`sin_ec` and `cos_ec`) to rotate </span>
<span class="sd">          the Y and Z components.</span>
<span class="sd">        - The obliquity of the ecliptic (`sin_ec` and `cos_ec`) must be defined globally or imported </span>
<span class="sd">          prior to calling this function.</span>

<span class="sd">    Example:</span>
<span class="sd">    --------</span>
<span class="sd">        equatorial_xyz_to_ecliptic_xyz(1.0, 0.5, 0.3) -&gt; (xc, yc, zc)</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="n">xc</span> <span class="o">=</span> <span class="n">xq</span>
    <span class="n">yc</span> <span class="o">=</span> <span class="n">cos_ec</span> <span class="o">*</span> <span class="n">yq</span> <span class="o">+</span> <span class="n">sin_ec</span> <span class="o">*</span> <span class="n">zq</span>
    <span class="n">zc</span> <span class="o">=</span> <span class="o">-</span><span class="n">sin_ec</span> <span class="o">*</span> <span class="n">yq</span> <span class="o">+</span> <span class="n">cos_ec</span> <span class="o">*</span> <span class="n">zq</span>
    <span class="k">return</span> <span class="n">xc</span><span class="p">,</span> <span class="n">yc</span><span class="p">,</span> <span class="n">zc</span></div>


<div class="viewcode-block" id="ecliptic_xyz_to_equatorial_xyz"><a class="viewcode-back" href="../../api/ssapy.utils.ecliptic_xyz_to_equatorial_xyz.html#ssapy.utils.ecliptic_xyz_to_equatorial_xyz">[docs]</a><span class="k">def</span><span class="w"> </span><span class="nf">ecliptic_xyz_to_equatorial_xyz</span><span class="p">(</span><span class="n">xc</span><span class="p">,</span> <span class="n">yc</span><span class="p">,</span> <span class="n">zc</span><span class="p">):</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Convert ecliptic rectangular coordinates (X, Y, Z) to equatorial rectangular coordinates.</span>

<span class="sd">    This function transforms the position of an object from the ecliptic coordinate system </span>
<span class="sd">    to the equatorial coordinate system using the obliquity of the ecliptic.</span>

<span class="sd">    Parameters:</span>
<span class="sd">    -----------</span>
<span class="sd">        xc (float): X-coordinate in the ecliptic coordinate system.</span>
<span class="sd">        yc (float): Y-coordinate in the ecliptic coordinate system.</span>
<span class="sd">        zc (float): Z-coordinate in the ecliptic coordinate system.</span>

<span class="sd">    Returns:</span>
<span class="sd">    --------</span>
<span class="sd">        tuple: A tuple containing:</span>
<span class="sd">            - xq (float): X-coordinate in the equatorial coordinate system (unchanged from ecliptic X).</span>
<span class="sd">            - yq (float): Y-coordinate in the equatorial coordinate system.</span>
<span class="sd">            - zq (float): Z-coordinate in the equatorial coordinate system.</span>

<span class="sd">    Notes:</span>
<span class="sd">    ------</span>
<span class="sd">        - The transformation uses the obliquity of the ecliptic (`sin_ec` and `cos_ec`) to rotate </span>
<span class="sd">          the Y and Z components.</span>
<span class="sd">        - The obliquity of the ecliptic (`sin_ec` and `cos_ec`) must be defined globally or imported </span>
<span class="sd">          prior to calling this function.</span>

<span class="sd">    Example:</span>
<span class="sd">    --------</span>
<span class="sd">        ecliptic_xyz_to_equatorial_xyz(1.0, 0.5, 0.3) -&gt; (xq, yq, zq)</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="n">xq</span> <span class="o">=</span> <span class="n">xc</span>
    <span class="n">yq</span> <span class="o">=</span> <span class="n">cos_ec</span> <span class="o">*</span> <span class="n">yc</span> <span class="o">-</span> <span class="n">sin_ec</span> <span class="o">*</span> <span class="n">zc</span>
    <span class="n">zq</span> <span class="o">=</span> <span class="n">sin_ec</span> <span class="o">*</span> <span class="n">yc</span> <span class="o">+</span> <span class="n">cos_ec</span> <span class="o">*</span> <span class="n">zc</span>
    <span class="k">return</span> <span class="n">xq</span><span class="p">,</span> <span class="n">yq</span><span class="p">,</span> <span class="n">zq</span></div>


<div class="viewcode-block" id="xyz_to_ecliptic"><a class="viewcode-back" href="../../api/ssapy.utils.xyz_to_ecliptic.html#ssapy.utils.xyz_to_ecliptic">[docs]</a><span class="k">def</span><span class="w"> </span><span class="nf">xyz_to_ecliptic</span><span class="p">(</span><span class="n">xc</span><span class="p">,</span> <span class="n">yc</span><span class="p">,</span> <span class="n">zc</span><span class="p">,</span> <span class="n">xe</span><span class="o">=</span><span class="mi">0</span><span class="p">,</span> <span class="n">ye</span><span class="o">=</span><span class="mi">0</span><span class="p">,</span> <span class="n">ze</span><span class="o">=</span><span class="mi">0</span><span class="p">,</span> <span class="n">degrees</span><span class="o">=</span><span class="kc">False</span><span class="p">):</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Convert rectangular coordinates (X, Y, Z) to ecliptic longitude and latitude.</span>

<span class="sd">    This function computes the ecliptic longitude and latitude of an object relative to the Earth </span>
<span class="sd">    or another reference point, given its rectangular coordinates in the ecliptic coordinate system.</span>

<span class="sd">    Parameters:</span>
<span class="sd">    -----------</span>
<span class="sd">        xc (float): X-coordinate of the object in the ecliptic coordinate system.</span>
<span class="sd">        yc (float): Y-coordinate of the object in the ecliptic coordinate system.</span>
<span class="sd">        zc (float): Z-coordinate of the object in the ecliptic coordinate system.</span>
<span class="sd">        xe (float, optional): X-coordinate of the reference point (default is 0, typically Earth&#39;s position).</span>
<span class="sd">        ye (float, optional): Y-coordinate of the reference point (default is 0, typically Earth&#39;s position).</span>
<span class="sd">        ze (float, optional): Z-coordinate of the reference point (default is 0, typically Earth&#39;s position).</span>
<span class="sd">        degrees (bool, optional): If `True`, returns the longitude and latitude in degrees; </span>
<span class="sd">                                  otherwise, returns them in radians (default is `False`).</span>

<span class="sd">    Returns:</span>
<span class="sd">    --------</span>
<span class="sd">        tuple: A tuple containing:</span>
<span class="sd">            - ec_longitude (float): Ecliptic longitude of the object (in radians or degrees).</span>
<span class="sd">            - ec_latitude (float): Ecliptic latitude of the object (in radians or degrees).</span>

<span class="sd">    Notes:</span>
<span class="sd">    ------</span>
<span class="sd">        - The calculation involves finding the vector from the reference point to the object </span>
<span class="sd">          and determining its magnitude and angular position.</span>
<span class="sd">        - The `rad0to2pi` function ensures the longitude is normalized to the range [0, 2π] in radians.</span>
<span class="sd">        - The `np.arctan2` function is used to compute the longitude, and `np.arcsin` is used for latitude.</span>
<span class="sd">        - If `degrees=True`, the results are converted from radians to degrees using `np.degrees`.</span>

<span class="sd">    Example:</span>
<span class="sd">    --------</span>
<span class="sd">        xyz_to_ecliptic(1.0, 0.5, 0.3, xe=0.1, ye=0.2, ze=0.3, degrees=True) -&gt; (longitude, latitude)</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="n">x_ast_to_earth</span> <span class="o">=</span> <span class="n">xc</span> <span class="o">-</span> <span class="n">xe</span>
    <span class="n">y_ast_to_earth</span> <span class="o">=</span> <span class="n">yc</span> <span class="o">-</span> <span class="n">ye</span>
    <span class="n">z_ast_to_earth</span> <span class="o">=</span> <span class="n">zc</span> <span class="o">-</span> <span class="n">ze</span>
    <span class="n">d_earth_mag</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">sqrt</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">power</span><span class="p">(</span><span class="n">x_ast_to_earth</span><span class="p">,</span> <span class="mi">2</span><span class="p">)</span> <span class="o">+</span> <span class="n">np</span><span class="o">.</span><span class="n">power</span><span class="p">(</span><span class="n">y_ast_to_earth</span><span class="p">,</span> <span class="mi">2</span><span class="p">)</span> <span class="o">+</span> <span class="n">np</span><span class="o">.</span><span class="n">power</span><span class="p">(</span><span class="n">z_ast_to_earth</span><span class="p">,</span> <span class="mi">2</span><span class="p">))</span>
    <span class="n">ec_longitude</span> <span class="o">=</span> <span class="n">rad0to2pi</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">arctan2</span><span class="p">(</span><span class="n">y_ast_to_earth</span><span class="p">,</span> <span class="n">x_ast_to_earth</span><span class="p">))</span>  <span class="c1"># in radians</span>
    <span class="n">ec_latitude</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">arcsin</span><span class="p">(</span><span class="n">z_ast_to_earth</span> <span class="o">/</span> <span class="n">d_earth_mag</span><span class="p">)</span>
    <span class="k">if</span> <span class="n">degrees</span><span class="p">:</span>
        <span class="k">return</span> <span class="n">np</span><span class="o">.</span><span class="n">degrees</span><span class="p">(</span><span class="n">ec_longitude</span><span class="p">),</span> <span class="n">np</span><span class="o">.</span><span class="n">degrees</span><span class="p">(</span><span class="n">ec_latitude</span><span class="p">)</span>
    <span class="k">else</span><span class="p">:</span>
        <span class="k">return</span> <span class="n">ec_longitude</span><span class="p">,</span> <span class="n">ec_latitude</span></div>


<div class="viewcode-block" id="xyz_to_equatorial"><a class="viewcode-back" href="../../api/ssapy.utils.xyz_to_equatorial.html#ssapy.utils.xyz_to_equatorial">[docs]</a><span class="k">def</span><span class="w"> </span><span class="nf">xyz_to_equatorial</span><span class="p">(</span><span class="n">xq</span><span class="p">,</span> <span class="n">yq</span><span class="p">,</span> <span class="n">zq</span><span class="p">,</span> <span class="n">xe</span><span class="o">=</span><span class="mi">0</span><span class="p">,</span> <span class="n">ye</span><span class="o">=</span><span class="mi">0</span><span class="p">,</span> <span class="n">ze</span><span class="o">=</span><span class="mi">0</span><span class="p">,</span> <span class="n">degrees</span><span class="o">=</span><span class="kc">False</span><span class="p">):</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Convert rectangular coordinates (X, Y, Z) to equatorial right ascension (RA) and declination (DEC).</span>

<span class="sd">    This function computes the equatorial coordinates of an object relative to the Earth </span>
<span class="sd">    or another reference point, given its rectangular coordinates in the equatorial coordinate system.</span>

<span class="sd">    Parameters:</span>
<span class="sd">    -----------</span>
<span class="sd">        xq (float): X-coordinate of the object in the equatorial coordinate system.</span>
<span class="sd">        yq (float): Y-coordinate of the object in the equatorial coordinate system.</span>
<span class="sd">        zq (float): Z-coordinate of the object in the equatorial coordinate system.</span>
<span class="sd">        xe (float, optional): X-coordinate of the reference point (default is 0, typically Earth&#39;s position).</span>
<span class="sd">        ye (float, optional): Y-coordinate of the reference point (default is 0, typically Earth&#39;s position).</span>
<span class="sd">        ze (float, optional): Z-coordinate of the reference point (default is 0, typically Earth&#39;s position).</span>
<span class="sd">        degrees (bool, optional): If `True`, returns the RA and DEC in degrees; otherwise, returns them in radians (default is `False`).</span>

<span class="sd">    Returns:</span>
<span class="sd">    --------</span>
<span class="sd">        tuple: A tuple containing:</span>
<span class="sd">            - ra (float): Right ascension of the object (in radians or degrees).</span>
<span class="sd">            - dec (float): Declination of the object (in radians or degrees).</span>

<span class="sd">    Notes:</span>
<span class="sd">    ------</span>
<span class="sd">        - The calculation assumes the XY plane corresponds to the celestial equator, </span>
<span class="sd">          and the -X axis points toward the vernal equinox.</span>
<span class="sd">        - The `rad0to2pi` function ensures the RA is normalized to the range [0, 2π] in radians.</span>
<span class="sd">        - The `np.arctan2` function is used to compute the RA, and `np.arcsin` is used for DEC.</span>
<span class="sd">        - If `degrees=True`, the results are converted from radians to degrees using `np.degrees`.</span>

<span class="sd">    Example:</span>
<span class="sd">    --------</span>
<span class="sd">        xyz_to_equatorial(1.0, 0.5, 0.3, xe=0.1, ye=0.2, ze=0.3, degrees=True) -&gt; (ra, dec)</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="c1"># RA / DEC calculation - assumes XY plane to be celestial equator, and -x axis to be vernal equinox</span>
    <span class="n">x_ast_to_earth</span> <span class="o">=</span> <span class="n">xq</span> <span class="o">-</span> <span class="n">xe</span>
    <span class="n">y_ast_to_earth</span> <span class="o">=</span> <span class="n">yq</span> <span class="o">-</span> <span class="n">ye</span>
    <span class="n">z_ast_to_earth</span> <span class="o">=</span> <span class="n">zq</span> <span class="o">-</span> <span class="n">ze</span>
    <span class="n">d_earth_mag</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">sqrt</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">power</span><span class="p">(</span><span class="n">x_ast_to_earth</span><span class="p">,</span> <span class="mi">2</span><span class="p">)</span> <span class="o">+</span> <span class="n">np</span><span class="o">.</span><span class="n">power</span><span class="p">(</span><span class="n">y_ast_to_earth</span><span class="p">,</span> <span class="mi">2</span><span class="p">)</span> <span class="o">+</span> <span class="n">np</span><span class="o">.</span><span class="n">power</span><span class="p">(</span><span class="n">z_ast_to_earth</span><span class="p">,</span> <span class="mi">2</span><span class="p">))</span>
    <span class="n">ra</span> <span class="o">=</span> <span class="n">rad0to2pi</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">arctan2</span><span class="p">(</span><span class="n">y_ast_to_earth</span><span class="p">,</span> <span class="n">x_ast_to_earth</span><span class="p">))</span>  <span class="c1"># in radians</span>
    <span class="n">dec</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">arcsin</span><span class="p">(</span><span class="n">z_ast_to_earth</span> <span class="o">/</span> <span class="n">d_earth_mag</span><span class="p">)</span>
    <span class="k">if</span> <span class="n">degrees</span><span class="p">:</span>
        <span class="k">return</span> <span class="n">np</span><span class="o">.</span><span class="n">degrees</span><span class="p">(</span><span class="n">ra</span><span class="p">),</span> <span class="n">np</span><span class="o">.</span><span class="n">degrees</span><span class="p">(</span><span class="n">dec</span><span class="p">)</span>
    <span class="k">else</span><span class="p">:</span>
        <span class="k">return</span> <span class="n">ra</span><span class="p">,</span> <span class="n">dec</span></div>


<div class="viewcode-block" id="ecliptic_xyz_to_equatorial"><a class="viewcode-back" href="../../api/ssapy.utils.ecliptic_xyz_to_equatorial.html#ssapy.utils.ecliptic_xyz_to_equatorial">[docs]</a><span class="k">def</span><span class="w"> </span><span class="nf">ecliptic_xyz_to_equatorial</span><span class="p">(</span><span class="n">xc</span><span class="p">,</span> <span class="n">yc</span><span class="p">,</span> <span class="n">zc</span><span class="p">,</span> <span class="n">xe</span><span class="o">=</span><span class="mi">0</span><span class="p">,</span> <span class="n">ye</span><span class="o">=</span><span class="mi">0</span><span class="p">,</span> <span class="n">ze</span><span class="o">=</span><span class="mi">0</span><span class="p">,</span> <span class="n">degrees</span><span class="o">=</span><span class="kc">False</span><span class="p">):</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Convert ecliptic Cartesian coordinates (X, Y, Z) to equatorial right ascension (RA) and declination (DEC).</span>

<span class="sd">    This function first converts ecliptic Cartesian coordinates to equatorial Cartesian coordinates </span>
<span class="sd">    and then computes the equatorial coordinates (RA and DEC) of an object relative to the Earth or another reference point.</span>

<span class="sd">    Parameters:</span>
<span class="sd">    -----------</span>
<span class="sd">        xc (float): X-coordinate of the object in the ecliptic coordinate system.</span>
<span class="sd">        yc (float): Y-coordinate of the object in the ecliptic coordinate system.</span>
<span class="sd">        zc (float): Z-coordinate of the object in the ecliptic coordinate system.</span>
<span class="sd">        xe (float, optional): X-coordinate of the reference point (default is 0, typically Earth&#39;s position).</span>
<span class="sd">        ye (float, optional): Y-coordinate of the reference point (default is 0, typically Earth&#39;s position).</span>
<span class="sd">        ze (float, optional): Z-coordinate of the reference point (default is 0, typically Earth&#39;s position).</span>
<span class="sd">        degrees (bool, optional): If `True`, returns the RA and DEC in degrees; otherwise, returns them in radians (default is `False`).</span>

<span class="sd">    Returns:</span>
<span class="sd">    --------</span>
<span class="sd">        tuple: A tuple containing:</span>
<span class="sd">            - ra (float): Right ascension of the object (in radians or degrees).</span>
<span class="sd">            - dec (float): Declination of the object (in radians or degrees).</span>

<span class="sd">    Notes:</span>
<span class="sd">    ------</span>
<span class="sd">        - The function relies on `ecliptic_xyz_to_equatorial_xyz` to perform the conversion </span>
<span class="sd">          from ecliptic Cartesian coordinates to equatorial Cartesian coordinates.</span>
<span class="sd">        - The calculation assumes the XY plane corresponds to the celestial equator, </span>
<span class="sd">          and the -X axis points toward the vernal equinox.</span>
<span class="sd">        - The `rad0to2pi` function ensures the RA is normalized to the range [0, 2π] in radians.</span>
<span class="sd">        - The `np.arctan2` function is used to compute the RA, and `np.arcsin` is used for DEC.</span>
<span class="sd">        - If `degrees=True`, the results are converted from radians to degrees using `np.degrees`.</span>

<span class="sd">    Example:</span>
<span class="sd">    --------</span>
<span class="sd">        ecliptic_xyz_to_equatorial(1.0, 0.5, 0.3, xe=0.1, ye=0.2, ze=0.3, degrees=True) -&gt; (ra, dec)</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="c1"># Convert ecliptic cartesian into equitorial cartesian</span>
    <span class="n">x_ast_to_earth</span><span class="p">,</span> <span class="n">y_ast_to_earth</span><span class="p">,</span> <span class="n">z_ast_to_earth</span> <span class="o">=</span> <span class="n">ecliptic_xyz_to_equatorial_xyz</span><span class="p">(</span><span class="n">xc</span> <span class="o">-</span> <span class="n">xe</span><span class="p">,</span> <span class="n">yc</span> <span class="o">-</span> <span class="n">ye</span><span class="p">,</span> <span class="n">zc</span> <span class="o">-</span> <span class="n">ze</span><span class="p">)</span>
    <span class="n">d_earth_mag</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">sqrt</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">power</span><span class="p">(</span><span class="n">x_ast_to_earth</span><span class="p">,</span> <span class="mi">2</span><span class="p">)</span> <span class="o">+</span> <span class="n">np</span><span class="o">.</span><span class="n">power</span><span class="p">(</span><span class="n">y_ast_to_earth</span><span class="p">,</span> <span class="mi">2</span><span class="p">)</span> <span class="o">+</span> <span class="n">np</span><span class="o">.</span><span class="n">power</span><span class="p">(</span><span class="n">z_ast_to_earth</span><span class="p">,</span> <span class="mi">2</span><span class="p">))</span>
    <span class="n">ra</span> <span class="o">=</span> <span class="n">rad0to2pi</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">arctan2</span><span class="p">(</span><span class="n">y_ast_to_earth</span><span class="p">,</span> <span class="n">x_ast_to_earth</span><span class="p">))</span>  <span class="c1"># in radians</span>
    <span class="n">dec</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">arcsin</span><span class="p">(</span><span class="n">z_ast_to_earth</span> <span class="o">/</span> <span class="n">d_earth_mag</span><span class="p">)</span>
    <span class="k">if</span> <span class="n">degrees</span><span class="p">:</span>
        <span class="k">return</span> <span class="n">np</span><span class="o">.</span><span class="n">degrees</span><span class="p">(</span><span class="n">ra</span><span class="p">),</span> <span class="n">np</span><span class="o">.</span><span class="n">degrees</span><span class="p">(</span><span class="n">dec</span><span class="p">)</span>
    <span class="k">else</span><span class="p">:</span>
        <span class="k">return</span> <span class="n">ra</span><span class="p">,</span> <span class="n">dec</span></div>


<div class="viewcode-block" id="equatorial_to_ecliptic"><a class="viewcode-back" href="../../api/ssapy.utils.equatorial_to_ecliptic.html#ssapy.utils.equatorial_to_ecliptic">[docs]</a><span class="k">def</span><span class="w"> </span><span class="nf">equatorial_to_ecliptic</span><span class="p">(</span><span class="n">right_ascension</span><span class="p">,</span> <span class="n">declination</span><span class="p">,</span> <span class="n">degrees</span><span class="o">=</span><span class="kc">False</span><span class="p">):</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Convert equatorial coordinates (RA, DEC) to ecliptic longitude and latitude.</span>

<span class="sd">    This function transforms equatorial right ascension (RA) and declination (DEC) into </span>
<span class="sd">    ecliptic longitude and latitude, taking into account the obliquity of the ecliptic.</span>

<span class="sd">    Parameters:</span>
<span class="sd">    -----------</span>
<span class="sd">        right_ascension (float): Right ascension of the object (in degrees or radians).</span>
<span class="sd">        declination (float): Declination of the object (in degrees or radians).</span>
<span class="sd">        degrees (bool, optional): If `True`, assumes input is in degrees and returns output in degrees; </span>
<span class="sd">                                  otherwise, assumes input is in radians and returns output in radians (default is `False`).</span>

<span class="sd">    Returns:</span>
<span class="sd">    --------</span>
<span class="sd">        tuple: A tuple containing:</span>
<span class="sd">            - ec_longitude (float): Ecliptic longitude of the object (in radians or degrees).</span>
<span class="sd">            - ec_latitude (float): Ecliptic latitude of the object (in radians or degrees).</span>

<span class="sd">    Notes:</span>
<span class="sd">    ------</span>
<span class="sd">        - The calculation uses the obliquity of the ecliptic, which is the tilt of Earth&#39;s axis relative to its orbit.</span>
<span class="sd">          The constants `cos_ec` and `sin_ec` represent the cosine and sine of the obliquity angle, respectively.</span>
<span class="sd">        - The `rad0to2pi` function ensures the ecliptic longitude is normalized to the range [0, 2π] in radians.</span>
<span class="sd">        - The `deg0to360` function ensures the ecliptic longitude is normalized to the range [0, 360] in degrees.</span>
<span class="sd">        - If `degrees=True`, the input is converted from degrees to radians using `np.radians`, and the output is converted </span>
<span class="sd">          back to degrees using `np.degrees`.</span>

<span class="sd">    Example:</span>
<span class="sd">    --------</span>
<span class="sd">        equatorial_to_ecliptic(180.0, 45.0, degrees=True) -&gt; (ec_longitude, ec_latitude)</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="n">ra</span><span class="p">,</span> <span class="n">dec</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">radians</span><span class="p">(</span><span class="n">right_ascension</span><span class="p">),</span> <span class="n">np</span><span class="o">.</span><span class="n">radians</span><span class="p">(</span><span class="n">declination</span><span class="p">)</span>
    <span class="n">ec_latitude</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">arcsin</span><span class="p">(</span><span class="n">cos_ec</span> <span class="o">*</span> <span class="n">np</span><span class="o">.</span><span class="n">sin</span><span class="p">(</span><span class="n">dec</span><span class="p">)</span> <span class="o">-</span> <span class="n">sin_ec</span> <span class="o">*</span> <span class="n">np</span><span class="o">.</span><span class="n">cos</span><span class="p">(</span><span class="n">dec</span><span class="p">)</span> <span class="o">*</span> <span class="n">np</span><span class="o">.</span><span class="n">sin</span><span class="p">(</span><span class="n">ra</span><span class="p">))</span>
    <span class="n">ec_longitude</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">arctan</span><span class="p">((</span><span class="n">cos_ec</span> <span class="o">*</span> <span class="n">np</span><span class="o">.</span><span class="n">cos</span><span class="p">(</span><span class="n">dec</span><span class="p">)</span> <span class="o">*</span> <span class="n">np</span><span class="o">.</span><span class="n">sin</span><span class="p">(</span><span class="n">ra</span><span class="p">)</span> <span class="o">+</span> <span class="n">sin_ec</span> <span class="o">*</span> <span class="n">np</span><span class="o">.</span><span class="n">sin</span><span class="p">(</span><span class="n">dec</span><span class="p">))</span> <span class="o">/</span> <span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">cos</span><span class="p">(</span><span class="n">dec</span><span class="p">)</span> <span class="o">*</span> <span class="n">np</span><span class="o">.</span><span class="n">cos</span><span class="p">(</span><span class="n">ra</span><span class="p">)))</span>
    <span class="k">if</span> <span class="n">degrees</span><span class="p">:</span>
        <span class="k">return</span> <span class="n">deg0to360</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">degrees</span><span class="p">(</span><span class="n">ec_longitude</span><span class="p">)),</span> <span class="n">np</span><span class="o">.</span><span class="n">degrees</span><span class="p">(</span><span class="n">ec_latitude</span><span class="p">)</span>
    <span class="k">else</span><span class="p">:</span>
        <span class="k">return</span> <span class="n">rad0to2pi</span><span class="p">(</span><span class="n">ec_longitude</span><span class="p">),</span> <span class="n">ec_latitude</span></div>


<div class="viewcode-block" id="ecliptic_to_equatorial"><a class="viewcode-back" href="../../api/ssapy.utils.ecliptic_to_equatorial.html#ssapy.utils.ecliptic_to_equatorial">[docs]</a><span class="k">def</span><span class="w"> </span><span class="nf">ecliptic_to_equatorial</span><span class="p">(</span><span class="n">lon</span><span class="p">,</span> <span class="n">lat</span><span class="p">,</span> <span class="n">degrees</span><span class="o">=</span><span class="kc">False</span><span class="p">):</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Convert ecliptic coordinates (longitude, latitude) to equatorial right ascension (RA) and declination (DEC).</span>

<span class="sd">    This function transforms ecliptic longitude and latitude into equatorial right ascension (RA) and declination (DEC),</span>
<span class="sd">    taking into account the obliquity of the ecliptic.</span>

<span class="sd">    Parameters:</span>
<span class="sd">    -----------</span>
<span class="sd">        lon (float): Ecliptic longitude of the object (in degrees or radians).</span>
<span class="sd">        lat (float): Ecliptic latitude of the object (in degrees or radians).</span>
<span class="sd">        degrees (bool, optional): If `True`, assumes input is in degrees and returns output in degrees; </span>
<span class="sd">                                  otherwise, assumes input is in radians and returns output in radians (default is `False`).</span>

<span class="sd">    Returns:</span>
<span class="sd">    --------</span>
<span class="sd">        tuple: A tuple containing:</span>
<span class="sd">            - ra (float): Right ascension of the object (in radians or degrees).</span>
<span class="sd">            - dec (float): Declination of the object (in radians or degrees).</span>

<span class="sd">    Notes:</span>
<span class="sd">    ------</span>
<span class="sd">        - The calculation uses the obliquity of the ecliptic, which is the tilt of Earth&#39;s axis relative to its orbit.</span>
<span class="sd">          The constants `cos_ec` and `sin_ec` represent the cosine and sine of the obliquity angle, respectively.</span>
<span class="sd">        - The `np.arctan` function computes the RA, and `np.arcsin` computes the DEC.</span>
<span class="sd">        - If `degrees=True`, the input is converted from degrees to radians using `np.radians`, and the output is converted </span>
<span class="sd">          back to degrees using `np.degrees`.</span>

<span class="sd">    Example:</span>
<span class="sd">    --------</span>
<span class="sd">        ecliptic_to_equatorial(180.0, 45.0, degrees=True) -&gt; (ra, dec)</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="n">lon</span><span class="p">,</span> <span class="n">lat</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">radians</span><span class="p">(</span><span class="n">lon</span><span class="p">),</span> <span class="n">np</span><span class="o">.</span><span class="n">radians</span><span class="p">(</span><span class="n">lat</span><span class="p">)</span>
    <span class="n">ra</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">arctan</span><span class="p">((</span><span class="n">cos_ec</span> <span class="o">*</span> <span class="n">np</span><span class="o">.</span><span class="n">cos</span><span class="p">(</span><span class="n">lat</span><span class="p">)</span> <span class="o">*</span> <span class="n">np</span><span class="o">.</span><span class="n">sin</span><span class="p">(</span><span class="n">lon</span><span class="p">)</span> <span class="o">-</span> <span class="n">sin_ec</span> <span class="o">*</span> <span class="n">np</span><span class="o">.</span><span class="n">sin</span><span class="p">(</span><span class="n">lat</span><span class="p">))</span> <span class="o">/</span> <span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">cos</span><span class="p">(</span><span class="n">lat</span><span class="p">)</span> <span class="o">*</span> <span class="n">np</span><span class="o">.</span><span class="n">cos</span><span class="p">(</span><span class="n">lon</span><span class="p">)))</span>
    <span class="n">dec</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">arcsin</span><span class="p">(</span><span class="n">cos_ec</span> <span class="o">*</span> <span class="n">np</span><span class="o">.</span><span class="n">sin</span><span class="p">(</span><span class="n">lat</span><span class="p">)</span> <span class="o">+</span> <span class="n">sin_ec</span> <span class="o">*</span> <span class="n">np</span><span class="o">.</span><span class="n">cos</span><span class="p">(</span><span class="n">lat</span><span class="p">)</span> <span class="o">*</span> <span class="n">np</span><span class="o">.</span><span class="n">sin</span><span class="p">(</span><span class="n">lon</span><span class="p">))</span>
    <span class="k">if</span> <span class="n">degrees</span><span class="p">:</span>
        <span class="k">return</span> <span class="n">np</span><span class="o">.</span><span class="n">degrees</span><span class="p">(</span><span class="n">ra</span><span class="p">),</span> <span class="n">np</span><span class="o">.</span><span class="n">degrees</span><span class="p">(</span><span class="n">dec</span><span class="p">)</span>
    <span class="k">else</span><span class="p">:</span>
        <span class="k">return</span> <span class="n">ra</span><span class="p">,</span> <span class="n">dec</span></div>


<div class="viewcode-block" id="proper_motion_ra_dec"><a class="viewcode-back" href="../../api/ssapy.utils.proper_motion_ra_dec.html#ssapy.utils.proper_motion_ra_dec">[docs]</a><span class="k">def</span><span class="w"> </span><span class="nf">proper_motion_ra_dec</span><span class="p">(</span><span class="n">r</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">v</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">x</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">y</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">z</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">vx</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">vy</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">vz</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">r_earth</span><span class="o">=</span><span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">([</span><span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">]),</span> <span class="n">v_earth</span><span class="o">=</span><span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">([</span><span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">]),</span> <span class="n">input_unit</span><span class="o">=</span><span class="s1">&#39;si&#39;</span><span class="p">):</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Calculate the proper motion in right ascension (RA) and declination (DEC) for celestial objects.</span>

<span class="sd">    This function computes the proper motion in RA and DEC based on the position and velocity of the object</span>
<span class="sd">    relative to Earth. Proper motion is expressed in arcseconds per second.</span>

<span class="sd">    Parameters:</span>
<span class="sd">    -----------</span>
<span class="sd">        r (numpy array, optional): Position vector of the object [x, y, z] (in meters or AU, depending on `input_unit`).</span>
<span class="sd">        v (numpy array, optional): Velocity vector of the object [vx, vy, vz] (in meters/second or AU/s, depending on `input_unit`).</span>
<span class="sd">        x, y, z (float, optional): Individual position coordinates of the object (used if `r` is not provided).</span>
<span class="sd">        vx, vy, vz (float, optional): Individual velocity components of the object (used if `v` is not provided).</span>
<span class="sd">        r_earth (numpy array, optional): Position vector of Earth [x, y, z] (default is [0, 0, 0]).</span>
<span class="sd">        v_earth (numpy array, optional): Velocity vector of Earth [vx, vy, vz] (default is [0, 0, 0]).</span>
<span class="sd">        input_unit (str, optional): Unit system for input data (&#39;si&#39; for SI units, &#39;rebound&#39; for REBOUND simulation units).</span>
<span class="sd">                                    Default is &#39;si&#39;.</span>

<span class="sd">    Returns:</span>
<span class="sd">    --------</span>
<span class="sd">        tuple: Proper motion in RA and DEC:</span>
<span class="sd">            - pmra (numpy array): Proper motion in RA (arcseconds per second).</span>
<span class="sd">            - pmdec (numpy array): Proper motion in DEC (arcseconds per second).</span>

<span class="sd">    Notes:</span>
<span class="sd">    ------</span>
<span class="sd">        - If `r` and `v` are not provided, the function expects individual coordinates (`x`, `y`, `z`) and velocities (`vx`, `vy`, `vz`).</span>
<span class="sd">        - Earth&#39;s position and velocity are subtracted from the input position and velocity vectors to calculate relative motion.</span>
<span class="sd">        - The `einsum_norm` function calculates the magnitude of the position vector.</span>
<span class="sd">        - Proper motion is scaled by a factor of 206265 to convert radians to arcseconds.</span>
<span class="sd">        - For REBOUND simulation units, proper motion is adjusted to account for time scaling.</span>
<span class="sd">    &quot;&quot;&quot;</span>

    <span class="k">if</span> <span class="n">r</span> <span class="ow">is</span> <span class="kc">None</span> <span class="ow">or</span> <span class="n">v</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
        <span class="k">if</span> <span class="n">x</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span> <span class="ow">and</span> <span class="n">y</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span> <span class="ow">and</span> <span class="n">z</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span> <span class="ow">and</span> <span class="n">vx</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span> <span class="ow">and</span> <span class="n">vy</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span> <span class="ow">and</span> <span class="n">vz</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
            <span class="n">r</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">([</span><span class="n">x</span><span class="p">,</span> <span class="n">y</span><span class="p">,</span> <span class="n">z</span><span class="p">])</span>
            <span class="n">v</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">([</span><span class="n">vx</span><span class="p">,</span> <span class="n">vy</span><span class="p">,</span> <span class="n">vz</span><span class="p">])</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s2">&quot;Either provide r and v arrays or individual coordinates (x, y, z) and velocities (vx, vy, vz)&quot;</span><span class="p">)</span>

    <span class="c1"># Subtract Earth&#39;s position and velocity from the input arrays</span>
    <span class="n">r</span> <span class="o">=</span> <span class="n">r</span> <span class="o">-</span> <span class="n">r_earth</span>
    <span class="n">v</span> <span class="o">=</span> <span class="n">v</span> <span class="o">-</span> <span class="n">v_earth</span>

    <span class="c1"># Distances to Earth and Sun</span>
    <span class="n">d_earth_mag</span> <span class="o">=</span> <span class="n">einsum_norm</span><span class="p">(</span><span class="n">r</span><span class="p">,</span> <span class="s1">&#39;ij,ij-&gt;i&#39;</span><span class="p">)</span>

    <span class="c1"># RA / DEC calculation</span>
    <span class="n">ra</span> <span class="o">=</span> <span class="n">rad0to2pi</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">arctan2</span><span class="p">(</span><span class="n">r</span><span class="p">[:,</span> <span class="mi">1</span><span class="p">],</span> <span class="n">r</span><span class="p">[:,</span> <span class="mi">0</span><span class="p">]))</span>  <span class="c1"># in radians</span>
    <span class="n">dec</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">arcsin</span><span class="p">(</span><span class="n">r</span><span class="p">[:,</span> <span class="mi">2</span><span class="p">]</span> <span class="o">/</span> <span class="n">d_earth_mag</span><span class="p">)</span>
    <span class="n">ra_unit_vector</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">([</span><span class="o">-</span><span class="n">np</span><span class="o">.</span><span class="n">sin</span><span class="p">(</span><span class="n">ra</span><span class="p">),</span> <span class="n">np</span><span class="o">.</span><span class="n">cos</span><span class="p">(</span><span class="n">ra</span><span class="p">),</span> <span class="n">np</span><span class="o">.</span><span class="n">zeros</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">shape</span><span class="p">(</span><span class="n">ra</span><span class="p">))])</span><span class="o">.</span><span class="n">T</span>
    <span class="n">dec_unit_vector</span> <span class="o">=</span> <span class="o">-</span><span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">([</span><span class="n">np</span><span class="o">.</span><span class="n">cos</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">pi</span> <span class="o">/</span> <span class="mi">2</span> <span class="o">-</span> <span class="n">dec</span><span class="p">)</span> <span class="o">*</span> <span class="n">np</span><span class="o">.</span><span class="n">cos</span><span class="p">(</span><span class="n">ra</span><span class="p">),</span> <span class="n">np</span><span class="o">.</span><span class="n">cos</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">pi</span> <span class="o">/</span> <span class="mi">2</span> <span class="o">-</span> <span class="n">dec</span><span class="p">)</span> <span class="o">*</span> <span class="n">np</span><span class="o">.</span><span class="n">sin</span><span class="p">(</span><span class="n">ra</span><span class="p">),</span> <span class="o">-</span><span class="n">np</span><span class="o">.</span><span class="n">sin</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">pi</span> <span class="o">/</span> <span class="mi">2</span> <span class="o">-</span> <span class="n">dec</span><span class="p">)])</span><span class="o">.</span><span class="n">T</span>
    <span class="n">pmra</span> <span class="o">=</span> <span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">einsum</span><span class="p">(</span><span class="s1">&#39;ij,ij-&gt;i&#39;</span><span class="p">,</span> <span class="n">v</span><span class="p">,</span> <span class="n">ra_unit_vector</span><span class="p">))</span> <span class="o">/</span> <span class="n">d_earth_mag</span> <span class="o">*</span> <span class="mi">206265</span>  <span class="c1"># arcseconds / second</span>
    <span class="n">pmdec</span> <span class="o">=</span> <span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">einsum</span><span class="p">(</span><span class="s1">&#39;ij,ij-&gt;i&#39;</span><span class="p">,</span> <span class="n">v</span><span class="p">,</span> <span class="n">dec_unit_vector</span><span class="p">))</span> <span class="o">/</span> <span class="n">d_earth_mag</span> <span class="o">*</span> <span class="mi">206265</span>  <span class="c1"># arcseconds / second</span>

    <span class="k">if</span> <span class="n">input_unit</span> <span class="o">==</span> <span class="s1">&#39;si&#39;</span><span class="p">:</span>
        <span class="k">return</span> <span class="n">pmra</span><span class="p">,</span> <span class="n">pmdec</span>
    <span class="k">elif</span> <span class="n">input_unit</span> <span class="o">==</span> <span class="s1">&#39;rebound&#39;</span><span class="p">:</span>
        <span class="n">pmra</span> <span class="o">=</span> <span class="n">pmra</span> <span class="o">/</span> <span class="p">(</span><span class="mi">31557600</span> <span class="o">*</span> <span class="mi">2</span> <span class="o">*</span> <span class="n">np</span><span class="o">.</span><span class="n">pi</span><span class="p">)</span>
        <span class="n">pmdec</span> <span class="o">=</span> <span class="n">pmdec</span> <span class="o">/</span> <span class="p">(</span><span class="mi">31557600</span> <span class="o">*</span> <span class="mi">2</span> <span class="o">*</span> <span class="n">np</span><span class="o">.</span><span class="n">pi</span><span class="p">)</span>  <span class="c1"># arcseconds * (au/sim_time)/au, convert to arcseconds / second</span>
        <span class="k">return</span> <span class="n">pmra</span><span class="p">,</span> <span class="n">pmdec</span>
    <span class="k">else</span><span class="p">:</span>
        <span class="nb">print</span><span class="p">(</span><span class="s1">&#39;Error - units provided not available, provide either SI or rebound units.&#39;</span><span class="p">)</span>
        <span class="k">return</span></div>



<div class="viewcode-block" id="gcrf_to_lunar"><a class="viewcode-back" href="../../api/ssapy.utils.gcrf_to_lunar.html#ssapy.utils.gcrf_to_lunar">[docs]</a><span class="k">def</span><span class="w"> </span><span class="nf">gcrf_to_lunar</span><span class="p">(</span><span class="n">r</span><span class="p">,</span> <span class="n">t</span><span class="p">,</span> <span class="n">v</span><span class="o">=</span><span class="kc">None</span><span class="p">):</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Transform position and velocity vectors from the GCRF (Geocentric Celestial Reference Frame) to a lunar-centric frame.</span>

<span class="sd">    This function converts coordinates from the Earth-centered GCRF to a coordinate system centered on the Moon. </span>
<span class="sd">    It uses the Moon&#39;s position and velocity to define the transformation.</span>

<span class="sd">    Parameters:</span>
<span class="sd">    -----------</span>
<span class="sd">        r (numpy array): Position vector(s) in the GCRF [x, y, z].</span>
<span class="sd">        t (numpy array): Time(s) at which the position vector(s) are defined.</span>
<span class="sd">        v (numpy array, optional): Velocity vector(s) in the GCRF [vx, vy, vz]. If not provided, only position is transformed.</span>

<span class="sd">    Returns:</span>
<span class="sd">    --------</span>
<span class="sd">        numpy array or tuple:</span>
<span class="sd">            - If `v` is not provided: Transformed position vector(s) in the lunar-centric frame.</span>
<span class="sd">            - If `v` is provided: A tuple containing:</span>
<span class="sd">                - r_lunar (numpy array): Transformed position vector(s) in the lunar-centric frame.</span>
<span class="sd">                - v_lunar (numpy array): Transformed velocity vector(s) in the lunar-centric frame.</span>

<span class="sd">    Notes:</span>
<span class="sd">    ------</span>
<span class="sd">        - The `MoonPosition` class is used to calculate the Moon&#39;s position at a given time.</span>
<span class="sd">        - The Moon&#39;s velocity is approximated using finite differences over a ±5-second interval.</span>
<span class="sd">        - The lunar-centric frame is defined with the following axes:</span>
<span class="sd">            - x-axis: Points from the Moon toward the Earth (direction of the Moon&#39;s position vector).</span>
<span class="sd">            - y-axis: Perpendicular to the Moon&#39;s velocity vector, in the plane of motion.</span>
<span class="sd">            - z-axis: Perpendicular to both the x-axis and y-axis (right-hand rule).</span>
<span class="sd">        - The transformation matrix `R` is constructed using these axes and applied to the input position vector(s).</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="kn">from</span><span class="w"> </span><span class="nn">.body</span><span class="w"> </span><span class="kn">import</span> <span class="n">MoonPosition</span>
    <span class="k">class</span><span class="w"> </span><span class="nc">MoonRotator</span><span class="p">:</span>
        <span class="k">def</span><span class="w"> </span><span class="fm">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">mpm</span> <span class="o">=</span> <span class="n">MoonPosition</span><span class="p">()</span>

        <span class="k">def</span><span class="w"> </span><span class="fm">__call__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">r</span><span class="p">,</span> <span class="n">t</span><span class="p">):</span>
            <span class="n">rmoon</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">mpm</span><span class="p">(</span><span class="n">t</span><span class="p">)</span>
            <span class="n">vmoon</span> <span class="o">=</span> <span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">mpm</span><span class="p">(</span><span class="n">t</span> <span class="o">+</span> <span class="mf">5.0</span><span class="p">)</span> <span class="o">-</span> <span class="bp">self</span><span class="o">.</span><span class="n">mpm</span><span class="p">(</span><span class="n">t</span> <span class="o">-</span> <span class="mf">5.0</span><span class="p">))</span> <span class="o">/</span> <span class="mf">10.</span>
            <span class="n">xhat</span> <span class="o">=</span> <span class="n">normed</span><span class="p">(</span><span class="n">rmoon</span><span class="o">.</span><span class="n">T</span><span class="p">)</span><span class="o">.</span><span class="n">T</span>
            <span class="n">vpar</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">einsum</span><span class="p">(</span><span class="s2">&quot;ab,ab-&gt;b&quot;</span><span class="p">,</span> <span class="n">xhat</span><span class="p">,</span> <span class="n">vmoon</span><span class="p">)</span> <span class="o">*</span> <span class="n">xhat</span>
            <span class="n">vperp</span> <span class="o">=</span> <span class="n">vmoon</span> <span class="o">-</span> <span class="n">vpar</span>
            <span class="n">yhat</span> <span class="o">=</span> <span class="n">normed</span><span class="p">(</span><span class="n">vperp</span><span class="o">.</span><span class="n">T</span><span class="p">)</span><span class="o">.</span><span class="n">T</span>
            <span class="n">zhat</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">cross</span><span class="p">(</span><span class="n">xhat</span><span class="p">,</span> <span class="n">yhat</span><span class="p">,</span> <span class="n">axisa</span><span class="o">=</span><span class="mi">0</span><span class="p">,</span> <span class="n">axisb</span><span class="o">=</span><span class="mi">0</span><span class="p">)</span><span class="o">.</span><span class="n">T</span>
            <span class="n">R</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">empty</span><span class="p">((</span><span class="mi">3</span><span class="p">,</span> <span class="mi">3</span><span class="p">,</span> <span class="nb">len</span><span class="p">(</span><span class="n">t</span><span class="p">)))</span>
            <span class="n">R</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">=</span> <span class="n">xhat</span>
            <span class="n">R</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span> <span class="o">=</span> <span class="n">yhat</span>
            <span class="n">R</span><span class="p">[</span><span class="mi">2</span><span class="p">]</span> <span class="o">=</span> <span class="n">zhat</span>
            <span class="k">return</span> <span class="n">np</span><span class="o">.</span><span class="n">einsum</span><span class="p">(</span><span class="s2">&quot;abc,cb-&gt;ca&quot;</span><span class="p">,</span> <span class="n">R</span><span class="p">,</span> <span class="n">r</span><span class="p">)</span>
    <span class="n">rotator</span> <span class="o">=</span> <span class="n">MoonRotator</span><span class="p">()</span>
    <span class="k">if</span> <span class="n">v</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
        <span class="k">return</span> <span class="n">rotator</span><span class="p">(</span><span class="n">r</span><span class="p">,</span> <span class="n">t</span><span class="p">)</span>
    <span class="k">else</span><span class="p">:</span>
        <span class="n">r_lunar</span> <span class="o">=</span> <span class="n">rotator</span><span class="p">(</span><span class="n">r</span><span class="p">,</span> <span class="n">t</span><span class="p">)</span>
        <span class="n">v_lunar</span> <span class="o">=</span> <span class="n">v_from_r</span><span class="p">(</span><span class="n">r_lunar</span><span class="p">,</span> <span class="n">t</span><span class="p">)</span>
        <span class="k">return</span> <span class="n">r_lunar</span><span class="p">,</span> <span class="n">v_lunar</span></div>


<div class="viewcode-block" id="gcrf_to_lunar_fixed"><a class="viewcode-back" href="../../api/ssapy.utils.gcrf_to_lunar_fixed.html#ssapy.utils.gcrf_to_lunar_fixed">[docs]</a><span class="k">def</span><span class="w"> </span><span class="nf">gcrf_to_lunar_fixed</span><span class="p">(</span><span class="n">r</span><span class="p">,</span> <span class="n">t</span><span class="p">,</span> <span class="n">v</span><span class="o">=</span><span class="kc">None</span><span class="p">):</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Transform position and velocity vectors from the GCRF (Geocentric Celestial Reference Frame) </span>
<span class="sd">    to a Moon-fixed (lunar-centric) frame.</span>

<span class="sd">    This function adjusts the position and velocity vectors to account for the Moon&#39;s motion, </span>
<span class="sd">    effectively transforming them into a frame fixed to the Moon.</span>

<span class="sd">    Parameters:</span>
<span class="sd">    -----------</span>
<span class="sd">        r (numpy array): Position vector(s) in the GCRF [x, y, z].</span>
<span class="sd">        t (numpy array): Time(s) at which the position vector(s) are defined.</span>
<span class="sd">        v (numpy array, optional): Velocity vector(s) in the GCRF [vx, vy, vz]. If not provided, only position is transformed.</span>

<span class="sd">    Returns:</span>
<span class="sd">    --------</span>
<span class="sd">        numpy array or tuple:</span>
<span class="sd">            - If `v` is not provided: Transformed position vector(s) in the Moon-fixed frame.</span>
<span class="sd">            - If `v` is provided: A tuple containing:</span>
<span class="sd">                - r_lunar (numpy array): Transformed position vector(s) in the Moon-fixed frame.</span>
<span class="sd">                - v_lunar (numpy array): Transformed velocity vector(s) in the Moon-fixed frame.</span>

<span class="sd">    Notes:</span>
<span class="sd">    ------</span>
<span class="sd">        - The `get_body` function is used to retrieve the Moon&#39;s position at a given time.</span>
<span class="sd">        - The Moon&#39;s position is subtracted from the transformed lunar-centric position to obtain a Moon-fixed reference frame.</span>
<span class="sd">        - If velocity is provided, it is recalculated in the Moon-fixed frame using the `v_from_r` function.</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="kn">from</span><span class="w"> </span><span class="nn">.body</span><span class="w"> </span><span class="kn">import</span> <span class="n">get_body</span>
    <span class="n">r_lunar</span> <span class="o">=</span> <span class="n">gcrf_to_lunar</span><span class="p">(</span><span class="n">r</span><span class="p">,</span> <span class="n">t</span><span class="p">)</span> <span class="o">-</span> <span class="n">gcrf_to_lunar</span><span class="p">(</span><span class="n">get_body</span><span class="p">(</span><span class="s1">&#39;moon&#39;</span><span class="p">)</span><span class="o">.</span><span class="n">position</span><span class="p">(</span><span class="n">t</span><span class="p">)</span><span class="o">.</span><span class="n">T</span><span class="p">,</span> <span class="n">t</span><span class="p">)</span>
    <span class="k">if</span> <span class="n">v</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
        <span class="k">return</span> <span class="n">r_lunar</span>
    <span class="k">else</span><span class="p">:</span>
        <span class="n">v</span> <span class="o">=</span> <span class="n">v_from_r</span><span class="p">(</span><span class="n">r_lunar</span><span class="p">,</span> <span class="n">t</span><span class="p">)</span>
        <span class="k">return</span> <span class="n">r_lunar</span><span class="p">,</span> <span class="n">v</span></div>


<div class="viewcode-block" id="gcrf_to_radec"><a class="viewcode-back" href="../../api/ssapy.utils.gcrf_to_radec.html#ssapy.utils.gcrf_to_radec">[docs]</a><span class="k">def</span><span class="w"> </span><span class="nf">gcrf_to_radec</span><span class="p">(</span><span class="n">gcrf_coords</span><span class="p">):</span>
    <span class="n">x</span><span class="p">,</span> <span class="n">y</span><span class="p">,</span> <span class="n">z</span> <span class="o">=</span> <span class="n">gcrf_coords</span>
    <span class="c1"># Calculate right ascension in radians</span>
    <span class="n">ra</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">arctan2</span><span class="p">(</span><span class="n">y</span><span class="p">,</span> <span class="n">x</span><span class="p">)</span>
    <span class="c1"># Convert right ascension to degrees</span>
    <span class="n">ra_deg</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">degrees</span><span class="p">(</span><span class="n">ra</span><span class="p">)</span>
    <span class="c1"># Normalize right ascension to the range [0, 360)</span>
    <span class="n">ra_deg</span> <span class="o">=</span> <span class="n">ra_deg</span> <span class="o">%</span> <span class="mi">360</span>
    <span class="c1"># Calculate declination in radians</span>
    <span class="n">dec_rad</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">arctan2</span><span class="p">(</span><span class="n">z</span><span class="p">,</span> <span class="n">np</span><span class="o">.</span><span class="n">sqrt</span><span class="p">(</span><span class="n">x</span><span class="o">**</span><span class="mi">2</span> <span class="o">+</span> <span class="n">y</span><span class="o">**</span><span class="mi">2</span><span class="p">))</span>
    <span class="c1"># Convert declination to degrees</span>
    <span class="n">dec_deg</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">degrees</span><span class="p">(</span><span class="n">dec_rad</span><span class="p">)</span>
    <span class="k">return</span> <span class="p">(</span><span class="n">ra_deg</span><span class="p">,</span> <span class="n">dec_deg</span><span class="p">)</span></div>


<div class="viewcode-block" id="gcrf_to_ecef_bad"><a class="viewcode-back" href="../../api/ssapy.utils.gcrf_to_ecef_bad.html#ssapy.utils.gcrf_to_ecef_bad">[docs]</a><span class="k">def</span><span class="w"> </span><span class="nf">gcrf_to_ecef_bad</span><span class="p">(</span><span class="n">r_gcrf</span><span class="p">,</span> <span class="n">t</span><span class="p">):</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Convert position vectors from the GCRF (Geocentric Celestial Reference Frame) to the ECEF (Earth-Centered, Earth-Fixed) frame.</span>

<span class="sd">    Parameters:</span>
<span class="sd">        r_gcrf (numpy array): Position vector(s) in the GCRF [x, y, z].</span>
<span class="sd">        t (Time or float): Time(s) at which the position vector(s) are defined. If `t` is a `Time` object, GPS seconds are extracted.</span>

<span class="sd">    Returns:</span>
<span class="sd">        numpy array: Position vector(s) in the ECEF frame.</span>

<span class="sd">    Notes:</span>
<span class="sd">        - The Earth&#39;s rotation rate is defined by `WGS84_EARTH_OMEGA`.</span>
<span class="sd">        - The rotation is performed around the Z-axis to account for Earth&#39;s rotation.</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">t</span><span class="p">,</span> <span class="n">Time</span><span class="p">):</span>
        <span class="n">t</span> <span class="o">=</span> <span class="n">t</span><span class="o">.</span><span class="n">gps</span>
    <span class="n">r_gcrf</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">atleast_2d</span><span class="p">(</span><span class="n">r_gcrf</span><span class="p">)</span>
    <span class="n">rotation_angles</span> <span class="o">=</span> <span class="n">WGS84_EARTH_OMEGA</span> <span class="o">*</span> <span class="p">(</span><span class="n">t</span> <span class="o">-</span> <span class="n">Time</span><span class="p">(</span><span class="s2">&quot;1980-3-20T11:06:00&quot;</span><span class="p">,</span> <span class="nb">format</span><span class="o">=</span><span class="s1">&#39;isot&#39;</span><span class="p">)</span><span class="o">.</span><span class="n">gps</span><span class="p">)</span>
    <span class="n">cos_thetas</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">cos</span><span class="p">(</span><span class="n">rotation_angles</span><span class="p">)</span>
    <span class="n">sin_thetas</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">sin</span><span class="p">(</span><span class="n">rotation_angles</span><span class="p">)</span>

    <span class="c1"># Create an array of 3x3 rotation matrices</span>
    <span class="n">Rz</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">([[</span><span class="n">cos_thetas</span><span class="p">,</span> <span class="o">-</span><span class="n">sin_thetas</span><span class="p">,</span> <span class="n">np</span><span class="o">.</span><span class="n">zeros_like</span><span class="p">(</span><span class="n">cos_thetas</span><span class="p">)],</span>
                  <span class="p">[</span><span class="n">sin_thetas</span><span class="p">,</span> <span class="n">cos_thetas</span><span class="p">,</span> <span class="n">np</span><span class="o">.</span><span class="n">zeros_like</span><span class="p">(</span><span class="n">cos_thetas</span><span class="p">)],</span>
                  <span class="p">[</span><span class="n">np</span><span class="o">.</span><span class="n">zeros_like</span><span class="p">(</span><span class="n">cos_thetas</span><span class="p">),</span> <span class="n">np</span><span class="o">.</span><span class="n">zeros_like</span><span class="p">(</span><span class="n">cos_thetas</span><span class="p">),</span> <span class="n">np</span><span class="o">.</span><span class="n">ones_like</span><span class="p">(</span><span class="n">cos_thetas</span><span class="p">)]])</span><span class="o">.</span><span class="n">T</span>

    <span class="c1"># Apply the rotation matrices to all rows of r_gcrf simultaneously</span>
    <span class="n">r_ecef</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">einsum</span><span class="p">(</span><span class="s1">&#39;ijk,ik-&gt;ij&#39;</span><span class="p">,</span> <span class="n">Rz</span><span class="p">,</span> <span class="n">r_gcrf</span><span class="p">)</span>
    <span class="k">return</span> <span class="n">r_ecef</span></div>


<div class="viewcode-block" id="gcrf_to_lat_lon"><a class="viewcode-back" href="../../api/ssapy.utils.gcrf_to_lat_lon.html#ssapy.utils.gcrf_to_lat_lon">[docs]</a><span class="k">def</span><span class="w"> </span><span class="nf">gcrf_to_lat_lon</span><span class="p">(</span><span class="n">r</span><span class="p">,</span> <span class="n">t</span><span class="p">):</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Converts a position vector in the GCRF (Geocentric Celestial Reference Frame) </span>
<span class="sd">    to latitude, longitude, and height coordinates on Earth.</span>

<span class="sd">    Parameters:</span>
<span class="sd">    -----------</span>
<span class="sd">        r (array-like): The position vector in GCRF coordinates (x, y, z) in meters.</span>
<span class="sd">        t (datetime or float): The time associated with the position vector. </span>
<span class="sd">                               This can be a datetime object or a timestamp in seconds.</span>

<span class="sd">    Returns:</span>
<span class="sd">    --------</span>
<span class="sd">        tuple: A tuple containing:</span>
<span class="sd">            - lon (float): Longitude in degrees (East-positive).</span>
<span class="sd">            - lat (float): Latitude in degrees (North-positive).</span>
<span class="sd">            - height (float): Height above the Earth&#39;s surface in meters.</span>

<span class="sd">    Note:</span>
<span class="sd">    -----</span>
<span class="sd">        This function relies on the `groundTrack` function from the `.compute` module </span>
<span class="sd">        to perform the conversion.</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="kn">from</span><span class="w"> </span><span class="nn">.compute</span><span class="w"> </span><span class="kn">import</span> <span class="n">groundTrack</span>
    <span class="n">lon</span><span class="p">,</span> <span class="n">lat</span><span class="p">,</span> <span class="n">height</span> <span class="o">=</span> <span class="n">groundTrack</span><span class="p">(</span><span class="n">r</span><span class="p">,</span> <span class="n">t</span><span class="p">)</span>
    <span class="k">return</span> <span class="n">lon</span><span class="p">,</span> <span class="n">lat</span><span class="p">,</span> <span class="n">height</span></div>


<div class="viewcode-block" id="gcrf_to_itrf"><a class="viewcode-back" href="../../api/ssapy.utils.gcrf_to_itrf.html#ssapy.utils.gcrf_to_itrf">[docs]</a><span class="k">def</span><span class="w"> </span><span class="nf">gcrf_to_itrf</span><span class="p">(</span><span class="n">r_gcrf</span><span class="p">,</span> <span class="n">t</span><span class="p">,</span> <span class="n">v</span><span class="o">=</span><span class="kc">None</span><span class="p">):</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Converts a position vector in the GCRF (Geocentric Celestial Reference Frame) </span>
<span class="sd">    to the ITRF (International Terrestrial Reference Frame) in Cartesian coordinates.</span>

<span class="sd">    Parameters:</span>
<span class="sd">    -----------</span>
<span class="sd">        r_gcrf (array-like): The position vector in GCRF coordinates (x, y, z) in meters.</span>
<span class="sd">        t (datetime or float): The time associated with the position vector. </span>
<span class="sd">                               This can be a datetime object or a timestamp in seconds.</span>
<span class="sd">        v (array-like, optional): Velocity vector in GCRF coordinates. If provided, the function </span>
<span class="sd">                                  will return the velocity transformed to the ITRF frame as well.</span>

<span class="sd">    Returns:</span>
<span class="sd">    --------</span>
<span class="sd">        tuple:</span>
<span class="sd">            - If `v` is not provided:</span>
<span class="sd">                - np.array: A 2D array containing the transformed position vector in ITRF coordinates.</span>
<span class="sd">            - If `v` is provided:</span>
<span class="sd">                - np.array: A 2D array containing the transformed position vector in ITRF coordinates.</span>
<span class="sd">                - np.array: The velocity vector transformed to the ITRF frame.</span>

<span class="sd">    Notes:</span>
<span class="sd">    ------</span>
<span class="sd">        - The function relies on the `groundTrack` function from the `.compute` module to perform the </span>
<span class="sd">          position transformation.</span>
<span class="sd">        - If velocity (`v`) is provided, the function assumes the existence of a `v_from_r` function </span>
<span class="sd">          to compute the velocity transformation.</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="kn">from</span><span class="w"> </span><span class="nn">.compute</span><span class="w"> </span><span class="kn">import</span> <span class="n">groundTrack</span>
    <span class="n">x</span><span class="p">,</span> <span class="n">y</span><span class="p">,</span> <span class="n">z</span> <span class="o">=</span> <span class="n">groundTrack</span><span class="p">(</span><span class="n">r_gcrf</span><span class="p">,</span> <span class="n">t</span><span class="p">,</span> <span class="nb">format</span><span class="o">=</span><span class="s1">&#39;cartesian&#39;</span><span class="p">)</span>
    <span class="n">_</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">([</span><span class="n">x</span><span class="p">,</span> <span class="n">y</span><span class="p">,</span> <span class="n">z</span><span class="p">])</span><span class="o">.</span><span class="n">T</span>
    <span class="k">if</span> <span class="n">v</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
        <span class="k">return</span> <span class="n">_</span>
    <span class="k">else</span><span class="p">:</span>
        <span class="k">return</span> <span class="n">_</span><span class="p">,</span> <span class="n">v_from_r</span><span class="p">(</span><span class="n">_</span><span class="p">,</span> <span class="n">t</span><span class="p">)</span></div>


<div class="viewcode-block" id="gcrf_to_sim_geo"><a class="viewcode-back" href="../../api/ssapy.utils.gcrf_to_sim_geo.html#ssapy.utils.gcrf_to_sim_geo">[docs]</a><span class="k">def</span><span class="w"> </span><span class="nf">gcrf_to_sim_geo</span><span class="p">(</span><span class="n">r_gcrf</span><span class="p">,</span> <span class="n">t</span><span class="p">,</span> <span class="n">h</span><span class="o">=</span><span class="mi">10</span><span class="p">):</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Transforms a position vector in the GCRF (Geocentric Celestial Reference Frame) </span>
<span class="sd">    to a simplified geostationary-like coordinate system.</span>

<span class="sd">    Parameters:</span>
<span class="sd">    -----------</span>
<span class="sd">        r_gcrf (array-like): The position vector(s) in GCRF coordinates (x, y, z) in meters. </span>
<span class="sd">                             Can be a single vector or a 2D array of vectors.</span>
<span class="sd">        t (object): A time object containing GPS time information. Must include a `gps` attribute </span>
<span class="sd">                    (e.g., `t.gps`) that provides time values in seconds.</span>
<span class="sd">        h (float, optional): Step size for numerical propagation in seconds. If the minimum difference </span>
<span class="sd">                             between consecutive GPS time values is smaller than `h`, the step size </span>
<span class="sd">                             will be adjusted accordingly. Default is 10 seconds.</span>

<span class="sd">    Returns:</span>
<span class="sd">    --------</span>
<span class="sd">        np.array: A 2D array of transformed position vectors in the simplified geostationary-like </span>
<span class="sd">                  coordinate system.</span>

<span class="sd">    Notes:</span>
<span class="sd">    ------</span>
<span class="sd">        - The function uses the `Orbit` class to define an orbit from Keplerian elements and propagates </span>
<span class="sd">          it using the `RK78Propagator` with the `AccelKepler` acceleration model.</span>
<span class="sd">        - The transformation involves calculating the rotation required to align the geostationary </span>
<span class="sd">          reference frame with the GCRF position vector.</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="kn">from</span><span class="w"> </span><span class="nn">.accel</span><span class="w"> </span><span class="kn">import</span> <span class="n">AccelKepler</span>
    <span class="kn">from</span><span class="w"> </span><span class="nn">.compute</span><span class="w"> </span><span class="kn">import</span> <span class="n">rv</span>
    <span class="kn">from</span><span class="w"> </span><span class="nn">.orbit</span><span class="w"> </span><span class="kn">import</span> <span class="n">Orbit</span>
    <span class="kn">from</span><span class="w"> </span><span class="nn">.propagator</span><span class="w"> </span><span class="kn">import</span> <span class="n">RK78Propagator</span>
    <span class="k">if</span> <span class="n">np</span><span class="o">.</span><span class="n">min</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">diff</span><span class="p">(</span><span class="n">t</span><span class="o">.</span><span class="n">gps</span><span class="p">))</span> <span class="o">&lt;</span> <span class="n">h</span><span class="p">:</span>
        <span class="n">h</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">min</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">diff</span><span class="p">(</span><span class="n">t</span><span class="o">.</span><span class="n">gps</span><span class="p">))</span>
    <span class="n">r_gcrf</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">atleast_2d</span><span class="p">(</span><span class="n">r_gcrf</span><span class="p">)</span>
    <span class="n">r_geo</span><span class="p">,</span> <span class="n">v_geo</span> <span class="o">=</span> <span class="n">rv</span><span class="p">(</span><span class="n">Orbit</span><span class="o">.</span><span class="n">fromKeplerianElements</span><span class="p">(</span><span class="o">*</span><span class="p">[</span><span class="n">RGEO</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">],</span> <span class="n">t</span><span class="o">=</span><span class="n">t</span><span class="p">[</span><span class="mi">0</span><span class="p">]),</span> <span class="n">t</span><span class="p">,</span> <span class="n">propagator</span><span class="o">=</span><span class="n">RK78Propagator</span><span class="p">(</span><span class="n">AccelKepler</span><span class="p">(),</span> <span class="n">h</span><span class="o">=</span><span class="n">h</span><span class="p">))</span>
    <span class="n">angle_geo_to_x</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">arctan2</span><span class="p">(</span><span class="n">r_geo</span><span class="p">[:,</span> <span class="mi">1</span><span class="p">],</span> <span class="n">r_geo</span><span class="p">[:,</span> <span class="mi">0</span><span class="p">])</span>
    <span class="n">c</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">cos</span><span class="p">(</span><span class="n">angle_geo_to_x</span><span class="p">)</span>
    <span class="n">s</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">sin</span><span class="p">(</span><span class="n">angle_geo_to_x</span><span class="p">)</span>
    <span class="n">rotation</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">([[</span><span class="n">c</span><span class="p">,</span> <span class="o">-</span><span class="n">s</span><span class="p">,</span> <span class="n">np</span><span class="o">.</span><span class="n">zeros_like</span><span class="p">(</span><span class="n">c</span><span class="p">)],</span> <span class="p">[</span><span class="n">s</span><span class="p">,</span> <span class="n">c</span><span class="p">,</span> <span class="n">np</span><span class="o">.</span><span class="n">zeros_like</span><span class="p">(</span><span class="n">c</span><span class="p">)],</span> <span class="p">[</span><span class="n">np</span><span class="o">.</span><span class="n">zeros_like</span><span class="p">(</span><span class="n">c</span><span class="p">),</span> <span class="n">np</span><span class="o">.</span><span class="n">zeros_like</span><span class="p">(</span><span class="n">c</span><span class="p">),</span> <span class="n">np</span><span class="o">.</span><span class="n">ones_like</span><span class="p">(</span><span class="n">c</span><span class="p">)]])</span><span class="o">.</span><span class="n">T</span>
    <span class="k">return</span> <span class="n">np</span><span class="o">.</span><span class="n">einsum</span><span class="p">(</span><span class="s1">&#39;ijk,ik-&gt;ij&#39;</span><span class="p">,</span> <span class="n">rotation</span><span class="p">,</span> <span class="n">r_gcrf</span><span class="p">)</span></div>


<span class="c1"># Function still in development, not 100% accurate.</span>
<div class="viewcode-block" id="gcrf_to_itrf_astropy"><a class="viewcode-back" href="../../api/ssapy.utils.gcrf_to_itrf_astropy.html#ssapy.utils.gcrf_to_itrf_astropy">[docs]</a><span class="k">def</span><span class="w"> </span><span class="nf">gcrf_to_itrf_astropy</span><span class="p">(</span><span class="n">state_vectors</span><span class="p">,</span> <span class="n">t</span><span class="p">):</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Converts position vectors from the GCRF (Geocentric Celestial Reference Frame) to the ITRF </span>
<span class="sd">    (International Terrestrial Reference Frame) using Astropy.</span>

<span class="sd">    This function is still under development and may not produce 100% accurate results.</span>

<span class="sd">    Parameters:</span>
<span class="sd">    -----------</span>
<span class="sd">        state_vectors (np.array): A 2D array of shape (N, 3), where N is the number of position vectors. </span>
<span class="sd">                                  Each row contains the (x, y, z) Cartesian coordinates in meters in the GCRF frame.</span>
<span class="sd">        t (astropy.time.Time): An Astropy `Time` object representing the observation time(s) for the transformation.</span>

<span class="sd">    Returns:</span>
<span class="sd">    --------</span>
<span class="sd">        np.array: A 2D array of shape (N, 3), where N is the number of position vectors. Each row contains </span>
<span class="sd">                  the (x, y, z) Cartesian coordinates in meters in the ITRF frame.</span>

<span class="sd">    Notes:</span>
<span class="sd">    ------</span>
<span class="sd">        - The transformation uses Astropy&#39;s `SkyCoord` and `GCRS`/`ITRS` frames for coordinate conversion.</span>
<span class="sd">        - The barycentric position of Earth is calculated using the `solar_system_ephemeris` context manager </span>
<span class="sd">          with the DE430 ephemeris.</span>
<span class="sd">        - The transformation accounts for Earth&#39;s barycentric position to ensure the coordinates are </span>
<span class="sd">          relative to Earth&#39;s center in the ITRF frame.</span>
<span class="sd">        - The function assumes the input `state_vectors` are in meters and outputs coordinates in meters.</span>


<span class="sd">    &quot;&quot;&quot;</span>
    <span class="kn">import</span><span class="w"> </span><span class="nn">astropy.units</span><span class="w"> </span><span class="k">as</span><span class="w"> </span><span class="nn">u</span>
    <span class="kn">from</span><span class="w"> </span><span class="nn">astropy.coordinates</span><span class="w"> </span><span class="kn">import</span> <span class="n">GCRS</span><span class="p">,</span> <span class="n">ITRS</span><span class="p">,</span> <span class="n">SkyCoord</span><span class="p">,</span> <span class="n">get_body_barycentric</span><span class="p">,</span> <span class="n">solar_system_ephemeris</span><span class="p">,</span> <span class="n">ICRS</span>

    <span class="n">sc</span> <span class="o">=</span> <span class="n">SkyCoord</span><span class="p">(</span><span class="n">x</span><span class="o">=</span><span class="n">state_vectors</span><span class="p">[:,</span> <span class="mi">0</span><span class="p">]</span> <span class="o">*</span> <span class="n">u</span><span class="o">.</span><span class="n">m</span><span class="p">,</span> <span class="n">y</span><span class="o">=</span><span class="n">state_vectors</span><span class="p">[:,</span> <span class="mi">1</span><span class="p">]</span> <span class="o">*</span> <span class="n">u</span><span class="o">.</span><span class="n">m</span><span class="p">,</span> <span class="n">z</span><span class="o">=</span><span class="n">state_vectors</span><span class="p">[:,</span> <span class="mi">2</span><span class="p">]</span> <span class="o">*</span> <span class="n">u</span><span class="o">.</span><span class="n">m</span><span class="p">,</span> <span class="n">representation_type</span><span class="o">=</span><span class="s1">&#39;cartesian&#39;</span><span class="p">,</span> <span class="n">frame</span><span class="o">=</span><span class="n">GCRS</span><span class="p">(</span><span class="n">obstime</span><span class="o">=</span><span class="n">t</span><span class="p">))</span>
    <span class="n">sc_itrs</span> <span class="o">=</span> <span class="n">sc</span><span class="o">.</span><span class="n">transform_to</span><span class="p">(</span><span class="n">ITRS</span><span class="p">(</span><span class="n">obstime</span><span class="o">=</span><span class="n">t</span><span class="p">))</span>
    <span class="k">with</span> <span class="n">solar_system_ephemeris</span><span class="o">.</span><span class="n">set</span><span class="p">(</span><span class="s1">&#39;de430&#39;</span><span class="p">):</span>  <span class="c1"># other options: builtin, de432s</span>
        <span class="n">earth</span> <span class="o">=</span> <span class="n">get_body_barycentric</span><span class="p">(</span><span class="s1">&#39;earth&#39;</span><span class="p">,</span> <span class="n">t</span><span class="p">)</span>
    <span class="n">earth_center_itrs</span> <span class="o">=</span> <span class="n">SkyCoord</span><span class="p">(</span><span class="n">earth</span><span class="o">.</span><span class="n">x</span><span class="p">,</span> <span class="n">earth</span><span class="o">.</span><span class="n">y</span><span class="p">,</span> <span class="n">earth</span><span class="o">.</span><span class="n">z</span><span class="p">,</span> <span class="n">representation_type</span><span class="o">=</span><span class="s1">&#39;cartesian&#39;</span><span class="p">,</span> <span class="n">frame</span><span class="o">=</span><span class="n">ICRS</span><span class="p">())</span><span class="o">.</span><span class="n">transform_to</span><span class="p">(</span><span class="n">ITRS</span><span class="p">(</span><span class="n">obstime</span><span class="o">=</span><span class="n">t</span><span class="p">))</span>
    <span class="n">itrs_coords</span> <span class="o">=</span> <span class="n">SkyCoord</span><span class="p">(</span>
        <span class="n">sc_itrs</span><span class="o">.</span><span class="n">x</span><span class="o">.</span><span class="n">value</span> <span class="o">-</span> <span class="n">earth_center_itrs</span><span class="o">.</span><span class="n">x</span><span class="o">.</span><span class="n">to_value</span><span class="p">(</span><span class="n">u</span><span class="o">.</span><span class="n">m</span><span class="p">),</span>
        <span class="n">sc_itrs</span><span class="o">.</span><span class="n">y</span><span class="o">.</span><span class="n">value</span> <span class="o">-</span> <span class="n">earth_center_itrs</span><span class="o">.</span><span class="n">y</span><span class="o">.</span><span class="n">to_value</span><span class="p">(</span><span class="n">u</span><span class="o">.</span><span class="n">m</span><span class="p">),</span>
        <span class="n">sc_itrs</span><span class="o">.</span><span class="n">z</span><span class="o">.</span><span class="n">value</span> <span class="o">-</span> <span class="n">earth_center_itrs</span><span class="o">.</span><span class="n">z</span><span class="o">.</span><span class="n">to_value</span><span class="p">(</span><span class="n">u</span><span class="o">.</span><span class="n">m</span><span class="p">),</span>
        <span class="n">representation_type</span><span class="o">=</span><span class="s1">&#39;cartesian&#39;</span><span class="p">,</span>
        <span class="n">frame</span><span class="o">=</span><span class="n">ITRS</span><span class="p">(</span><span class="n">obstime</span><span class="o">=</span><span class="n">t</span><span class="p">)</span>
    <span class="p">)</span>
    <span class="c1"># Extract Cartesian coordinates and convert to meters</span>
    <span class="n">itrs_coords_meters</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">([</span><span class="n">itrs_coords</span><span class="o">.</span><span class="n">x</span><span class="p">,</span>
                                  <span class="n">itrs_coords</span><span class="o">.</span><span class="n">y</span><span class="p">,</span>
                                  <span class="n">itrs_coords</span><span class="o">.</span><span class="n">z</span><span class="p">])</span><span class="o">.</span><span class="n">T</span>
    <span class="k">return</span> <span class="n">itrs_coords_meters</span></div>


<div class="viewcode-block" id="v_from_r"><a class="viewcode-back" href="../../api/ssapy.utils.v_from_r.html#ssapy.utils.v_from_r">[docs]</a><span class="k">def</span><span class="w"> </span><span class="nf">v_from_r</span><span class="p">(</span><span class="n">r</span><span class="p">,</span> <span class="n">t</span><span class="p">):</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Calculate the velocity from position and time data.</span>

<span class="sd">    Parameters:</span>
<span class="sd">    -----------</span>
<span class="sd">    r (ndarray): Array of position data with shape (N, D), </span>
<span class="sd">                 where N is the number of time steps and D is the number of dimensions.</span>
<span class="sd">    t (array-like): Array of time data corresponding to the position data. </span>
<span class="sd">                    If the first element is of type `Time`, it will be converted to GPS time.</span>

<span class="sd">    Returns:</span>
<span class="sd">    --------</span>
<span class="sd">    ndarray: Array of velocity data with shape (N, D), calculated as the rate of change of position </span>
<span class="sd">             over time. The last row of the velocity array is repeated to match the input shape.</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">t</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span> <span class="n">Time</span><span class="p">):</span>
        <span class="n">t</span> <span class="o">=</span> <span class="n">t</span><span class="o">.</span><span class="n">gps</span>        
    <span class="n">delta_r</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">diff</span><span class="p">(</span><span class="n">r</span><span class="p">,</span> <span class="n">axis</span><span class="o">=</span><span class="mi">0</span><span class="p">)</span>
    <span class="n">delta_t</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">diff</span><span class="p">(</span><span class="n">t</span><span class="p">)</span>
    <span class="n">v</span> <span class="o">=</span> <span class="n">delta_r</span> <span class="o">/</span> <span class="n">delta_t</span><span class="p">[:,</span> <span class="n">np</span><span class="o">.</span><span class="n">newaxis</span><span class="p">]</span>
    <span class="n">v</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">vstack</span><span class="p">((</span><span class="n">v</span><span class="p">,</span> <span class="n">v</span><span class="p">[</span><span class="o">-</span><span class="mi">1</span><span class="p">]))</span>
    <span class="k">return</span> <span class="n">v</span></div>


<span class="c1"># Stolen from https://github.com/lsst/utils/blob/main/python/lsst/utils/wrappers.py</span>
<span class="n">INTRINSIC_SPECIAL_ATTRIBUTES</span> <span class="o">=</span> <span class="nb">frozenset</span><span class="p">(</span>
    <span class="p">(</span>
        <span class="s2">&quot;__qualname__&quot;</span><span class="p">,</span>
        <span class="s2">&quot;__module__&quot;</span><span class="p">,</span>
        <span class="s2">&quot;__metaclass__&quot;</span><span class="p">,</span>
        <span class="s2">&quot;__dict__&quot;</span><span class="p">,</span>
        <span class="s2">&quot;__weakref__&quot;</span><span class="p">,</span>
        <span class="s2">&quot;__class__&quot;</span><span class="p">,</span>
        <span class="s2">&quot;__subclasshook__&quot;</span><span class="p">,</span>
        <span class="s2">&quot;__name__&quot;</span><span class="p">,</span>
        <span class="s2">&quot;__doc__&quot;</span><span class="p">,</span>
    <span class="p">)</span>
<span class="p">)</span>


<div class="viewcode-block" id="isAttributeSafeToTransfer"><a class="viewcode-back" href="../../api/ssapy.utils.isAttributeSafeToTransfer.html#ssapy.utils.isAttributeSafeToTransfer">[docs]</a><span class="k">def</span><span class="w"> </span><span class="nf">isAttributeSafeToTransfer</span><span class="p">(</span><span class="n">name</span><span class="p">,</span> <span class="n">value</span><span class="p">):</span>
    <span class="c1"># Stolen from https://github.com/lsst/utils/blob/main/python/lsst/utils/wrappers.py</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;Return True if an attribute is safe to monkeypatch-transfer to another</span>
<span class="sd">    class.</span>
<span class="sd">    This rejects special methods that are defined automatically for all</span>
<span class="sd">    classes, leaving only those explicitly defined in a class decorated by</span>
<span class="sd">    `continueClass` or registered with an instance of `TemplateMeta`.</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="k">if</span> <span class="n">name</span><span class="o">.</span><span class="n">startswith</span><span class="p">(</span><span class="s2">&quot;__&quot;</span><span class="p">)</span> <span class="ow">and</span> <span class="p">(</span>
        <span class="n">value</span> <span class="ow">is</span> <span class="nb">getattr</span><span class="p">(</span><span class="nb">object</span><span class="p">,</span> <span class="n">name</span><span class="p">,</span> <span class="kc">None</span><span class="p">)</span> <span class="ow">or</span> <span class="n">name</span> <span class="ow">in</span> <span class="n">INTRINSIC_SPECIAL_ATTRIBUTES</span>
    <span class="p">):</span>
        <span class="k">return</span> <span class="kc">False</span>
    <span class="k">return</span> <span class="kc">True</span></div>


<div class="viewcode-block" id="continueClass"><a class="viewcode-back" href="../../api/ssapy.utils.continueClass.html#ssapy.utils.continueClass">[docs]</a><span class="k">def</span><span class="w"> </span><span class="nf">continueClass</span><span class="p">(</span><span class="bp">cls</span><span class="p">):</span>
    <span class="c1"># Stolen from https://github.com/lsst/utils/blob/main/python/lsst/utils/wrappers.py</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;Re-open the decorated class, adding any new definitions into the</span>
<span class="sd">    original.</span>
<span class="sd">    For example:</span>
<span class="sd">    .. code-block:: python</span>
<span class="sd">        class Foo:</span>
<span class="sd">            pass</span>
<span class="sd">        @continueClass</span>
<span class="sd">        class Foo:</span>
<span class="sd">            def run(self):</span>
<span class="sd">                return None</span>
<span class="sd">    is equivalent to:</span>
<span class="sd">    .. code-block:: python</span>
<span class="sd">        class Foo:</span>
<span class="sd">            def run(self):</span>
<span class="sd">                return None</span>
<span class="sd">    .. warning::</span>
<span class="sd">        Python&#39;s built-in `super` function does not behave properly in classes</span>
<span class="sd">        decorated with `continueClass`.  Base class methods must be invoked</span>
<span class="sd">        directly using their explicit types instead.</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="n">orig</span> <span class="o">=</span> <span class="nb">getattr</span><span class="p">(</span><span class="n">sys</span><span class="o">.</span><span class="n">modules</span><span class="p">[</span><span class="bp">cls</span><span class="o">.</span><span class="vm">__module__</span><span class="p">],</span> <span class="bp">cls</span><span class="o">.</span><span class="vm">__name__</span><span class="p">)</span>
    <span class="k">for</span> <span class="n">name</span> <span class="ow">in</span> <span class="nb">dir</span><span class="p">(</span><span class="bp">cls</span><span class="p">):</span>
        <span class="c1"># Common descriptors like classmethod and staticmethod can only be</span>
        <span class="c1"># accessed without invoking their magic if we use __dict__; if we use</span>
        <span class="c1"># getattr on those we&#39;ll get e.g. a bound method instance on the dummy</span>
        <span class="c1"># class rather than a classmethod instance we can put on the target</span>
        <span class="c1"># class.</span>
        <span class="n">attr</span> <span class="o">=</span> <span class="bp">cls</span><span class="o">.</span><span class="vm">__dict__</span><span class="o">.</span><span class="n">get</span><span class="p">(</span><span class="n">name</span><span class="p">,</span> <span class="kc">None</span><span class="p">)</span> <span class="ow">or</span> <span class="nb">getattr</span><span class="p">(</span><span class="bp">cls</span><span class="p">,</span> <span class="n">name</span><span class="p">)</span>
        <span class="k">if</span> <span class="n">isAttributeSafeToTransfer</span><span class="p">(</span><span class="n">name</span><span class="p">,</span> <span class="n">attr</span><span class="p">):</span>
            <span class="nb">setattr</span><span class="p">(</span><span class="n">orig</span><span class="p">,</span> <span class="n">name</span><span class="p">,</span> <span class="n">attr</span><span class="p">)</span>
    <span class="k">return</span> <span class="n">orig</span></div>


<div class="viewcode-block" id="dms_to_dd"><a class="viewcode-back" href="../../api/ssapy.utils.dms_to_dd.html#ssapy.utils.dms_to_dd">[docs]</a><span class="k">def</span><span class="w"> </span><span class="nf">dms_to_dd</span><span class="p">(</span><span class="n">dms</span><span class="p">):</span>  <span class="c1"># Degree minute second to Degree decimal</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Converts coordinates from Degree-Minute-Second (DMS) format to Decimal Degrees (DD).</span>

<span class="sd">    Parameters:</span>
<span class="sd">    -----------</span>
<span class="sd">        dms (str or list of str): A single DMS string (e.g., &quot;12:34:56&quot;) or a list of DMS strings </span>
<span class="sd">                                  (e.g., [&quot;12:34:56&quot;, &quot;-45:30:15&quot;]). Each string should represent </span>
<span class="sd">                                  degrees, minutes, and seconds separated by colons.</span>

<span class="sd">    Returns:</span>
<span class="sd">    --------</span>
<span class="sd">        float or list of float: </span>
<span class="sd">            - If the input is a single DMS string or a list with one element, returns a single float </span>
<span class="sd">              representing the decimal degree value.</span>
<span class="sd">            - If the input is a list of multiple DMS strings, returns a list of floats representing </span>
<span class="sd">              the decimal degree values.</span>

<span class="sd">    Notes:</span>
<span class="sd">    ------</span>
<span class="sd">        - Negative degrees are handled correctly, ensuring that the minutes and seconds are also </span>
<span class="sd">          treated as negative when converting to decimal degrees.</span>
<span class="sd">        - The function supports both single DMS strings and lists of DMS strings for batch conversion.</span>

<span class="sd">    Example:</span>
<span class="sd">    --------</span>
<span class="sd">        &gt;&gt;&gt; dms_to_dd(&quot;12:34:56&quot;)</span>
<span class="sd">        12.582222222222223</span>

<span class="sd">        &gt;&gt;&gt; dms_to_dd([&quot;12:34:56&quot;, &quot;-45:30:15&quot;])</span>
<span class="sd">        [12.582222222222223, -45.50416666666667]</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="n">dms</span><span class="p">,</span> <span class="n">out</span> <span class="o">=</span> <span class="p">[[</span><span class="n">dms</span><span class="p">]</span> <span class="k">if</span> <span class="nb">type</span><span class="p">(</span><span class="n">dms</span><span class="p">)</span> <span class="ow">is</span> <span class="nb">str</span> <span class="k">else</span> <span class="n">dms</span><span class="p">][</span><span class="mi">0</span><span class="p">],</span> <span class="p">[]</span>
    <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="n">dms</span><span class="p">:</span>
        <span class="n">deg</span><span class="p">,</span> <span class="n">minute</span><span class="p">,</span> <span class="n">sec</span> <span class="o">=</span> <span class="p">[</span><span class="nb">float</span><span class="p">(</span><span class="n">j</span><span class="p">)</span> <span class="k">for</span> <span class="n">j</span> <span class="ow">in</span> <span class="n">i</span><span class="o">.</span><span class="n">split</span><span class="p">(</span><span class="s1">&#39;:&#39;</span><span class="p">)]</span>
        <span class="k">if</span> <span class="n">deg</span> <span class="o">&lt;</span> <span class="mi">0</span><span class="p">:</span>
            <span class="n">minute</span><span class="p">,</span> <span class="n">sec</span> <span class="o">=</span> <span class="nb">float</span><span class="p">(</span><span class="sa">f</span><span class="s1">&#39;-</span><span class="si">{</span><span class="n">minute</span><span class="si">}</span><span class="s1">&#39;</span><span class="p">),</span> <span class="nb">float</span><span class="p">(</span><span class="sa">f</span><span class="s1">&#39;-</span><span class="si">{</span><span class="n">sec</span><span class="si">}</span><span class="s1">&#39;</span><span class="p">)</span>
        <span class="n">out</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">deg</span> <span class="o">+</span> <span class="n">minute</span> <span class="o">/</span> <span class="mi">60</span> <span class="o">+</span> <span class="n">sec</span> <span class="o">/</span> <span class="mi">3600</span><span class="p">)</span>
    <span class="k">return</span> <span class="p">[</span><span class="n">out</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="k">if</span> <span class="nb">type</span><span class="p">(</span><span class="n">dms</span><span class="p">)</span> <span class="ow">is</span> <span class="nb">str</span> <span class="ow">or</span> <span class="nb">len</span><span class="p">(</span><span class="n">dms</span><span class="p">)</span> <span class="o">==</span> <span class="mi">1</span> <span class="k">else</span> <span class="n">out</span><span class="p">][</span><span class="mi">0</span><span class="p">]</span></div>


<div class="viewcode-block" id="dd_to_dms"><a class="viewcode-back" href="../../api/ssapy.utils.dd_to_dms.html#ssapy.utils.dd_to_dms">[docs]</a><span class="k">def</span><span class="w"> </span><span class="nf">dd_to_dms</span><span class="p">(</span><span class="n">degree_decimal</span><span class="p">):</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Converts a Decimal Degree (DD) value to Degree-Minute-Second (DMS) format.</span>

<span class="sd">    Parameters:</span>
<span class="sd">    -----------</span>
<span class="sd">        degree_decimal (float): A single decimal degree value to be converted to DMS format. </span>
<span class="sd">                                Positive values represent north/east, and negative values represent </span>
<span class="sd">                                south/west.</span>

<span class="sd">    Returns:</span>
<span class="sd">    --------</span>
<span class="sd">        str: A string representing the DMS format (e.g., &quot;12:34:56&quot;). The format includes:</span>
<span class="sd">            - Degrees as an integer.</span>
<span class="sd">            - Minutes as an integer.</span>
<span class="sd">            - Seconds as a float (rounded to 4 decimal places if necessary).</span>

<span class="sd">    Notes:</span>
<span class="sd">    ------</span>
<span class="sd">        - Handles negative decimal degree values correctly, ensuring the DMS format reflects the </span>
<span class="sd">          correct sign for degrees, minutes, and seconds.</span>
<span class="sd">        - Ensures seconds are properly rounded and handles edge cases where seconds reach 60, </span>
<span class="sd">          incrementing minutes accordingly.</span>
<span class="sd">        - Returns seconds as an integer if the value is a whole number.</span>

<span class="sd">    Example:</span>
<span class="sd">    --------</span>
<span class="sd">        &gt;&gt;&gt; dd_to_dms(12.582222222222223)</span>
<span class="sd">        &#39;12:34:56&#39;</span>

<span class="sd">        &gt;&gt;&gt; dd_to_dms(-45.50416666666667)</span>
<span class="sd">        &#39;-45:30:15&#39;</span>

<span class="sd">        &gt;&gt;&gt; dd_to_dms(0.0002777777777777778)</span>
<span class="sd">        &#39;0:0:1&#39;</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="n">_d</span><span class="p">,</span> <span class="n">__d</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">trunc</span><span class="p">(</span><span class="n">degree_decimal</span><span class="p">),</span> <span class="n">degree_decimal</span> <span class="o">-</span> <span class="n">np</span><span class="o">.</span><span class="n">trunc</span><span class="p">(</span><span class="n">degree_decimal</span><span class="p">)</span>
    <span class="n">__d</span> <span class="o">=</span> <span class="p">[</span><span class="o">-</span><span class="n">__d</span> <span class="k">if</span> <span class="n">degree_decimal</span> <span class="o">&lt;</span> <span class="mi">0</span> <span class="k">else</span> <span class="n">__d</span><span class="p">][</span><span class="mi">0</span><span class="p">]</span>
    <span class="n">_m</span><span class="p">,</span> <span class="n">__m</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">trunc</span><span class="p">(</span><span class="n">__d</span> <span class="o">*</span> <span class="mi">60</span><span class="p">),</span> <span class="n">__d</span> <span class="o">*</span> <span class="mi">60</span> <span class="o">-</span> <span class="n">np</span><span class="o">.</span><span class="n">trunc</span><span class="p">(</span><span class="n">__d</span> <span class="o">*</span> <span class="mi">60</span><span class="p">)</span>
    <span class="n">_s</span> <span class="o">=</span> <span class="nb">round</span><span class="p">(</span><span class="n">__m</span> <span class="o">*</span> <span class="mi">60</span><span class="p">,</span> <span class="mi">4</span><span class="p">)</span>
    <span class="n">_s</span> <span class="o">=</span> <span class="p">[</span><span class="nb">int</span><span class="p">(</span><span class="n">_s</span><span class="p">)</span> <span class="k">if</span> <span class="nb">int</span><span class="p">(</span><span class="n">_s</span><span class="p">)</span> <span class="o">==</span> <span class="n">_s</span> <span class="k">else</span> <span class="n">_s</span><span class="p">][</span><span class="mi">0</span><span class="p">]</span>
    <span class="k">if</span> <span class="n">_s</span> <span class="o">==</span> <span class="mi">60</span><span class="p">:</span>
        <span class="n">_m</span><span class="p">,</span> <span class="n">_s</span> <span class="o">=</span> <span class="n">_m</span> <span class="o">+</span> <span class="mi">1</span><span class="p">,</span> <span class="s1">&#39;00&#39;</span>
    <span class="k">elif</span> <span class="n">_s</span> <span class="o">&gt;</span> <span class="mi">60</span><span class="p">:</span>
        <span class="n">_m</span><span class="p">,</span> <span class="n">_s</span> <span class="o">=</span> <span class="n">_m</span> <span class="o">+</span> <span class="mi">1</span><span class="p">,</span> <span class="n">_s</span> <span class="o">-</span> <span class="mi">60</span>

    <span class="k">return</span> <span class="sa">f</span><span class="s1">&#39;</span><span class="si">{</span><span class="nb">int</span><span class="p">(</span><span class="n">_d</span><span class="p">)</span><span class="si">}</span><span class="s1">:</span><span class="si">{</span><span class="nb">int</span><span class="p">(</span><span class="n">_m</span><span class="p">)</span><span class="si">}</span><span class="s1">:</span><span class="si">{</span><span class="n">_s</span><span class="si">}</span><span class="s1">&#39;</span></div>


<div class="viewcode-block" id="hms_to_dd"><a class="viewcode-back" href="../../api/ssapy.utils.hms_to_dd.html#ssapy.utils.hms_to_dd">[docs]</a><span class="k">def</span><span class="w"> </span><span class="nf">hms_to_dd</span><span class="p">(</span><span class="n">hms</span><span class="p">):</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Converts Hour-Minute-Second (HMS) format to Decimal Degrees (DD).</span>

<span class="sd">    Parameters:</span>
<span class="sd">    -----------</span>
<span class="sd">        hms (str or list of str): A single HMS string (e.g., &quot;12:34:56&quot;) or a list of HMS strings </span>
<span class="sd">                                  (e.g., [&quot;12:34:56&quot;, &quot;15:45:30&quot;]). Each string should represent </span>
<span class="sd">                                  hours, minutes, and seconds separated by colons.</span>

<span class="sd">    Returns:</span>
<span class="sd">    --------</span>
<span class="sd">        float or list of float:</span>
<span class="sd">            - If the input is a single HMS string or a list with one element, returns a single float </span>
<span class="sd">              representing the decimal degree value.</span>
<span class="sd">            - If the input is a list of multiple HMS strings, returns a list of floats representing </span>
<span class="sd">              the decimal degree values.</span>

<span class="sd">    Notes:</span>
<span class="sd">    ------</span>
<span class="sd">        - HMS values are converted to decimal degrees using the formula:</span>
<span class="sd">          Decimal Degrees = (Hours * 15) + (Minutes / 4) + (Seconds / 240).</span>
<span class="sd">        - Negative HMS values are not allowed, and the function will print an error message if </span>
<span class="sd">          encountered.</span>
<span class="sd">        - The function supports both single HMS strings and lists of HMS strings for batch conversion.</span>

<span class="sd">    Example:</span>
<span class="sd">    --------</span>
<span class="sd">        &gt;&gt;&gt; hms_to_dd(&quot;12:34:56&quot;)</span>
<span class="sd">        188.73333333333332</span>

<span class="sd">        &gt;&gt;&gt; hms_to_dd([&quot;12:34:56&quot;, &quot;15:45:30&quot;])</span>
<span class="sd">        [188.73333333333332, 236.375]</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="n">_type</span> <span class="o">=</span> <span class="nb">type</span><span class="p">(</span><span class="n">hms</span><span class="p">)</span>
    <span class="n">hms</span><span class="p">,</span> <span class="n">out</span> <span class="o">=</span> <span class="p">[[</span><span class="n">hms</span><span class="p">]</span> <span class="k">if</span> <span class="n">_type</span> <span class="o">==</span> <span class="nb">str</span> <span class="k">else</span> <span class="n">hms</span><span class="p">][</span><span class="mi">0</span><span class="p">],</span> <span class="p">[]</span>
    <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="n">hms</span><span class="p">:</span>
        <span class="k">if</span> <span class="n">i</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">!=</span> <span class="s1">&#39;-&#39;</span><span class="p">:</span>
            <span class="n">hour</span><span class="p">,</span> <span class="n">minute</span><span class="p">,</span> <span class="n">sec</span> <span class="o">=</span> <span class="n">i</span><span class="o">.</span><span class="n">split</span><span class="p">(</span><span class="s1">&#39;:&#39;</span><span class="p">)</span>
            <span class="n">hour</span><span class="p">,</span> <span class="n">minute</span><span class="p">,</span> <span class="n">sec</span> <span class="o">=</span> <span class="nb">float</span><span class="p">(</span><span class="n">hour</span><span class="p">),</span> <span class="nb">float</span><span class="p">(</span><span class="n">minute</span><span class="p">),</span> <span class="nb">float</span><span class="p">(</span><span class="n">sec</span><span class="p">)</span>
            <span class="n">out</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">hour</span> <span class="o">*</span> <span class="mi">15</span> <span class="o">+</span> <span class="p">(</span><span class="n">minute</span> <span class="o">/</span> <span class="mi">4</span><span class="p">)</span> <span class="o">+</span> <span class="p">(</span><span class="n">sec</span> <span class="o">/</span> <span class="mi">240</span><span class="p">))</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="nb">print</span><span class="p">(</span><span class="s1">&#39;hms cannot be negative.&#39;</span><span class="p">)</span>

    <span class="k">return</span> <span class="p">[</span><span class="n">out</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="k">if</span> <span class="n">_type</span> <span class="o">==</span> <span class="nb">str</span> <span class="ow">or</span> <span class="nb">len</span><span class="p">(</span><span class="n">hms</span><span class="p">)</span> <span class="o">==</span> <span class="mi">1</span> <span class="k">else</span> <span class="n">out</span><span class="p">][</span><span class="mi">0</span><span class="p">]</span></div>


<div class="viewcode-block" id="dd_to_hms"><a class="viewcode-back" href="../../api/ssapy.utils.dd_to_hms.html#ssapy.utils.dd_to_hms">[docs]</a><span class="k">def</span><span class="w"> </span><span class="nf">dd_to_hms</span><span class="p">(</span><span class="n">degree_decimal</span><span class="p">):</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Converts Decimal Degrees (DD) to Hour-Minute-Second (HMS) format.</span>

<span class="sd">    Parameters:</span>
<span class="sd">    -----------</span>
<span class="sd">        degree_decimal (float or str): </span>
<span class="sd">            - A decimal degree value (float) to be converted to HMS format.</span>
<span class="sd">            - If the input is a string in DMS format (e.g., &quot;12:34:56&quot;), it will be converted to DD </span>
<span class="sd">              using the `dms_to_dd` function before processing.</span>

<span class="sd">    Returns:</span>
<span class="sd">    --------</span>
<span class="sd">        str: A string representing the HMS format (e.g., &quot;12:34:56&quot;). The format includes:</span>
<span class="sd">            - Hours as an integer.</span>
<span class="sd">            - Minutes as an integer.</span>
<span class="sd">            - Seconds as a float (rounded to 4 decimal places if necessary).</span>

<span class="sd">    Notes:</span>
<span class="sd">    ------</span>
<span class="sd">        - Decimal degrees are divided by 15 to convert to hours.</span>
<span class="sd">        - If the input DD value is negative, the function assumes the absolute value for conversion </span>
<span class="sd">          and prints a warning message.</span>
<span class="sd">        - Handles edge cases where seconds reach 60, incrementing minutes accordingly.</span>
<span class="sd">        - Returns seconds as an integer if the value is a whole number.</span>

<span class="sd">    Example:</span>
<span class="sd">    --------</span>
<span class="sd">        &gt;&gt;&gt; dd_to_hms(188.73333333333332)</span>
<span class="sd">        &#39;12:34:56&#39;</span>

<span class="sd">        &gt;&gt;&gt; dd_to_hms(-236.375)</span>
<span class="sd">        &#39;15:45:30&#39;  # Assumes positive value for conversion.</span>

<span class="sd">        &gt;&gt;&gt; dd_to_hms(&quot;12:34:56&quot;)  # DMS string converted to DD first.</span>
<span class="sd">        &#39;0:50:18.4&#39;</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="k">if</span> <span class="nb">type</span><span class="p">(</span><span class="n">degree_decimal</span><span class="p">)</span> <span class="ow">is</span> <span class="nb">str</span><span class="p">:</span>
        <span class="n">degree_decimal</span> <span class="o">=</span> <span class="n">dms_to_dd</span><span class="p">(</span><span class="n">degree_decimal</span><span class="p">)</span>
    <span class="k">if</span> <span class="n">degree_decimal</span> <span class="o">&lt;</span> <span class="mi">0</span><span class="p">:</span>
        <span class="nb">print</span><span class="p">(</span><span class="s1">&#39;dd for HMS conversion cannot be negative, assuming positive.&#39;</span><span class="p">)</span>
        <span class="n">_dd</span> <span class="o">=</span> <span class="o">-</span><span class="n">degree_decimal</span> <span class="o">/</span> <span class="mi">15</span>
    <span class="k">else</span><span class="p">:</span>
        <span class="n">_dd</span> <span class="o">=</span> <span class="n">degree_decimal</span> <span class="o">/</span> <span class="mi">15</span>
    <span class="n">_h</span><span class="p">,</span> <span class="n">__h</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">trunc</span><span class="p">(</span><span class="n">_dd</span><span class="p">),</span> <span class="n">_dd</span> <span class="o">-</span> <span class="n">np</span><span class="o">.</span><span class="n">trunc</span><span class="p">(</span><span class="n">_dd</span><span class="p">)</span>
    <span class="n">_m</span><span class="p">,</span> <span class="n">__m</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">trunc</span><span class="p">(</span><span class="n">__h</span> <span class="o">*</span> <span class="mi">60</span><span class="p">),</span> <span class="n">__h</span> <span class="o">*</span> <span class="mi">60</span> <span class="o">-</span> <span class="n">np</span><span class="o">.</span><span class="n">trunc</span><span class="p">(</span><span class="n">__h</span> <span class="o">*</span> <span class="mi">60</span><span class="p">)</span>
    <span class="n">_s</span> <span class="o">=</span> <span class="nb">round</span><span class="p">(</span><span class="n">__m</span> <span class="o">*</span> <span class="mi">60</span><span class="p">,</span> <span class="mi">4</span><span class="p">)</span>
    <span class="n">_s</span> <span class="o">=</span> <span class="p">[</span><span class="nb">int</span><span class="p">(</span><span class="n">_s</span><span class="p">)</span> <span class="k">if</span> <span class="nb">int</span><span class="p">(</span><span class="n">_s</span><span class="p">)</span> <span class="o">==</span> <span class="n">_s</span> <span class="k">else</span> <span class="n">_s</span><span class="p">][</span><span class="mi">0</span><span class="p">]</span>
    <span class="k">if</span> <span class="n">_s</span> <span class="o">==</span> <span class="mi">60</span><span class="p">:</span>
        <span class="n">_m</span><span class="p">,</span> <span class="n">_s</span> <span class="o">=</span> <span class="n">_m</span> <span class="o">+</span> <span class="mi">1</span><span class="p">,</span> <span class="s1">&#39;00&#39;</span>
    <span class="k">elif</span> <span class="n">_s</span> <span class="o">&gt;</span> <span class="mi">60</span><span class="p">:</span>
        <span class="n">_m</span><span class="p">,</span> <span class="n">_s</span> <span class="o">=</span> <span class="n">_m</span> <span class="o">+</span> <span class="mi">1</span><span class="p">,</span> <span class="n">_s</span> <span class="o">-</span> <span class="mi">60</span>

    <span class="k">return</span> <span class="sa">f</span><span class="s1">&#39;</span><span class="si">{</span><span class="nb">int</span><span class="p">(</span><span class="n">_h</span><span class="p">)</span><span class="si">}</span><span class="s1">:</span><span class="si">{</span><span class="nb">int</span><span class="p">(</span><span class="n">_m</span><span class="p">)</span><span class="si">}</span><span class="s1">:</span><span class="si">{</span><span class="n">_s</span><span class="si">}</span><span class="s1">&#39;</span></div>


<div class="viewcode-block" id="get_times"><a class="viewcode-back" href="../../api/ssapy.utils.get_times.html#ssapy.utils.get_times">[docs]</a><span class="k">def</span><span class="w"> </span><span class="nf">get_times</span><span class="p">(</span><span class="n">duration</span><span class="p">:</span> <span class="n">Tuple</span><span class="p">[</span><span class="nb">int</span><span class="p">,</span> <span class="nb">str</span><span class="p">],</span> <span class="n">freq</span><span class="p">:</span> <span class="n">Tuple</span><span class="p">[</span><span class="nb">int</span><span class="p">,</span> <span class="nb">str</span><span class="p">],</span> <span class="n">t0</span><span class="p">:</span> <span class="n">Union</span><span class="p">[</span><span class="nb">str</span><span class="p">,</span> <span class="n">Time</span><span class="p">]</span> <span class="o">=</span> <span class="s2">&quot;2025-01-01&quot;</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="n">np</span><span class="o">.</span><span class="n">ndarray</span><span class="p">:</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Calculate a list of times spaced equally apart over a specified duration.</span>

<span class="sd">    Parameters</span>
<span class="sd">    ----------</span>
<span class="sd">    duration : tuple</span>
<span class="sd">        A tuple containing the length of time and the unit (e.g., (30, &#39;day&#39;)).</span>
<span class="sd">    freq : tuple</span>
<span class="sd">        A tuple containing the frequency value and its unit (e.g., (1, &#39;hr&#39;)).</span>
<span class="sd">    t0 : str or Time, optional</span>
<span class="sd">        The starting time. Default is &quot;2025-01-01&quot;.</span>

<span class="sd">    Returns</span>
<span class="sd">    -------</span>
<span class="sd">    np.ndarray</span>
<span class="sd">        A list of times spaced equally apart over the specified duration.</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">t0</span><span class="p">,</span> <span class="nb">str</span><span class="p">):</span>
        <span class="n">t0</span> <span class="o">=</span> <span class="n">Time</span><span class="p">(</span><span class="n">t0</span><span class="p">,</span> <span class="n">scale</span><span class="o">=</span><span class="s1">&#39;utc&#39;</span><span class="p">)</span>
    <span class="n">unit_dict</span> <span class="o">=</span> <span class="p">{</span><span class="s1">&#39;second&#39;</span><span class="p">:</span> <span class="mi">1</span><span class="p">,</span> <span class="s1">&#39;sec&#39;</span><span class="p">:</span> <span class="mi">1</span><span class="p">,</span> <span class="s1">&#39;s&#39;</span><span class="p">:</span> <span class="mi">1</span><span class="p">,</span> <span class="s1">&#39;minute&#39;</span><span class="p">:</span> <span class="mi">60</span><span class="p">,</span> <span class="s1">&#39;min&#39;</span><span class="p">:</span> <span class="mi">60</span><span class="p">,</span> <span class="s1">&#39;hour&#39;</span><span class="p">:</span> <span class="mi">3600</span><span class="p">,</span> <span class="s1">&#39;hr&#39;</span><span class="p">:</span> <span class="mi">3600</span><span class="p">,</span> <span class="s1">&#39;h&#39;</span><span class="p">:</span> <span class="mi">3600</span><span class="p">,</span> <span class="s1">&#39;day&#39;</span><span class="p">:</span> <span class="mi">86400</span><span class="p">,</span> <span class="s1">&#39;d&#39;</span><span class="p">:</span> <span class="mi">86400</span><span class="p">,</span> <span class="s1">&#39;week&#39;</span><span class="p">:</span> <span class="mi">604800</span><span class="p">,</span> <span class="s1">&#39;month&#39;</span><span class="p">:</span> <span class="mi">2630016</span><span class="p">,</span> <span class="s1">&#39;mo&#39;</span><span class="p">:</span> <span class="mi">2630016</span><span class="p">,</span> <span class="s1">&#39;year&#39;</span><span class="p">:</span> <span class="mi">31557600</span><span class="p">,</span> <span class="s1">&#39;yr&#39;</span><span class="p">:</span> <span class="mi">31557600</span><span class="p">}</span>
    <span class="n">dur_val</span><span class="p">,</span> <span class="n">dur_unit</span> <span class="o">=</span> <span class="n">duration</span>
    <span class="n">freq_val</span><span class="p">,</span> <span class="n">freq_unit</span> <span class="o">=</span> <span class="n">freq</span>
    <span class="k">if</span> <span class="n">dur_unit</span><span class="p">[</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span> <span class="o">==</span> <span class="s1">&#39;s&#39;</span> <span class="ow">and</span> <span class="nb">len</span><span class="p">(</span><span class="n">dur_unit</span><span class="p">)</span> <span class="o">&gt;</span> <span class="mi">1</span><span class="p">:</span>
        <span class="n">dur_unit</span> <span class="o">=</span> <span class="n">dur_unit</span><span class="p">[:</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span>
    <span class="k">if</span> <span class="n">freq_unit</span><span class="p">[</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span> <span class="o">==</span> <span class="s1">&#39;s&#39;</span> <span class="ow">and</span> <span class="nb">len</span><span class="p">(</span><span class="n">freq_unit</span><span class="p">)</span> <span class="o">&gt;</span> <span class="mi">1</span><span class="p">:</span>
        <span class="n">freq_unit</span> <span class="o">=</span> <span class="n">freq_unit</span><span class="p">[:</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span>
    <span class="k">if</span> <span class="n">dur_unit</span><span class="o">.</span><span class="n">lower</span><span class="p">()</span> <span class="ow">not</span> <span class="ow">in</span> <span class="n">unit_dict</span><span class="p">:</span>
        <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="sa">f</span><span class="s1">&#39;Error, </span><span class="si">{</span><span class="n">dur_unit</span><span class="si">}</span><span class="s1"> is not a valid time unit. Valid options are: </span><span class="si">{</span><span class="s2">&quot;, &quot;</span><span class="o">.</span><span class="n">join</span><span class="p">(</span><span class="n">unit_dict</span><span class="o">.</span><span class="n">keys</span><span class="p">())</span><span class="si">}</span><span class="s1">.&#39;</span><span class="p">)</span>
    <span class="k">if</span> <span class="n">freq_unit</span><span class="o">.</span><span class="n">lower</span><span class="p">()</span> <span class="ow">not</span> <span class="ow">in</span> <span class="n">unit_dict</span><span class="p">:</span>
        <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="sa">f</span><span class="s1">&#39;Error, </span><span class="si">{</span><span class="n">freq_unit</span><span class="si">}</span><span class="s1"> is not a valid time unit. Valid options are: </span><span class="si">{</span><span class="s2">&quot;, &quot;</span><span class="o">.</span><span class="n">join</span><span class="p">(</span><span class="n">unit_dict</span><span class="o">.</span><span class="n">keys</span><span class="p">())</span><span class="si">}</span><span class="s1">.&#39;</span><span class="p">)</span>
    <span class="n">dur_seconds</span> <span class="o">=</span> <span class="n">dur_val</span> <span class="o">*</span> <span class="n">unit_dict</span><span class="p">[</span><span class="n">dur_unit</span><span class="o">.</span><span class="n">lower</span><span class="p">()]</span>
    <span class="n">freq_seconds</span> <span class="o">=</span> <span class="n">freq_val</span> <span class="o">*</span> <span class="n">unit_dict</span><span class="p">[</span><span class="n">freq_unit</span><span class="o">.</span><span class="n">lower</span><span class="p">()]</span>
    <span class="n">timesteps</span> <span class="o">=</span> <span class="nb">int</span><span class="p">(</span><span class="n">dur_seconds</span> <span class="o">/</span> <span class="n">freq_seconds</span><span class="p">)</span> <span class="o">+</span> <span class="mi">1</span>

    <span class="n">times</span> <span class="o">=</span> <span class="n">t0</span> <span class="o">+</span> <span class="n">np</span><span class="o">.</span><span class="n">linspace</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="n">dur_seconds</span><span class="p">,</span> <span class="n">timesteps</span><span class="p">)</span> <span class="o">/</span> <span class="n">unit_dict</span><span class="p">[</span><span class="s1">&#39;day&#39;</span><span class="p">]</span> <span class="o">*</span> <span class="n">u</span><span class="o">.</span><span class="n">day</span>
    <span class="k">return</span> <span class="n">times</span></div>


<div class="viewcode-block" id="interpolate_points_between"><a class="viewcode-back" href="../../api/ssapy.utils.interpolate_points_between.html#ssapy.utils.interpolate_points_between">[docs]</a><span class="k">def</span><span class="w"> </span><span class="nf">interpolate_points_between</span><span class="p">(</span><span class="n">r</span><span class="p">,</span> <span class="n">m</span><span class="p">):</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Interpolates points between the given points.</span>

<span class="sd">    Args:</span>
<span class="sd">        r: An (n, 3) numpy array of the original points.</span>
<span class="sd">        m: The number of points to interpolate between each pair of points.</span>

<span class="sd">    Returns:</span>
<span class="sd">        An (n * m) numpy array of the interpolated points.</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="n">n</span> <span class="o">=</span> <span class="nb">len</span><span class="p">(</span><span class="n">r</span><span class="p">)</span>
    <span class="n">interpolated_points</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">empty</span><span class="p">((</span><span class="mi">0</span><span class="p">,</span> <span class="mi">3</span><span class="p">))</span>
    <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">n</span><span class="p">):</span>
        <span class="c1"># Generate 1D linearly spaced arrays along each axis using np.linspace()</span>
        <span class="n">x</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">linspace</span><span class="p">(</span><span class="n">r</span><span class="p">[</span><span class="n">i</span><span class="p">,</span> <span class="mi">0</span><span class="p">],</span> <span class="n">r</span><span class="p">[</span><span class="n">i</span><span class="p">,</span> <span class="mi">0</span><span class="p">],</span> <span class="n">m</span><span class="p">)</span>
        <span class="n">y</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">linspace</span><span class="p">(</span><span class="n">r</span><span class="p">[</span><span class="n">i</span><span class="p">,</span> <span class="mi">1</span><span class="p">],</span> <span class="n">r</span><span class="p">[</span><span class="n">i</span><span class="p">,</span> <span class="mi">1</span><span class="p">],</span> <span class="n">m</span><span class="p">)</span>
        <span class="n">z</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">linspace</span><span class="p">(</span><span class="n">r</span><span class="p">[</span><span class="n">i</span><span class="p">,</span> <span class="mi">2</span><span class="p">],</span> <span class="n">r</span><span class="p">[</span><span class="n">i</span><span class="p">,</span> <span class="mi">2</span><span class="p">],</span> <span class="n">m</span><span class="p">)</span>
        <span class="n">interpolated_points</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">vstack</span><span class="p">((</span><span class="n">interpolated_points</span><span class="p">,</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">([</span><span class="n">x</span><span class="p">,</span> <span class="n">y</span><span class="p">,</span> <span class="n">z</span><span class="p">])</span><span class="o">.</span><span class="n">T</span><span class="p">))</span>
    <span class="k">return</span> <span class="n">np</span><span class="o">.</span><span class="n">vstack</span><span class="p">((</span><span class="n">interpolated_points</span><span class="p">,</span> <span class="n">r</span><span class="p">[</span><span class="o">-</span><span class="mi">1</span><span class="p">]))</span></div>


<div class="viewcode-block" id="check_lunar_collision"><a class="viewcode-back" href="../../api/ssapy.utils.check_lunar_collision.html#ssapy.utils.check_lunar_collision">[docs]</a><span class="k">def</span><span class="w"> </span><span class="nf">check_lunar_collision</span><span class="p">(</span><span class="n">r</span><span class="p">,</span> <span class="n">times</span><span class="p">,</span> <span class="n">m</span><span class="o">=</span><span class="mi">1000</span><span class="p">):</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Checks if the trajectory of a particle intersects with the Moon.</span>

<span class="sd">    Parameters</span>
<span class="sd">    ----------</span>
<span class="sd">    r : np.array</span>
<span class="sd">        The particle&#39;s trajectory in Cartesian coordinates.</span>
<span class="sd">    times : an array of astropy.Time where r points are calculated.</span>
<span class="sd">    m : int, optional</span>
<span class="sd">        The number of points to interpolate between. Defaults to 1000.</span>

<span class="sd">    Returns</span>
<span class="sd">    -------</span>
<span class="sd">    np.array</span>
<span class="sd">        Indexes where collision occurs.</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="kn">from</span><span class="w"> </span><span class="nn">.body</span><span class="w"> </span><span class="kn">import</span> <span class="n">get_body</span>
    <span class="c1"># For a time step of 1 hour, m=1000 will be sensitive of collisions up to 482 km/s</span>
    <span class="n">new_r</span> <span class="o">=</span> <span class="n">interpolate_points_between</span><span class="p">(</span><span class="n">r</span><span class="p">,</span> <span class="n">m</span><span class="p">)</span>
    <span class="c1"># Time span of integration</span>
    <span class="n">times_new</span> <span class="o">=</span> <span class="n">Time</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">linspace</span><span class="p">(</span><span class="n">times</span><span class="o">.</span><span class="n">decimalyear</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span> <span class="n">times</span><span class="o">.</span><span class="n">decimalyear</span><span class="p">[</span><span class="o">-</span><span class="mi">1</span><span class="p">],</span> <span class="nb">int</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">times</span><span class="p">)</span> <span class="o">*</span> <span class="n">m</span> <span class="o">+</span> <span class="mi">1</span><span class="p">)),</span> <span class="nb">format</span><span class="o">=</span><span class="s1">&#39;decimalyear&#39;</span><span class="p">,</span> <span class="n">scale</span><span class="o">=</span><span class="s1">&#39;utc&#39;</span><span class="p">)</span>
    <span class="n">moon_r</span> <span class="o">=</span> <span class="n">get_body</span><span class="p">(</span><span class="s1">&#39;moon&#39;</span><span class="p">)</span><span class="o">.</span><span class="n">position</span><span class="p">(</span><span class="n">times_new</span><span class="p">)</span><span class="o">.</span><span class="n">T</span>
    <span class="n">collision_index</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">where</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">linalg</span><span class="o">.</span><span class="n">norm</span><span class="p">(</span><span class="n">new_r</span> <span class="o">-</span> <span class="n">moon_r</span><span class="p">,</span> <span class="n">axis</span><span class="o">=-</span><span class="mi">1</span><span class="p">)</span> <span class="o">&lt;</span> <span class="n">MOON_RADIUS</span><span class="p">)</span>
    <span class="k">if</span> <span class="n">np</span><span class="o">.</span><span class="n">size</span><span class="p">(</span><span class="n">collision_index</span><span class="p">)</span> <span class="o">&gt;</span> <span class="mi">0</span><span class="p">:</span>
        <span class="n">collision_times</span> <span class="o">=</span> <span class="n">times_new</span><span class="p">[</span><span class="n">collision_index</span><span class="p">]</span>
        <span class="n">nearest_indices</span> <span class="o">=</span> <span class="n">find_nearest_indices</span><span class="p">(</span><span class="n">times</span><span class="o">.</span><span class="n">decimalyear</span><span class="p">,</span> <span class="n">collision_times</span><span class="o">.</span><span class="n">decimalyear</span><span class="p">)</span>
        <span class="k">return</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">(</span><span class="nb">list</span><span class="p">(</span><span class="nb">set</span><span class="p">(</span><span class="n">nearest_indices</span><span class="p">)))</span>
    <span class="k">else</span><span class="p">:</span>
        <span class="k">return</span> <span class="p">[]</span></div>


<div class="viewcode-block" id="find_nearest_indices"><a class="viewcode-back" href="../../api/ssapy.utils.find_nearest_indices.html#ssapy.utils.find_nearest_indices">[docs]</a><span class="k">def</span><span class="w"> </span><span class="nf">find_nearest_indices</span><span class="p">(</span><span class="n">A</span><span class="p">,</span> <span class="n">B</span><span class="p">):</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Finds the indices of the nearest values in array `A` for each value in array `B`.</span>

<span class="sd">    Parameters:</span>
<span class="sd">    -----------</span>
<span class="sd">        A (array-like): A 1D array or list of values to search within.</span>
<span class="sd">        B (array-like): A 1D array or list of values for which the nearest values in `A` are to be found.</span>

<span class="sd">    Returns:</span>
<span class="sd">    --------</span>
<span class="sd">        numpy.ndarray: A 1D array of indices corresponding to the nearest values in `A` for each value in `B`.</span>

<span class="sd">    Notes:</span>
<span class="sd">    ------</span>
<span class="sd">        - This function uses broadcasting to compute the absolute differences between each element in `B` </span>
<span class="sd">          and all elements in `A`.</span>
<span class="sd">        - The nearest value is determined by finding the index of the minimum absolute difference.</span>
<span class="sd">        - If there are multiple values in `A` equally close to a value in `B`, the index of the first </span>
<span class="sd">          occurrence is returned.</span>

<span class="sd">    Example:</span>
<span class="sd">    --------</span>
<span class="sd">        &gt;&gt;&gt; import numpy as np</span>
<span class="sd">        &gt;&gt;&gt; A = np.array([1, 3, 7, 10])</span>
<span class="sd">        &gt;&gt;&gt; B = np.array([2, 8])</span>
<span class="sd">        &gt;&gt;&gt; find_nearest_indices(A, B)</span>
<span class="sd">        array([1, 2])  # Nearest values are A[1] (3) for B[0] (2) and A[2] (7) for B[1] (8).</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="c1"># Calculate the absolute differences between B and A using broadcasting</span>
    <span class="n">abs_diff</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">abs</span><span class="p">(</span><span class="n">B</span><span class="p">[:,</span> <span class="n">np</span><span class="o">.</span><span class="n">newaxis</span><span class="p">]</span> <span class="o">-</span> <span class="n">A</span><span class="p">)</span>
    <span class="c1"># Find the index of the minimum absolute difference for each element of B</span>
    <span class="n">nearest_indices</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">argmin</span><span class="p">(</span><span class="n">abs_diff</span><span class="p">,</span> <span class="n">axis</span><span class="o">=</span><span class="mi">1</span><span class="p">)</span>
    <span class="k">return</span> <span class="n">nearest_indices</span></div>


<div class="viewcode-block" id="find_smallest_bounding_cube"><a class="viewcode-back" href="../../api/ssapy.utils.find_smallest_bounding_cube.html#ssapy.utils.find_smallest_bounding_cube">[docs]</a><span class="k">def</span><span class="w"> </span><span class="nf">find_smallest_bounding_cube</span><span class="p">(</span><span class="n">r</span><span class="p">:</span> <span class="n">np</span><span class="o">.</span><span class="n">ndarray</span><span class="p">,</span> <span class="n">pad</span><span class="p">:</span> <span class="nb">float</span> <span class="o">=</span> <span class="mf">0.0</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="n">Tuple</span><span class="p">[</span><span class="n">np</span><span class="o">.</span><span class="n">ndarray</span><span class="p">,</span> <span class="n">np</span><span class="o">.</span><span class="n">ndarray</span><span class="p">]:</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Find the smallest bounding cube for a set of 3D coordinates, with optional padding.</span>

<span class="sd">    Parameters:</span>
<span class="sd">    r (np.ndarray): An array of shape (n, 3) containing the 3D coordinates.</span>
<span class="sd">    pad (float): Amount to increase the bounding cube in all dimensions.</span>

<span class="sd">    Returns:</span>
<span class="sd">    tuple: A tuple containing the lower and upper bounds of the bounding cube.</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="n">min_coords</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">min</span><span class="p">(</span><span class="n">r</span><span class="p">,</span> <span class="n">axis</span><span class="o">=</span><span class="mi">0</span><span class="p">)</span>
    <span class="n">max_coords</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">max</span><span class="p">(</span><span class="n">r</span><span class="p">,</span> <span class="n">axis</span><span class="o">=</span><span class="mi">0</span><span class="p">)</span>
    <span class="n">ranges</span> <span class="o">=</span> <span class="n">max_coords</span> <span class="o">-</span> <span class="n">min_coords</span>
    <span class="n">max_range</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">max</span><span class="p">(</span><span class="n">ranges</span><span class="p">)</span>
    <span class="n">center</span> <span class="o">=</span> <span class="p">(</span><span class="n">max_coords</span> <span class="o">+</span> <span class="n">min_coords</span><span class="p">)</span> <span class="o">/</span> <span class="mi">2</span>
    <span class="n">half_side_length</span> <span class="o">=</span> <span class="n">max_range</span> <span class="o">/</span> <span class="mi">2</span> <span class="o">+</span> <span class="n">pad</span>
    <span class="n">lower_bound</span> <span class="o">=</span> <span class="n">center</span> <span class="o">-</span> <span class="n">half_side_length</span>
    <span class="n">upper_bound</span> <span class="o">=</span> <span class="n">center</span> <span class="o">+</span> <span class="n">half_side_length</span>

    <span class="k">return</span> <span class="n">lower_bound</span><span class="p">,</span> <span class="n">upper_bound</span></div>
</pre></div>

           </div>
          </div>
          <footer>

  <hr/>

  <div role="contentinfo">
    <p>&#169; Copyright 2018, Lawrence Livermore National Security, LLC.</p>
  </div>

  Built with <a href="https://www.sphinx-doc.org/">Sphinx</a> using a
    <a href="https://github.com/readthedocs/sphinx_rtd_theme">theme</a>
    provided by <a href="https://readthedocs.org">Read the Docs</a>.
   

</footer>
        </div>
      </div>
    </section>
  </div>
  <script>
      jQuery(function () {
          SphinxRtdTheme.Navigation.enable(true);
      });
  </script> 

</body>
</html>